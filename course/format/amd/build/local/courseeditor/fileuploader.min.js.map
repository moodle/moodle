{"version":3,"file":"fileuploader.min.js","sources":["../../../src/local/courseeditor/fileuploader.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * The course file uploader.\n *\n * This module is used to upload files directly into the course.\n *\n * @module     core_courseformat/local/courseeditor/fileuploader\n * @copyright  2022 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/**\n * @typedef {Object} Handler\n * @property {String} extension the handled extension or * for any\n * @property {String} message the handler message\n * @property {String} module the module name\n */\n\nimport Config from 'core/config';\nimport ModalFactory from 'core/modal_factory';\nimport ModalEvents from 'core/modal_events';\nimport Templates from 'core/templates';\nimport {getFirst} from 'core/normalise';\nimport {prefetchStrings} from 'core/prefetch';\nimport {get_string as getString, get_strings as getStrings} from 'core/str';\nimport {getCourseEditor} from 'core_courseformat/courseeditor';\nimport {processMonitor} from 'core/process_monitor';\nimport {debounce} from 'core/utils';\n\n// Uploading url.\nconst UPLOADURL = Config.wwwroot + '/course/dndupload.php';\nconst DEBOUNCETIMER = 500;\nconst USERCANIGNOREFILESIZELIMITS = -1;\n\n/** @var {ProcessQueue} uploadQueue the internal uploadQueue instance.  */\nlet uploadQueue = null;\n/** @var {Object} handlerManagers the courseId indexed loaded handler managers. */\nlet handlerManagers = {};\n/** @var {Map} courseUpdates the pending course sections updates. */\nlet courseUpdates = new Map();\n/** @var {Object} errors the error messages. */\nlet errors = null;\n\n// Load global strings.\nprefetchStrings('moodle', ['addresourceoractivity', 'upload']);\nprefetchStrings('core_error', ['dndmaxbytes', 'dndread', 'dndupload', 'dndunkownfile']);\n\n/**\n * Class to upload a file into the course.\n * @private\n */\nclass FileUploader {\n    /**\n     * Class constructor.\n     *\n     * @param {number} courseId the course id\n     * @param {number} sectionId the section id\n     * @param {number} sectionNum the section number\n     * @param {File} fileInfo the file information object\n     * @param {Handler} handler the file selected file handler\n     */\n    constructor(courseId, sectionId, sectionNum, fileInfo, handler) {\n        this.courseId = courseId;\n        this.sectionId = sectionId;\n        this.sectionNum = sectionNum;\n        this.fileInfo = fileInfo;\n        this.handler = handler;\n    }\n\n    /**\n     * Execute the file upload and update the state in the given process.\n     *\n     * @param {LoadingProcess} process the process to store the upload result\n     */\n    execute(process) {\n        const fileInfo = this.fileInfo;\n        const xhr = this._createXhrRequest(process);\n        const formData = this._createUploadFormData();\n\n        // Try reading the file to check it is not a folder, before sending it to the server.\n        const reader = new FileReader();\n        reader.onload = function() {\n            // File was read OK - send it to the server.\n            xhr.open(\"POST\", UPLOADURL, true);\n            xhr.send(formData);\n        };\n        reader.onerror = function() {\n            // Unable to read the file (it is probably a folder) - display an error message.\n            process.setError(errors.dndread);\n        };\n        if (fileInfo.size > 0) {\n            // If this is a non-empty file, try reading the first few bytes.\n            // This will trigger reader.onerror() for folders and reader.onload() for ordinary, readable files.\n            reader.readAsText(fileInfo.slice(0, 5));\n        } else {\n            // If you call slice() on a 0-byte folder, before calling readAsText, then Firefox triggers reader.onload(),\n            // instead of reader.onerror().\n            // So, for 0-byte files, just call readAsText on the whole file (and it will trigger load/error functions as expected).\n            reader.readAsText(fileInfo);\n        }\n    }\n\n    /**\n     * Returns the bind version of execute function.\n     *\n     * This method is used to queue the process into a ProcessQueue instance.\n     *\n     * @returns {Function} the bind function to execute the process\n     */\n    getExecutionFunction() {\n        return this.execute.bind(this);\n    }\n\n    /**\n     * Generate a upload XHR file request.\n     *\n     * @param {LoadingProcess} process the current process\n     * @return {XMLHttpRequest} the XHR request\n     */\n    _createXhrRequest(process) {\n        const xhr = new XMLHttpRequest();\n        // Update the progress bar as the file is uploaded.\n        xhr.upload.addEventListener(\n            'progress',\n            (event) => {\n                if (event.lengthComputable) {\n                    const percent = Math.round((event.loaded * 100) / event.total);\n                    process.setPercentage(percent);\n                }\n            },\n            false\n        );\n        // Wait for the AJAX call to complete.\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState == 1) {\n                // Add a 1% just to indicate that it is uploading.\n                process.setPercentage(1);\n            }\n            // State 4 is DONE. Otherwise the connection is still ongoing.\n            if (xhr.readyState != 4) {\n                return;\n            }\n            if (xhr.status == 200) {\n                var result = JSON.parse(xhr.responseText);\n                if (result && result.error == 0) {\n                    // All OK.\n                    this._finishProcess(process);\n                } else {\n                    process.setError(result.error);\n                }\n            } else {\n                process.setError(errors.dndupload);\n            }\n        };\n        return xhr;\n    }\n\n    /**\n     * Upload a file into the course.\n     *\n     * @return {FormData|null} the new form data object\n     */\n    _createUploadFormData() {\n        const formData = new FormData();\n        try {\n            formData.append('repo_upload_file', this.fileInfo);\n        } catch (error) {\n            throw Error(error.dndread);\n        }\n        formData.append('sesskey', Config.sesskey);\n        formData.append('course', this.courseId);\n        formData.append('section', this.sectionNum);\n        formData.append('module', this.handler.module);\n        formData.append('type', 'Files');\n        return formData;\n    }\n\n    /**\n     * Finishes the current process.\n     * @param {LoadingProcess} process the process\n     */\n    _finishProcess(process) {\n        addRefreshSection(this.courseId, this.sectionId);\n        process.setPercentage(100);\n        process.finish();\n    }\n}\n\n/**\n * The file handler manager class.\n *\n * @private\n */\nclass HandlerManager {\n\n    /** @var {Object} lastHandlers the last handlers selected per each file extension. */\n    lastHandlers = {};\n\n    /** @var {Handler[]|null} allHandlers all the available handlers. */\n    allHandlers = null;\n\n    /**\n     * Class constructor.\n     *\n     * @param {Number} courseId\n     */\n    constructor(courseId) {\n        this.courseId = courseId;\n        this.lastUploadId = 0;\n        this.courseEditor = getCourseEditor(courseId);\n        if (!this.courseEditor) {\n            throw Error('Unkown course editor');\n        }\n        this.maxbytes = this.courseEditor.get('course')?.maxbytes ?? 0;\n    }\n\n    /**\n     * Load the course file handlers.\n     */\n    async loadHandlers() {\n        this.allHandlers = await this.courseEditor.getFileHandlersPromise();\n    }\n\n    /**\n     * Extract the file extension from a fileInfo.\n     *\n     * @param {File} fileInfo\n     * @returns {String} the file extension or an empty string.\n     */\n    getFileExtension(fileInfo) {\n        let extension = '';\n        const dotpos = fileInfo.name.lastIndexOf('.');\n        if (dotpos != -1) {\n            extension = fileInfo.name.substring(dotpos + 1, fileInfo.name.length).toLowerCase();\n        }\n        return extension;\n    }\n\n    /**\n     * Check if the file is valid.\n     *\n     * @param {File} fileInfo the file info\n     */\n    validateFile(fileInfo) {\n        if (this.maxbytes !== USERCANIGNOREFILESIZELIMITS && fileInfo.size > this.maxbytes) {\n            throw Error(errors.dndmaxbytes);\n        }\n    }\n\n    /**\n     * Get the file handlers of an specific file.\n     *\n     * @param {File} fileInfo the file indo\n     * @return {Array} Array of handlers\n     */\n    filterHandlers(fileInfo) {\n        const extension = this.getFileExtension(fileInfo);\n        return this.allHandlers.filter(handler => handler.extension == '*' || handler.extension == extension);\n    }\n\n    /**\n     * Get the Handler to upload a specific file.\n     *\n     * It will ask the used if more than one handler is available.\n     *\n     * @param {File} fileInfo the file info\n     * @returns {Promise<Handler|null>} the selected handler or null if the user cancel\n     */\n    async getFileHandler(fileInfo) {\n        const fileHandlers = this.filterHandlers(fileInfo);\n        if (fileHandlers.length == 0) {\n            throw Error(errors.dndunkownfile);\n        }\n        let fileHandler = null;\n        if (fileHandlers.length == 1) {\n            fileHandler = fileHandlers[0];\n        } else {\n            fileHandler = await this.askHandlerToUser(fileHandlers, fileInfo);\n        }\n        return fileHandler;\n    }\n\n    /**\n     * Ask the user to select a specific handler.\n     *\n     * @param {Handler[]} fileHandlers\n     * @param {File} fileInfo the file info\n     * @return {Promise<Handler>} the selected handler\n     */\n    async askHandlerToUser(fileHandlers, fileInfo) {\n        const extension = this.getFileExtension(fileInfo);\n        // Build the modal parameters from the event data.\n        const modalParams = {\n            title: getString('addresourceoractivity', 'moodle'),\n            body: Templates.render(\n                'core_courseformat/fileuploader',\n                this.getModalData(\n                    fileHandlers,\n                    fileInfo,\n                    this.lastHandlers[extension] ?? null\n                )\n            ),\n            type: ModalFactory.types.SAVE_CANCEL,\n            saveButtonText: getString('upload', 'moodle'),\n        };\n        // Create the modal.\n        const modal = await this.modalBodyRenderedPromise(modalParams);\n        const selectedHandler = await this.modalUserAnswerPromise(modal, fileHandlers);\n        // Cancel action.\n        if (selectedHandler === null) {\n            return null;\n        }\n        // Save last selected handler.\n        this.lastHandlers[extension] = selectedHandler.module;\n        return selectedHandler;\n    }\n\n    /**\n     * Generated the modal template data.\n     *\n     * @param {Handler[]} fileHandlers\n     * @param {File} fileInfo the file info\n     * @param {String|null} defaultModule the default module if any\n     * @return {Object} the modal template data.\n     */\n    getModalData(fileHandlers, fileInfo, defaultModule) {\n        const data = {\n            filename: fileInfo.name,\n            uploadid: ++this.lastUploadId,\n            handlers: [],\n        };\n        let hasDefault = false;\n        fileHandlers.forEach((handler, index) => {\n            const isDefault = (defaultModule == handler.module);\n            data.handlers.push({\n                ...handler,\n                selected: isDefault,\n                labelid: `fileuploader_${data.uploadid}`,\n                value: index,\n            });\n            hasDefault = hasDefault || isDefault;\n        });\n        if (!hasDefault && data.handlers.length > 0) {\n            const lastHandler = data.handlers.pop();\n            lastHandler.selected = true;\n            data.handlers.push(lastHandler);\n        }\n        return data;\n    }\n\n    /**\n     * Get the user handler choice.\n     *\n     * Wait for the user answer in the modal and resolve with the selected index.\n     *\n     * @param {Modal} modal the modal instance\n     * @param {Handler[]} fileHandlers the availabvle file handlers\n     * @return {Promise} with the option selected by the user.\n     */\n    modalUserAnswerPromise(modal, fileHandlers) {\n        const modalBody = getFirst(modal.getBody());\n        return new Promise((resolve, reject) => {\n            modal.getRoot().on(\n                ModalEvents.save,\n                event => {\n                    // Get the selected option.\n                    const index = modalBody.querySelector('input:checked').value;\n                    event.preventDefault();\n                    modal.destroy();\n                    if (!fileHandlers[index]) {\n                        reject('Invalid handler selected');\n                    }\n                    resolve(fileHandlers[index]);\n\n                }\n            );\n            modal.getRoot().on(\n                ModalEvents.cancel,\n                () => {\n                    resolve(null);\n                }\n            );\n        });\n    }\n\n    /**\n     * Create a new modal and return a Promise to the body rendered.\n     *\n     * @param {Object} modalParams the modal params\n     * @returns {Promise} the modal body rendered promise\n     */\n    modalBodyRenderedPromise(modalParams) {\n        return new Promise((resolve, reject) => {\n            ModalFactory.create(modalParams).then((modal) => {\n                modal.setRemoveOnClose(true);\n                // Handle body loading event.\n                modal.getRoot().on(ModalEvents.bodyRendered, () => {\n                    resolve(modal);\n                });\n                // Configure some extra modal params.\n                if (modalParams.saveButtonText !== undefined) {\n                    modal.setSaveButtonText(modalParams.saveButtonText);\n                }\n                modal.show();\n                return;\n            }).catch(() => {\n                reject(`Cannot load modal content`);\n            });\n        });\n    }\n}\n\n/**\n * Add a section to refresh.\n *\n * @param {number} courseId the course id\n * @param {number} sectionId the seciton id\n */\nfunction addRefreshSection(courseId, sectionId) {\n    let refresh = courseUpdates.get(courseId);\n    if (!refresh) {\n        refresh = new Set();\n    }\n    refresh.add(sectionId);\n    courseUpdates.set(courseId, refresh);\n    refreshCourseEditors();\n}\n\n/**\n * Debounced processing all pending course refreshes.\n * @private\n */\nconst refreshCourseEditors = debounce(\n    () => {\n        const refreshes = courseUpdates;\n        courseUpdates = new Map();\n        refreshes.forEach((sectionIds, courseId) => {\n            const courseEditor = getCourseEditor(courseId);\n            if (!courseEditor) {\n                return;\n            }\n            courseEditor.dispatch('sectionState', [...sectionIds]);\n        });\n    },\n    DEBOUNCETIMER\n);\n\n/**\n * Load and return the course handler manager instance.\n *\n * @param {Number} courseId the course Id to load\n * @returns {Promise<HandlerManager>} promise of the the loaded handleManager\n */\nasync function loadCourseHandlerManager(courseId) {\n    if (handlerManagers[courseId] !== undefined) {\n        return handlerManagers[courseId];\n    }\n    try {\n        const handlerManager = new HandlerManager(courseId);\n        await handlerManager.loadHandlers();\n        handlerManagers[courseId] = handlerManager;\n    } catch (error) {\n        throw error;\n    }\n    return handlerManagers[courseId];\n}\n\n/**\n * Load all the erros messages at once in the module \"errors\" variable.\n * @param {Number} courseId the course id\n */\nasync function loadErrorStrings(courseId) {\n    if (errors !== null) {\n        return;\n    }\n    const courseEditor = getCourseEditor(courseId);\n    const maxbytestext = courseEditor.get('course')?.maxbytestext ?? '0';\n\n    errors = {};\n    const allStrings = [\n        {key: 'dndmaxbytes', component: 'core_error', param: {size: maxbytestext}},\n        {key: 'dndread', component: 'core_error'},\n        {key: 'dndupload', component: 'core_error'},\n        {key: 'dndunkownfile', component: 'core_error'},\n    ];\n    window.console.log(allStrings);\n    const loadedStrings = await getStrings(allStrings);\n    allStrings.forEach(({key}, index) => {\n        errors[key] = loadedStrings[index];\n    });\n}\n\n/**\n * Start a batch file uploading into the course.\n *\n * @private\n * @param {number} courseId the course id.\n * @param {number} sectionId the section id.\n * @param {number} sectionNum the section number.\n * @param {File} fileInfo the file information object\n * @param {HandlerManager} handlerManager the course handler manager\n */\nconst queueFileUpload = async function(courseId, sectionId, sectionNum, fileInfo, handlerManager) {\n    let handler;\n    uploadQueue = await processMonitor.createProcessQueue();\n    try {\n        handlerManager.validateFile(fileInfo);\n        handler = await handlerManager.getFileHandler(fileInfo);\n    } catch (error) {\n        uploadQueue.addError(fileInfo.name, error.message);\n        return;\n    }\n    // If we don't have a handler means the user cancel the upload.\n    if (!handler) {\n        return;\n    }\n    const fileProcessor = new FileUploader(courseId, sectionId, sectionNum, fileInfo, handler);\n    uploadQueue.addPending(fileInfo.name, fileProcessor.getExecutionFunction());\n};\n\n/**\n * Upload a file to the course.\n *\n * This method will show any necesary modal to handle the request.\n *\n * @param {number} courseId the course id\n * @param {number} sectionId the section id\n * @param {number} sectionNum the section number\n * @param {Array} files and array of files\n */\nexport const uploadFilesToCourse = async function(courseId, sectionId, sectionNum, files) {\n    // Get the course handlers.\n    let handlerManager;\n    try {\n        handlerManager = await loadCourseHandlerManager(courseId);\n        await loadErrorStrings(courseId);\n    } catch (error) {\n        throw error;\n    }\n    for (let index = 0; index < files.length; index++) {\n        const fileInfo = files[index];\n        await queueFileUpload(courseId, sectionId, sectionNum, fileInfo, handlerManager);\n    }\n};\n"],"names":["UPLOADURL","Config","wwwroot","uploadQueue","handlerManagers","courseUpdates","Map","errors","FileUploader","constructor","courseId","sectionId","sectionNum","fileInfo","handler","execute","process","this","xhr","_createXhrRequest","formData","_createUploadFormData","reader","FileReader","onload","open","send","onerror","setError","dndread","size","readAsText","slice","getExecutionFunction","bind","XMLHttpRequest","upload","addEventListener","event","lengthComputable","percent","Math","round","loaded","total","setPercentage","onreadystatechange","readyState","status","result","JSON","parse","responseText","error","_finishProcess","dndupload","FormData","append","Error","sesskey","module","refresh","get","Set","add","set","refreshCourseEditors","addRefreshSection","finish","HandlerManager","lastUploadId","courseEditor","maxbytes","_this$courseEditor$ge2","allHandlers","getFileHandlersPromise","getFileExtension","extension","dotpos","name","lastIndexOf","substring","length","toLowerCase","validateFile","dndmaxbytes","filterHandlers","filter","fileHandlers","dndunkownfile","fileHandler","askHandlerToUser","modalParams","title","body","Templates","render","getModalData","lastHandlers","type","ModalFactory","types","SAVE_CANCEL","saveButtonText","modal","modalBodyRenderedPromise","selectedHandler","modalUserAnswerPromise","defaultModule","data","filename","uploadid","handlers","hasDefault","forEach","index","isDefault","push","selected","labelid","value","lastHandler","pop","modalBody","getBody","Promise","resolve","reject","getRoot","on","ModalEvents","save","querySelector","preventDefault","destroy","cancel","create","then","setRemoveOnClose","bodyRendered","undefined","setSaveButtonText","show","catch","refreshes","sectionIds","dispatch","queueFileUpload","async","handlerManager","processMonitor","createProcessQueue","getFileHandler","addError","message","fileProcessor","addPending","files","loadHandlers","loadCourseHandlerManager","maxbytestext","_courseEditor$get","allStrings","key","component","param","window","console","log","loadedStrings","loadErrorStrings"],"mappings":"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"}