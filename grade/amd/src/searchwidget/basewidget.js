// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * A small modal to search users or grade items within the gradebook.
 *
 * @module    core_grades/searchwidget/basewidget
 * @copyright 2022 Mathew May <mathew.solutions>
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
import * as ModalFactory from 'core/modal_factory';
import * as ModalEvents from 'core/modal_events';
import {debounce} from 'core/utils';
import * as Templates from 'core/templates';

/**
 * Build the base searching widget.
 *
 * @method init
 * @param {Promise} bodyPromise The promise from the callee of the contents to place in the modal body.
 * @param {Array} data An array of all the data generated by the callee.
 * @param {Function} searchFunc Partially applied function we need to manage search the passed dataset.
 * @param {string} modalTitle The name of the search widget.
 * @param {string|null} unsearchableContent The content rendered in a non-searchable area.
 */
export const init = (bodyPromise, data, searchFunc, modalTitle, unsearchableContent = null) => {
    const modal = buildModal(bodyPromise, modalTitle);
    registerListenerEvents(modal, data, searchFunc, unsearchableContent);
};

/**
 * Register chooser related event listeners.
 *
 * @method registerListenerEvents
 * @param {Promise} modal Our modal that we are working with.
 * @param {Array} data An array of all the data generated by the callee.
 * @param {Function} searchFunc Partially applied function we need to manage search the passed dataset.
 * @param {string|null} unsearchableContent The content rendered in a non-searchable area.
 */
const registerListenerEvents = (modal, data, searchFunc, unsearchableContent) => {
    modal.then(modal => {
        // We want to destroy this when the dialog is closed.
        modal.getRoot().on(ModalEvents.hidden, () => {
            modal.destroy();
        });
        // Once the body of the modal has been resolved, add more features.
        modal.getBodyPromise()
            // The return value of getBodyPromise is a jquery object containing the body NodeElement.
            .then(body => body[0])
            .then(body => {
                const searchInput = body.querySelector('input[data-action="search"]');
                const searchResultsContainer = body.querySelector('[data-region="search-results-container-widget"]');

                renderSearchResults(searchResultsContainer, data);

                if (unsearchableContent) {
                    const unsearchableContentContainer = body.querySelector(
                        '[data-region="unsearchable-content-container-widget"]');
                    unsearchableContentContainer.innerHTML += unsearchableContent;
                }

                // The search input is triggered.
                searchInput.addEventListener('input', debounce(() => {
                    // Display the search results.
                    renderSearchResults(
                        searchResultsContainer,
                        debounceCallee(
                            searchInput.value,
                            data,
                            searchFunc()
                        )
                    );
                }, 300));
                return body;
            }).catch();
    }).catch();
};

/**
 * Given an object we want to build a modal ready to show.
 *
 * @method buildModal
 * @param {Promise} bodyPromise Body promise that the caller should resolve.
 * @param {string} modalTitle The name of the search widget.
 * @return {Object} The modal ready to display immediately and render body in later.
 */
const buildModal = (bodyPromise, modalTitle) => {
    return ModalFactory.create({
        type: ModalFactory.types.DEFAULT,
        // TODO: Make this defined by the interface.
        title: modalTitle,
        body: bodyPromise,
        small: true,
        scrollable: false,
        templateContext: {
            classes: 'reportdatasearch modal-sm'
        }
    }).then(modal => {
        modal.show();
        return modal;
    });
};

/**
 * We have a small helper that'll call the curried search function allowing callers to filter
 * the data set however we want rather than defining how data must be filtered.
 *
 * @method debounceCallee
 * @param {String} searchValue The input from the user that we'll search against.
 * @param {Array} data An array of all the data generated by the callee.
 * @param {Function} searchFunction Partially applied function we need to manage search the passed dataset.
 * @return {Array} The filtered subset of the provided data that we'll then render into the results.
 */
const debounceCallee = (searchValue, data, searchFunction) => {
    if (searchValue.length > 0) { // Search query is present.
        return searchFunction(data, searchValue);
    }
    return data;
};

/**
 * Given the output of the callers' search function, render out the results into the modal.
 *
 * @method renderSearchResults
 * @param {HTMLElement} searchResultsContainer The DOM node of the widget where we'll render the provided results.
 * @param {Array} searchResultsData The filtered subset of the provided data that we'll then render into the results.
 */
const renderSearchResults = async(searchResultsContainer, searchResultsData) => {
    const templateData = {
        'searchresults': searchResultsData,
    };
    // Build up the html & js ready to place into the help section.
    const {html, js} = await Templates.renderForPromise('core_grades/searchwidget/searchresults', templateData);
    await Templates.replaceNodeContents(searchResultsContainer, html, js);
};

/**
 * We want to create the basic promises and hooks that the caller will implement, so we can build modals
 * ahead of time and allow the caller to resolve their promises once complete.
 *
 * @method promisesAndResolvers
 * @returns {{bodyPromise: Promise, bodyPromiseResolver}}
 */
export const promisesAndResolvers = () => {
    // We want to show the modal instantly but loading whilst waiting for our data.
    let bodyPromiseResolver;
    const bodyPromise = new Promise(resolve => {
        bodyPromiseResolver = resolve;
    });

    return {bodyPromiseResolver, bodyPromise};
};
