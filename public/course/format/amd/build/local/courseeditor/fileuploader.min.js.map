{"version":3,"file":"fileuploader.min.js","sources":["../../../src/local/courseeditor/fileuploader.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * The course file uploader.\r\n *\r\n * This module is used to upload files directly into the course.\r\n *\r\n * @module     core_courseformat/local/courseeditor/fileuploader\r\n * @copyright  2022 Ferran Recio <ferran@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\n/**\r\n * @typedef {Object} Handler\r\n * @property {String} extension the handled extension or * for any\r\n * @property {String} message the handler message\r\n * @property {String} module the module name\r\n */\r\n\r\nimport Config from 'core/config';\r\nimport ModalSaveCancel from 'core/modal_save_cancel';\r\nimport ModalEvents from 'core/modal_events';\r\nimport Templates from 'core/templates';\r\nimport {getFirst} from 'core/normalise';\r\nimport {prefetchStrings} from 'core/prefetch';\r\nimport {getString, getStrings} from 'core/str';\r\nimport {getCourseEditor} from 'core_courseformat/courseeditor';\r\nimport {processMonitor} from 'core/process_monitor';\r\nimport {debounce} from 'core/utils';\r\n\r\n// Uploading url.\r\nconst UPLOADURL = Config.wwwroot + '/course/dndupload.php';\r\nconst DEBOUNCETIMER = 500;\r\nconst USERCANIGNOREFILESIZELIMITS = -1;\r\n\r\n/** @var {ProcessQueue} uploadQueue the internal uploadQueue instance.  */\r\nlet uploadQueue = null;\r\n/** @var {Object} handlerManagers the courseId indexed loaded handler managers. */\r\nlet handlerManagers = {};\r\n/** @var {Map} courseUpdates the pending course sections updates. */\r\nlet courseUpdates = new Map();\r\n/** @var {Object} errors the error messages. */\r\nlet errors = null;\r\n\r\n// Load global strings.\r\nprefetchStrings('moodle', ['addresourceoractivity', 'upload']);\r\nprefetchStrings('core_error', ['dndmaxbytes', 'dndread', 'dndupload', 'dndunkownfile']);\r\n\r\n/**\r\n * Class to upload a file into the course.\r\n * @private\r\n */\r\nclass FileUploader {\r\n    /**\r\n     * Class constructor.\r\n     *\r\n     * @param {number} courseId the course id\r\n     * @param {number} sectionId the section id\r\n     * @param {number} sectionNum the section number\r\n     * @param {File} fileInfo the file information object\r\n     * @param {Handler} handler the file selected file handler\r\n     */\r\n    constructor(courseId, sectionId, sectionNum, fileInfo, handler) {\r\n        this.courseId = courseId;\r\n        this.sectionId = sectionId;\r\n        this.sectionNum = sectionNum;\r\n        this.fileInfo = fileInfo;\r\n        this.handler = handler;\r\n    }\r\n\r\n    /**\r\n     * Execute the file upload and update the state in the given process.\r\n     *\r\n     * @param {LoadingProcess} process the process to store the upload result\r\n     */\r\n    execute(process) {\r\n        const fileInfo = this.fileInfo;\r\n        const xhr = this._createXhrRequest(process);\r\n        const formData = this._createUploadFormData();\r\n\r\n        // Try reading the file to check it is not a folder, before sending it to the server.\r\n        const reader = new FileReader();\r\n        reader.onload = function() {\r\n            // File was read OK - send it to the server.\r\n            xhr.open(\"POST\", UPLOADURL, true);\r\n            xhr.send(formData);\r\n        };\r\n        reader.onerror = function() {\r\n            // Unable to read the file (it is probably a folder) - display an error message.\r\n            process.setError(errors.dndread);\r\n        };\r\n        if (fileInfo.size > 0) {\r\n            // If this is a non-empty file, try reading the first few bytes.\r\n            // This will trigger reader.onerror() for folders and reader.onload() for ordinary, readable files.\r\n            reader.readAsText(fileInfo.slice(0, 5));\r\n        } else {\r\n            // If you call slice() on a 0-byte folder, before calling readAsText, then Firefox triggers reader.onload(),\r\n            // instead of reader.onerror().\r\n            // So, for 0-byte files, just call readAsText on the whole file (and it will trigger load/error functions as expected).\r\n            reader.readAsText(fileInfo);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the bind version of execute function.\r\n     *\r\n     * This method is used to queue the process into a ProcessQueue instance.\r\n     *\r\n     * @returns {Function} the bind function to execute the process\r\n     */\r\n    getExecutionFunction() {\r\n        return this.execute.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Generate a upload XHR file request.\r\n     *\r\n     * @param {LoadingProcess} process the current process\r\n     * @return {XMLHttpRequest} the XHR request\r\n     */\r\n    _createXhrRequest(process) {\r\n        const xhr = new XMLHttpRequest();\r\n        // Update the progress bar as the file is uploaded.\r\n        xhr.upload.addEventListener(\r\n            'progress',\r\n            (event) => {\r\n                if (event.lengthComputable) {\r\n                    const percent = Math.round((event.loaded * 100) / event.total);\r\n                    process.setPercentage(percent);\r\n                }\r\n            },\r\n            false\r\n        );\r\n        // Wait for the AJAX call to complete.\r\n        xhr.onreadystatechange = () => {\r\n            if (xhr.readyState == 1) {\r\n                // Add a 1% just to indicate that it is uploading.\r\n                process.setPercentage(1);\r\n            }\r\n            // State 4 is DONE. Otherwise the connection is still ongoing.\r\n            if (xhr.readyState != 4) {\r\n                return;\r\n            }\r\n            if (xhr.status == 200) {\r\n                var result = JSON.parse(xhr.responseText);\r\n                if (result && result.error == 0) {\r\n                    // All OK.\r\n                    this._finishProcess(process);\r\n                } else {\r\n                    process.setError(result.error);\r\n                }\r\n            } else {\r\n                process.setError(errors.dndupload);\r\n            }\r\n        };\r\n        return xhr;\r\n    }\r\n\r\n    /**\r\n     * Upload a file into the course.\r\n     *\r\n     * @return {FormData|null} the new form data object\r\n     */\r\n    _createUploadFormData() {\r\n        const formData = new FormData();\r\n        try {\r\n            formData.append('repo_upload_file', this.fileInfo);\r\n        } catch (error) {\r\n            throw Error(error.dndread);\r\n        }\r\n        formData.append('sesskey', Config.sesskey);\r\n        formData.append('course', this.courseId);\r\n        formData.append('section', this.sectionNum);\r\n        formData.append('module', this.handler.module);\r\n        formData.append('type', 'Files');\r\n        return formData;\r\n    }\r\n\r\n    /**\r\n     * Finishes the current process.\r\n     * @param {LoadingProcess} process the process\r\n     */\r\n    _finishProcess(process) {\r\n        addRefreshSection(this.courseId, this.sectionId);\r\n        process.setPercentage(100);\r\n        process.finish();\r\n    }\r\n}\r\n\r\n/**\r\n * The file handler manager class.\r\n *\r\n * @private\r\n */\r\nclass HandlerManager {\r\n\r\n    /** @var {Object} lastHandlers the last handlers selected per each file extension. */\r\n    lastHandlers = {};\r\n\r\n    /** @var {Handler[]|null} allHandlers all the available handlers. */\r\n    allHandlers = null;\r\n\r\n    /**\r\n     * Class constructor.\r\n     *\r\n     * @param {Number} courseId\r\n     */\r\n    constructor(courseId) {\r\n        this.courseId = courseId;\r\n        this.lastUploadId = 0;\r\n        this.courseEditor = getCourseEditor(courseId);\r\n        if (!this.courseEditor) {\r\n            throw Error('Unkown course editor');\r\n        }\r\n        this.maxbytes = this.courseEditor.get('course')?.maxbytes ?? 0;\r\n    }\r\n\r\n    /**\r\n     * Load the course file handlers.\r\n     */\r\n    async loadHandlers() {\r\n        this.allHandlers = await this.courseEditor.getFileHandlersPromise();\r\n    }\r\n\r\n    /**\r\n     * Extract the file extension from a fileInfo.\r\n     *\r\n     * @param {File} fileInfo\r\n     * @returns {String} the file extension or an empty string.\r\n     */\r\n    getFileExtension(fileInfo) {\r\n        let extension = '';\r\n        const dotpos = fileInfo.name.lastIndexOf('.');\r\n        if (dotpos != -1) {\r\n            extension = fileInfo.name.substring(dotpos + 1, fileInfo.name.length).toLowerCase();\r\n        }\r\n        return extension;\r\n    }\r\n\r\n    /**\r\n     * Check if the file is valid.\r\n     *\r\n     * @param {File} fileInfo the file info\r\n     */\r\n    validateFile(fileInfo) {\r\n        if (this.maxbytes !== USERCANIGNOREFILESIZELIMITS && fileInfo.size > this.maxbytes) {\r\n            throw Error(errors.dndmaxbytes);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the file handlers of an specific file.\r\n     *\r\n     * @param {File} fileInfo the file indo\r\n     * @return {Array} Array of handlers\r\n     */\r\n    filterHandlers(fileInfo) {\r\n        const extension = this.getFileExtension(fileInfo);\r\n        return this.allHandlers.filter(handler => handler.extension == '*' || handler.extension == extension);\r\n    }\r\n\r\n    /**\r\n     * Get the Handler to upload a specific file.\r\n     *\r\n     * It will ask the used if more than one handler is available.\r\n     *\r\n     * @param {File} fileInfo the file info\r\n     * @returns {Promise<Handler|null>} the selected handler or null if the user cancel\r\n     */\r\n    async getFileHandler(fileInfo) {\r\n        const fileHandlers = this.filterHandlers(fileInfo);\r\n        if (fileHandlers.length == 0) {\r\n            throw Error(errors.dndunkownfile);\r\n        }\r\n        let fileHandler = null;\r\n        if (fileHandlers.length == 1) {\r\n            fileHandler = fileHandlers[0];\r\n        } else {\r\n            fileHandler = await this.askHandlerToUser(fileHandlers, fileInfo);\r\n        }\r\n        return fileHandler;\r\n    }\r\n\r\n    /**\r\n     * Ask the user to select a specific handler.\r\n     *\r\n     * @param {Handler[]} fileHandlers\r\n     * @param {File} fileInfo the file info\r\n     * @return {Promise<Handler>} the selected handler\r\n     */\r\n    async askHandlerToUser(fileHandlers, fileInfo) {\r\n        const extension = this.getFileExtension(fileInfo);\r\n        // Build the modal parameters from the event data.\r\n        const modalParams = {\r\n            title: getString('addresourceoractivity', 'moodle'),\r\n            body: Templates.render(\r\n                'core_courseformat/fileuploader',\r\n                this.getModalData(\r\n                    fileHandlers,\r\n                    fileInfo,\r\n                    this.lastHandlers[extension] ?? null\r\n                )\r\n            ),\r\n            saveButtonText: getString('upload', 'moodle'),\r\n        };\r\n        // Create the modal.\r\n        const modal = await this.modalBodyRenderedPromise(modalParams);\r\n        const selectedHandler = await this.modalUserAnswerPromise(modal, fileHandlers);\r\n        // Cancel action.\r\n        if (selectedHandler === null) {\r\n            return null;\r\n        }\r\n        // Save last selected handler.\r\n        this.lastHandlers[extension] = selectedHandler.module;\r\n        return selectedHandler;\r\n    }\r\n\r\n    /**\r\n     * Generated the modal template data.\r\n     *\r\n     * @param {Handler[]} fileHandlers\r\n     * @param {File} fileInfo the file info\r\n     * @param {String|null} defaultModule the default module if any\r\n     * @return {Object} the modal template data.\r\n     */\r\n    getModalData(fileHandlers, fileInfo, defaultModule) {\r\n        const data = {\r\n            filename: fileInfo.name,\r\n            uploadid: ++this.lastUploadId,\r\n            handlers: [],\r\n        };\r\n        let hasDefault = false;\r\n        fileHandlers.forEach((handler, index) => {\r\n            const isDefault = (defaultModule == handler.module);\r\n            const optionNumber = index + 1;\r\n            data.handlers.push({\r\n                ...handler,\r\n                selected: isDefault,\r\n                labelid: `fileuploader_${data.uploadid}_${optionNumber}`,\r\n                value: index,\r\n            });\r\n            hasDefault = hasDefault || isDefault;\r\n        });\r\n        if (!hasDefault && data.handlers.length > 0) {\r\n            const lastHandler = data.handlers.pop();\r\n            lastHandler.selected = true;\r\n            data.handlers.push(lastHandler);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Get the user handler choice.\r\n     *\r\n     * Wait for the user answer in the modal and resolve with the selected index.\r\n     *\r\n     * @param {Modal} modal the modal instance\r\n     * @param {Handler[]} fileHandlers the availabvle file handlers\r\n     * @return {Promise} with the option selected by the user.\r\n     */\r\n    modalUserAnswerPromise(modal, fileHandlers) {\r\n        const modalBody = getFirst(modal.getBody());\r\n        return new Promise((resolve, reject) => {\r\n            modal.getRoot().on(\r\n                ModalEvents.save,\r\n                event => {\r\n                    // Get the selected option.\r\n                    const index = modalBody.querySelector('input:checked').value;\r\n                    event.preventDefault();\r\n                    modal.destroy();\r\n                    if (!fileHandlers[index]) {\r\n                        reject('Invalid handler selected');\r\n                    }\r\n                    resolve(fileHandlers[index]);\r\n\r\n                }\r\n            );\r\n            modal.getRoot().on(\r\n                ModalEvents.cancel,\r\n                () => {\r\n                    resolve(null);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create a new modal and return a Promise to the body rendered.\r\n     *\r\n     * @param {Object} modalParams the modal params\r\n     * @returns {Promise} the modal body rendered promise\r\n     */\r\n    modalBodyRenderedPromise(modalParams) {\r\n        return new Promise((resolve, reject) => {\r\n            ModalSaveCancel.create(modalParams).then((modal) => {\r\n                modal.setRemoveOnClose(true);\r\n                // Handle body loading event.\r\n                modal.getRoot().on(ModalEvents.bodyRendered, () => {\r\n                    resolve(modal);\r\n                });\r\n                // Configure some extra modal params.\r\n                if (modalParams.saveButtonText !== undefined) {\r\n                    modal.setSaveButtonText(modalParams.saveButtonText);\r\n                }\r\n                modal.show();\r\n                return;\r\n            }).catch(() => {\r\n                reject(`Cannot load modal content`);\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Add a section to refresh.\r\n *\r\n * @param {number} courseId the course id\r\n * @param {number} sectionId the seciton id\r\n */\r\nfunction addRefreshSection(courseId, sectionId) {\r\n    let refresh = courseUpdates.get(courseId);\r\n    if (!refresh) {\r\n        refresh = new Set();\r\n    }\r\n    refresh.add(sectionId);\r\n    courseUpdates.set(courseId, refresh);\r\n    refreshCourseEditors();\r\n}\r\n\r\n/**\r\n * Debounced processing all pending course refreshes.\r\n * @private\r\n */\r\nconst refreshCourseEditors = debounce(\r\n    () => {\r\n        const refreshes = courseUpdates;\r\n        courseUpdates = new Map();\r\n        refreshes.forEach((sectionIds, courseId) => {\r\n            const courseEditor = getCourseEditor(courseId);\r\n            if (!courseEditor) {\r\n                return;\r\n            }\r\n            courseEditor.dispatch('sectionState', [...sectionIds]);\r\n        });\r\n    },\r\n    DEBOUNCETIMER\r\n);\r\n\r\n/**\r\n * Load and return the course handler manager instance.\r\n *\r\n * @param {Number} courseId the course Id to load\r\n * @returns {Promise<HandlerManager>} promise of the the loaded handleManager\r\n */\r\nasync function loadCourseHandlerManager(courseId) {\r\n    if (handlerManagers[courseId] !== undefined) {\r\n        return handlerManagers[courseId];\r\n    }\r\n    const handlerManager = new HandlerManager(courseId);\r\n    await handlerManager.loadHandlers();\r\n    handlerManagers[courseId] = handlerManager;\r\n    return handlerManagers[courseId];\r\n}\r\n\r\n/**\r\n * Load all the erros messages at once in the module \"errors\" variable.\r\n * @param {Number} courseId the course id\r\n */\r\nasync function loadErrorStrings(courseId) {\r\n    if (errors !== null) {\r\n        return;\r\n    }\r\n    const courseEditor = getCourseEditor(courseId);\r\n    const maxbytestext = courseEditor.get('course')?.maxbytestext ?? '0';\r\n\r\n    errors = {};\r\n    const allStrings = [\r\n        {key: 'dndmaxbytes', component: 'core_error', param: {size: maxbytestext}},\r\n        {key: 'dndread', component: 'core_error'},\r\n        {key: 'dndupload', component: 'core_error'},\r\n        {key: 'dndunkownfile', component: 'core_error'},\r\n    ];\r\n\r\n    const loadedStrings = await getStrings(allStrings);\r\n    allStrings.forEach(({key}, index) => {\r\n        errors[key] = loadedStrings[index];\r\n    });\r\n}\r\n\r\n/**\r\n * Start a batch file uploading into the course.\r\n *\r\n * @private\r\n * @param {number} courseId the course id.\r\n * @param {number} sectionId the section id.\r\n * @param {number} sectionNum the section number.\r\n * @param {File} fileInfo the file information object\r\n * @param {HandlerManager} handlerManager the course handler manager\r\n */\r\nconst queueFileUpload = async function(courseId, sectionId, sectionNum, fileInfo, handlerManager) {\r\n    let handler;\r\n    uploadQueue = await processMonitor.createProcessQueue();\r\n    try {\r\n        handlerManager.validateFile(fileInfo);\r\n        handler = await handlerManager.getFileHandler(fileInfo);\r\n    } catch (error) {\r\n        uploadQueue.addError(fileInfo.name, error.message);\r\n        return;\r\n    }\r\n    // If we don't have a handler means the user cancel the upload.\r\n    if (!handler) {\r\n        return;\r\n    }\r\n    const fileProcessor = new FileUploader(courseId, sectionId, sectionNum, fileInfo, handler);\r\n    uploadQueue.addPending(fileInfo.name, fileProcessor.getExecutionFunction());\r\n};\r\n\r\n/**\r\n * Upload a file to the course.\r\n *\r\n * This method will show any necesary modal to handle the request.\r\n *\r\n * @param {number} courseId the course id\r\n * @param {number} sectionId the section id\r\n * @param {number} sectionNum the section number\r\n * @param {Array} files and array of files\r\n */\r\nexport const uploadFilesToCourse = async function(courseId, sectionId, sectionNum, files) {\r\n    // Get the course handlers.\r\n    const handlerManager = await loadCourseHandlerManager(courseId);\r\n    await loadErrorStrings(courseId);\r\n    for (let index = 0; index < files.length; index++) {\r\n        const fileInfo = files[index];\r\n        await queueFileUpload(courseId, sectionId, sectionNum, fileInfo, handlerManager);\r\n    }\r\n};\r\n"],"names":["UPLOADURL","Config","wwwroot","uploadQueue","handlerManagers","courseUpdates","Map","errors","FileUploader","constructor","courseId","sectionId","sectionNum","fileInfo","handler","execute","process","this","xhr","_createXhrRequest","formData","_createUploadFormData","reader","FileReader","onload","open","send","onerror","setError","dndread","size","readAsText","slice","getExecutionFunction","bind","XMLHttpRequest","upload","addEventListener","event","lengthComputable","percent","Math","round","loaded","total","setPercentage","onreadystatechange","readyState","status","result","JSON","parse","responseText","error","_finishProcess","dndupload","FormData","append","Error","sesskey","module","refresh","get","Set","add","set","refreshCourseEditors","addRefreshSection","finish","HandlerManager","lastUploadId","courseEditor","maxbytes","_this$courseEditor$ge2","allHandlers","getFileHandlersPromise","getFileExtension","extension","dotpos","name","lastIndexOf","substring","length","toLowerCase","validateFile","dndmaxbytes","filterHandlers","filter","fileHandlers","dndunkownfile","fileHandler","askHandlerToUser","modalParams","title","body","Templates","render","getModalData","lastHandlers","saveButtonText","modal","modalBodyRenderedPromise","selectedHandler","modalUserAnswerPromise","defaultModule","data","filename","uploadid","handlers","hasDefault","forEach","index","isDefault","optionNumber","push","selected","labelid","value","lastHandler","pop","modalBody","getBody","Promise","resolve","reject","getRoot","on","ModalEvents","save","querySelector","preventDefault","destroy","cancel","create","then","setRemoveOnClose","bodyRendered","undefined","setSaveButtonText","show","catch","refreshes","sectionIds","dispatch","queueFileUpload","async","handlerManager","processMonitor","createProcessQueue","getFileHandler","addError","message","fileProcessor","addPending","files","loadHandlers","loadCourseHandlerManager","maxbytestext","_courseEditor$get","allStrings","key","component","param","loadedStrings","loadErrorStrings"],"mappings":"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"}