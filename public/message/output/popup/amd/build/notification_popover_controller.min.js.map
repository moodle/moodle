{"version":3,"file":"notification_popover_controller.min.js","sources":["../src/notification_popover_controller.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Controls the notification popover in the nav bar.\r\n *\r\n * See template: message_popup/notification_popover\r\n *\r\n * @module     message_popup/notification_popover_controller\r\n * @class      notification_popover_controller\r\n * @copyright  2016 Ryan Wyllie <ryan@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\ndefine(['jquery', 'core/ajax', 'core/templates', 'core/str', 'core/url',\r\n            'core/notification', 'core/custom_interaction_events', 'core/popover_region_controller',\r\n            'message_popup/notification_repository', 'message_popup/notification_area_events',\r\n            'core/local/aria/focuslock',\r\n        ],\r\n        function($, Ajax, Templates, Str, URL, DebugNotification, CustomEvents,\r\n            PopoverController, NotificationRepo, NotificationAreaEvents, FocusLock) {\r\n\r\n    var SELECTORS = {\r\n        MARK_ALL_READ_BUTTON: '[data-action=\"mark-all-read\"]',\r\n        ALL_NOTIFICATIONS_CONTAINER: '[data-region=\"all-notifications\"]',\r\n        NOTIFICATION: '[data-region=\"notification-content-item-container\"]',\r\n        UNREAD_NOTIFICATION: '[data-region=\"notification-content-item-container\"].unread',\r\n        NOTIFICATION_LINK: '[data-action=\"content-item-link\"]',\r\n        EMPTY_MESSAGE: '[data-region=\"empty-message\"]',\r\n        COUNT_CONTAINER: '[data-region=\"count-container\"]',\r\n        NOTIFICATION_READ_FEEDBACK: '[data-region=\"notification-read-feedback\"]',\r\n        CLOSE_NOTIFICATION_POPOVER: '[data-action=\"close-notification-popover\"]',\r\n    };\r\n\r\n    /**\r\n     * Constructor for the NotificationPopoverController.\r\n     * Extends PopoverRegionController.\r\n     *\r\n     * @param {object} element jQuery object root element of the popover\r\n     */\r\n    var NotificationPopoverController = function(element) {\r\n        // Initialise base class.\r\n        PopoverController.call(this, element);\r\n\r\n        this.markAllReadButton = this.root.find(SELECTORS.MARK_ALL_READ_BUTTON);\r\n        this.unreadCount = 0;\r\n        this.lastQueried = 0;\r\n        this.userId = this.root.attr('data-userid');\r\n        this.container = this.root.find(SELECTORS.ALL_NOTIFICATIONS_CONTAINER);\r\n        this.limit = 20;\r\n        this.offset = 0;\r\n        this.loadedAll = false;\r\n        this.initialLoad = false;\r\n\r\n        // Let's find out how many unread notifications there are.\r\n        this.unreadCount = this.root.find(SELECTORS.COUNT_CONTAINER).html();\r\n    };\r\n\r\n    /**\r\n     * Clone the parent prototype.\r\n     */\r\n    NotificationPopoverController.prototype = Object.create(PopoverController.prototype);\r\n\r\n    /**\r\n     * Make sure the constructor is set correctly.\r\n     */\r\n    NotificationPopoverController.prototype.constructor = NotificationPopoverController;\r\n\r\n    /**\r\n     * Set the correct aria label on the menu toggle button to be read out by screen\r\n     * readers. The message will indicate the state of the unread notifications.\r\n     *\r\n     * @method updateButtonAriaLabel\r\n     */\r\n    NotificationPopoverController.prototype.updateButtonAriaLabel = function() {\r\n        if (this.isMenuOpen()) {\r\n            Str.get_string('hidenotificationwindow', 'message').done(function(string) {\r\n                this.menuToggle.attr('aria-label', string);\r\n            }.bind(this));\r\n        } else {\r\n            if (this.unreadCount) {\r\n                Str.get_string('shownotificationwindowwithcount', 'message', this.unreadCount).done(function(string) {\r\n                    this.menuToggle.attr('aria-label', string);\r\n                }.bind(this));\r\n            } else {\r\n                Str.get_string('shownotificationwindownonew', 'message').done(function(string) {\r\n                    this.menuToggle.attr('aria-label', string);\r\n                }.bind(this));\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Return the jQuery element with the content. This will return either\r\n     * the unread notification container or the all notification container\r\n     * depending on which is currently visible.\r\n     *\r\n     * @method getContent\r\n     * @return {object} jQuery object currently visible content contianer\r\n     */\r\n    NotificationPopoverController.prototype.getContent = function() {\r\n        return this.container;\r\n    };\r\n\r\n    /**\r\n     * Get the offset value for the current state of the popover in order\r\n     * to sent to the backend to correctly paginate the notifications.\r\n     *\r\n     * @method getOffset\r\n     * @return {int} current offset\r\n     */\r\n    NotificationPopoverController.prototype.getOffset = function() {\r\n        return this.offset;\r\n    };\r\n\r\n    /**\r\n     * Increment the offset for the current state, if required.\r\n     *\r\n     * @method incrementOffset\r\n     */\r\n    NotificationPopoverController.prototype.incrementOffset = function() {\r\n        this.offset += this.limit;\r\n    };\r\n\r\n    /**\r\n     * Check if the first load of notification has been triggered for the current\r\n     * state of the popover.\r\n     *\r\n     * @method hasDoneInitialLoad\r\n     * @return {bool} true if first notification loaded, false otherwise\r\n     */\r\n    NotificationPopoverController.prototype.hasDoneInitialLoad = function() {\r\n        return this.initialLoad;\r\n    };\r\n\r\n    /**\r\n     * Check if we've loaded all of the notifications for the current popover\r\n     * state.\r\n     *\r\n     * @method hasLoadedAllContent\r\n     * @return {bool} true if all notifications loaded, false otherwise\r\n     */\r\n    NotificationPopoverController.prototype.hasLoadedAllContent = function() {\r\n        return this.loadedAll;\r\n    };\r\n\r\n    /**\r\n     * Set the state of the loaded all content property for the current state\r\n     * of the popover.\r\n     *\r\n     * @method setLoadedAllContent\r\n     * @param {bool} val True if all content is loaded, false otherwise\r\n     */\r\n    NotificationPopoverController.prototype.setLoadedAllContent = function(val) {\r\n        this.loadedAll = val;\r\n    };\r\n\r\n    /**\r\n     * Show the unread notification count badge on the menu toggle if there\r\n     * are unread notifications, otherwise hide it.\r\n     *\r\n     * @method renderUnreadCount\r\n     */\r\n    NotificationPopoverController.prototype.renderUnreadCount = function() {\r\n        var element = this.root.find(SELECTORS.COUNT_CONTAINER);\r\n\r\n        if (this.unreadCount) {\r\n            element.text(this.unreadCount);\r\n            element.removeClass('hidden');\r\n        } else {\r\n            element.addClass('hidden');\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Hide the unread notification count badge on the menu toggle.\r\n     *\r\n     * @method hideUnreadCount\r\n     */\r\n    NotificationPopoverController.prototype.hideUnreadCount = function() {\r\n        this.root.find(SELECTORS.COUNT_CONTAINER).addClass('hidden');\r\n    };\r\n\r\n    /**\r\n     * Find the notification element for the given id.\r\n     *\r\n     * @param {int} id\r\n     * @method getNotificationElement\r\n     * @return {object|null} The notification element\r\n     */\r\n    NotificationPopoverController.prototype.getNotificationElement = function(id) {\r\n        var element = this.root.find(SELECTORS.NOTIFICATION + '[data-id=\"' + id + '\"]');\r\n        return element.length == 1 ? element : null;\r\n    };\r\n\r\n    /**\r\n     * Render the notification data with the appropriate template and add it to the DOM.\r\n     *\r\n     * @method renderNotifications\r\n     * @param {array} notifications Notification data\r\n     * @param {object} container jQuery object the container to append the rendered notifications\r\n     * @return {object} jQuery promise that is resolved when all notifications have been\r\n     *                  rendered and added to the DOM\r\n     */\r\n    NotificationPopoverController.prototype.renderNotifications = function(notifications, container) {\r\n        var promises = [];\r\n\r\n        $.each(notifications, function(index, notification) {\r\n            // Determine what the offset was when loading this notification.\r\n            var offset = this.getOffset() - this.limit;\r\n            // Update the view more url to contain the offset to allow the notifications\r\n            // page to load to the correct position in the list of notifications.\r\n            notification.viewmoreurl = URL.relativeUrl('/message/output/popup/notifications.php', {\r\n                notificationid: notification.id,\r\n                offset: offset,\r\n            });\r\n\r\n            // Link to mark read page before loading the actual link.\r\n            var notificationurlparams = {\r\n                notificationid: notification.id\r\n            };\r\n\r\n            notification.contexturl = URL.relativeUrl('message/output/popup/mark_notification_read.php', notificationurlparams);\r\n\r\n            var promise = Templates.render('message_popup/notification_content_item', notification)\r\n            .then(function(html, js) {\r\n                return {html: html, js: js};\r\n            });\r\n            promises.push(promise);\r\n        }.bind(this));\r\n\r\n        return $.when.apply($, promises).then(function() {\r\n            // Each of the promises in the when will pass its results as an argument to the function.\r\n            // The order of the arguments will be the order that the promises are passed to when()\r\n            // i.e. the first promise's results will be in the first argument.\r\n            $.each(arguments, function(index, argument) {\r\n                container.append(argument.html);\r\n                Templates.runTemplateJS(argument.js);\r\n            });\r\n            return;\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Send a request for more notifications from the server, if we aren't already\r\n     * loading some and haven't already loaded all of them.\r\n     *\r\n     * Takes into account the current mode of the popover and will request only\r\n     * unread notifications if required.\r\n     *\r\n     * All notifications are marked as read by the server when they are returned.\r\n     *\r\n     * @method loadMoreNotifications\r\n     * @return {object} jQuery promise that is resolved when notifications have been\r\n     *                        retrieved and added to the DOM\r\n     */\r\n    NotificationPopoverController.prototype.loadMoreNotifications = function() {\r\n        if (this.isLoading || this.hasLoadedAllContent()) {\r\n            return $.Deferred().resolve();\r\n        }\r\n\r\n        this.startLoading();\r\n        var request = {\r\n            limit: this.limit,\r\n            offset: this.getOffset(),\r\n            useridto: this.userId,\r\n        };\r\n\r\n        var container = this.getContent();\r\n        return NotificationRepo.query(request).then(function(result) {\r\n            var notifications = result.notifications;\r\n            this.unreadCount = result.unreadcount;\r\n            this.lastQueried = Math.floor(new Date().getTime() / 1000);\r\n            this.setLoadedAllContent(!notifications.length || notifications.length < this.limit);\r\n            this.initialLoad = true;\r\n            this.updateButtonAriaLabel();\r\n\r\n            if (notifications.length) {\r\n                this.incrementOffset();\r\n                return this.renderNotifications(notifications, container);\r\n            }\r\n\r\n            return false;\r\n        }.bind(this))\r\n        .always(function() {\r\n            this.stopLoading();\r\n        }.bind(this));\r\n    };\r\n\r\n    /**\r\n     * Send a request to the server to mark all unread notifications as read and update\r\n     * the unread count and unread notification elements appropriately.\r\n     *\r\n     * @return {Promise}\r\n     * @method markAllAsRead\r\n     */\r\n    NotificationPopoverController.prototype.markAllAsRead = function() {\r\n        this.markAllReadButton.addClass('loading');\r\n\r\n        var request = {\r\n            useridto: this.userId,\r\n            timecreatedto: this.lastQueried,\r\n        };\r\n\r\n        return NotificationRepo.markAllAsRead(request)\r\n            .then(function() {\r\n                this.unreadCount = 0;\r\n                this.root.find(SELECTORS.UNREAD_NOTIFICATION).removeClass('unread');\r\n\r\n                // Set the ARIA live region's contents with the feedback.\r\n                const readFeedback = this.root.get(0).querySelector(SELECTORS.NOTIFICATION_READ_FEEDBACK);\r\n                Str.get_string('notificationsmarkedasread', 'message').done((notificationsmarkedasread) => {\r\n                    readFeedback.innerHTML = notificationsmarkedasread;\r\n                });\r\n            }.bind(this))\r\n            .always(function() {\r\n                this.markAllReadButton.removeClass('loading');\r\n            }.bind(this));\r\n    };\r\n\r\n    /**\r\n     * Add all of the required event listeners for this notification popover.\r\n     *\r\n     * @method registerEventListeners\r\n     */\r\n    NotificationPopoverController.prototype.registerEventListeners = function() {\r\n        CustomEvents.define(this.root, [\r\n            CustomEvents.events.activate,\r\n        ]);\r\n\r\n        // Mark all notifications read if the user activates the mark all as read button.\r\n        this.root.on(CustomEvents.events.activate, SELECTORS.MARK_ALL_READ_BUTTON, function(e, data) {\r\n            if (this.unreadCount > 0) {\r\n                this.markAllAsRead();\r\n            }\r\n\r\n            e.stopPropagation();\r\n            data.originalEvent.preventDefault();\r\n        }.bind(this));\r\n\r\n        // Mark individual notification read if the user activates it.\r\n        this.root.on(CustomEvents.events.activate, SELECTORS.NOTIFICATION_LINK, function(e) {\r\n            var element = $(e.target).closest(SELECTORS.NOTIFICATION);\r\n\r\n            if (element.hasClass('unread')) {\r\n                this.unreadCount--;\r\n                element.removeClass('unread');\r\n            }\r\n\r\n            e.stopPropagation();\r\n        }.bind(this));\r\n\r\n        this.root.on(CustomEvents.events.activate, SELECTORS.CLOSE_NOTIFICATION_POPOVER, function(e) {\r\n            e.preventDefault();\r\n            $(this.root).trigger(CustomEvents.events.escape);\r\n            e.stopPropagation();\r\n        }.bind(this));\r\n\r\n        // Update the notification information when the menu is opened.\r\n        this.root.on(this.events().menuOpened, function() {\r\n            this.hideUnreadCount();\r\n            this.updateButtonAriaLabel();\r\n\r\n            if (!this.hasDoneInitialLoad()) {\r\n                this.loadMoreNotifications();\r\n            }\r\n\r\n            // Lock focus to the popover when it is opened, it is the parent of the container.\r\n            const contentContainer = this.getContentContainer()[0].parentNode;\r\n            FocusLock.trapFocus(contentContainer);\r\n\r\n        }.bind(this));\r\n\r\n        // Update the unread notification count when the menu is closed.\r\n        this.root.on(this.events().menuClosed, function() {\r\n            this.renderUnreadCount();\r\n            this.updateButtonAriaLabel();\r\n            // Lock focus to the popover when it is opened, it is the parent of the container.\r\n            FocusLock.untrapFocus();\r\n        }.bind(this));\r\n\r\n        // Set aria attributes when popover is loading.\r\n        this.root.on(this.events().startLoading, function() {\r\n            this.getContent().attr('aria-busy', 'true');\r\n        }.bind(this));\r\n\r\n        // Set aria attributes when popover is finished loading.\r\n        this.root.on(this.events().stopLoading, function() {\r\n            this.getContent().attr('aria-busy', 'false');\r\n        }.bind(this));\r\n\r\n        // Load more notifications if the user has scrolled to the end of content\r\n        // item list.\r\n        this.getContentContainer().on(CustomEvents.events.scrollBottom, function() {\r\n            if (!this.isLoading && !this.hasLoadedAllContent()) {\r\n                this.loadMoreNotifications();\r\n            }\r\n        }.bind(this));\r\n\r\n        // Stop mouse scroll from propagating to the window element and\r\n        // scrolling the page.\r\n        CustomEvents.define(this.getContentContainer(), [\r\n            CustomEvents.events.scrollLock\r\n        ]);\r\n\r\n        // Listen for when a notification is shown in the notifications page and mark\r\n        // it as read, if it's unread.\r\n        $(document).on(NotificationAreaEvents.notificationShown, function(e, notification) {\r\n            if (!notification.read) {\r\n                var element = this.getNotificationElement(notification.id);\r\n\r\n                if (element) {\r\n                    element.removeClass('unread');\r\n                }\r\n\r\n                this.unreadCount--;\r\n                this.renderUnreadCount();\r\n            }\r\n        }.bind(this));\r\n    };\r\n\r\n    return NotificationPopoverController;\r\n});\r\n"],"names":["define","$","Ajax","Templates","Str","URL","DebugNotification","CustomEvents","PopoverController","NotificationRepo","NotificationAreaEvents","FocusLock","SELECTORS","NotificationPopoverController","element","call","this","markAllReadButton","root","find","unreadCount","lastQueried","userId","attr","container","limit","offset","loadedAll","initialLoad","html","prototype","Object","create","constructor","updateButtonAriaLabel","isMenuOpen","get_string","done","string","menuToggle","bind","getContent","getOffset","incrementOffset","hasDoneInitialLoad","hasLoadedAllContent","setLoadedAllContent","val","renderUnreadCount","text","removeClass","addClass","hideUnreadCount","getNotificationElement","id","length","renderNotifications","notifications","promises","each","index","notification","viewmoreurl","relativeUrl","notificationid","notificationurlparams","contexturl","promise","render","then","js","push","when","apply","arguments","argument","append","runTemplateJS","loadMoreNotifications","isLoading","Deferred","resolve","startLoading","request","useridto","query","result","unreadcount","Math","floor","Date","getTime","always","stopLoading","markAllAsRead","timecreatedto","readFeedback","get","querySelector","notificationsmarkedasread","innerHTML","registerEventListeners","events","activate","on","e","data","stopPropagation","originalEvent","preventDefault","target","closest","hasClass","trigger","escape","menuOpened","contentContainer","getContentContainer","parentNode","trapFocus","menuClosed","untrapFocus","scrollBottom","scrollLock","document","notificationShown","read"],"mappings":"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"}