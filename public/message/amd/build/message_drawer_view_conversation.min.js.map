{"version":3,"file":"message_drawer_view_conversation.min.js","sources":["../src/message_drawer_view_conversation.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Controls the conversation page in the message drawer.\r\n *\r\n * This function handles all of the user actions that the user can take\r\n * when interacting with the conversation page.\r\n *\r\n * It maintains a view state which is a data representation of the view\r\n * and only operates on that data.\r\n *\r\n * The view state is immutable and should never be modified directly. Instead\r\n * all changes to the view state should be done using the StateManager which\r\n * will generate a new version of the view state with the requested changes.\r\n *\r\n * After any changes to the view state the module will call the render function\r\n * to ask the renderer to update the UI.\r\n *\r\n * General rules for this module:\r\n * 1.) Never modify viewState directly. All changes should be via the StateManager.\r\n * 2.) Call render() with the new state when you want to update the UI\r\n * 3.) Never modify the UI directly in this module. This module is only concerned\r\n *     with the data in the view state.\r\n *\r\n * The general flow for a user interaction will be something like:\r\n * User interaction: User clicks \"confirm block\" button to block the other user\r\n *      1.) This module is hears the click\r\n *      2.) This module sends a request to the server to block the user\r\n *      3.) The server responds with the new user profile\r\n *      4.) This module generates a new state using the StateManager with the updated\r\n *          user profile.\r\n *      5.) This module asks the Patcher to generate a patch from the current state and\r\n *          the newly generated state. This patch tells the renderer what has changed\r\n *          between the states.\r\n *      6.) This module gives the Renderer the generated patch. The renderer updates\r\n *          the UI with changes according to the patch.\r\n *\r\n * @module     core_message/message_drawer_view_conversation\r\n * @copyright  2018 Ryan Wyllie <ryan@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\ndefine(\r\n[\r\n    'jquery',\r\n    'core/auto_rows',\r\n    'core/backoff_timer',\r\n    'core/custom_interaction_events',\r\n    'core/notification',\r\n    'core/pending',\r\n    'core/pubsub',\r\n    'core/str',\r\n    'core_message/message_repository',\r\n    'core_message/message_drawer_events',\r\n    'core_message/message_drawer_view_conversation_constants',\r\n    'core_message/message_drawer_view_conversation_patcher',\r\n    'core_message/message_drawer_view_conversation_renderer',\r\n    'core_message/message_drawer_view_conversation_state_manager',\r\n    'core_message/message_drawer_router',\r\n    'core_message/message_drawer_routes',\r\n    'core/emoji/auto_complete',\r\n    'core/emoji/picker'\r\n],\r\nfunction(\r\n    $,\r\n    AutoRows,\r\n    BackOffTimer,\r\n    CustomEvents,\r\n    Notification,\r\n    Pending,\r\n    PubSub,\r\n    Str,\r\n    Repository,\r\n    MessageDrawerEvents,\r\n    Constants,\r\n    Patcher,\r\n    Renderer,\r\n    StateManager,\r\n    MessageDrawerRouter,\r\n    MessageDrawerRoutes,\r\n    initialiseEmojiAutoComplete,\r\n    initialiseEmojiPicker\r\n) {\r\n\r\n    // Contains a cache of all view states that have been loaded so far\r\n    // which saves us having to reload stuff with network requests when\r\n    // switching between conversations.\r\n    var stateCache = {};\r\n    // The current data representation of the view.\r\n    var viewState = null;\r\n    var loadedAllMessages = false;\r\n    var messagesOffset = 0;\r\n    var newMessagesPollTimer = null;\r\n    var isRendering = false;\r\n    var renderBuffer = [];\r\n    // If the UI is currently resetting.\r\n    var isResetting = true;\r\n    // If the UI is currently sending a message.\r\n    var isSendingMessage = false;\r\n    // If the UI is currently deleting a conversation.\r\n    var isDeletingConversationContent = false;\r\n    // A buffer of messages to send.\r\n    var sendMessageBuffer = [];\r\n    // These functions which will be generated when this module is\r\n    // first called. See generateRenderFunction for details.\r\n    var render = null;\r\n    // The list of renderers that have been registered to render\r\n    // this conversation. See generateRenderFunction for details.\r\n    var renderers = [];\r\n\r\n    var NEWEST_FIRST = Constants.NEWEST_MESSAGES_FIRST;\r\n    var LOAD_MESSAGE_LIMIT = Constants.LOAD_MESSAGE_LIMIT;\r\n    var MILLISECONDS_IN_SEC = Constants.MILLISECONDS_IN_SEC;\r\n    var SELECTORS = Constants.SELECTORS;\r\n    var CONVERSATION_TYPES = Constants.CONVERSATION_TYPES;\r\n\r\n    /**\r\n     * Get the other user userid.\r\n     *\r\n     * @return {Number} Userid.\r\n     */\r\n    var getOtherUserId = function() {\r\n        if (!viewState || viewState.type == CONVERSATION_TYPES.PUBLIC) {\r\n            return null;\r\n        }\r\n\r\n        var loggedInUserId = viewState.loggedInUserId;\r\n        if (viewState.type == CONVERSATION_TYPES.SELF) {\r\n            // It's a self-conversation, so the other user is the one logged in.\r\n            return loggedInUserId;\r\n        }\r\n\r\n        var otherUserIds = Object.keys(viewState.members).filter(function(userId) {\r\n            return loggedInUserId != userId;\r\n        });\r\n\r\n        return otherUserIds.length ? otherUserIds[0] : null;\r\n    };\r\n\r\n    /**\r\n     * Search the cache to see if we've already loaded a private conversation\r\n     * with the given user id.\r\n     *\r\n     * @param {Number} userId The id of the other user.\r\n     * @return {Number|null} Conversation id.\r\n     */\r\n    var getCachedPrivateConversationIdFromUserId = function(userId) {\r\n        return Object.keys(stateCache).reduce(function(carry, id) {\r\n            if (!carry) {\r\n                var state = stateCache[id].state;\r\n\r\n                if (state.type != CONVERSATION_TYPES.PUBLIC) {\r\n                    if (userId in state.members) {\r\n                        // We've found a cached conversation for this user!\r\n                        carry = state.id;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return carry;\r\n        }, null);\r\n    };\r\n\r\n    /**\r\n     * Get profile info for logged in user.\r\n     *\r\n     * @param {Object} body Conversation body container element.\r\n     * @return {Object}\r\n     */\r\n    var getLoggedInUserProfile = function(body) {\r\n        return {\r\n            id: parseInt(body.attr('data-user-id'), 10),\r\n            fullname: null,\r\n            profileimageurl: null,\r\n            profileimageurlsmall: null,\r\n            isonline:  null,\r\n            showonlinestatus: null,\r\n            isblocked: null,\r\n            iscontact: null,\r\n            isdeleted: null,\r\n            canmessage: null,\r\n            canmessageevenifblocked: null,\r\n            requirescontact: null,\r\n            contactrequests: [],\r\n            cancreatecontact: null,\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Get the messages offset value to load more messages.\r\n     *\r\n     * @return {Number}\r\n     */\r\n    var getMessagesOffset = function() {\r\n        return messagesOffset;\r\n    };\r\n\r\n    /**\r\n     * Set the messages offset value for loading more messages.\r\n     *\r\n     * @param {Number} value The offset value\r\n     */\r\n    var setMessagesOffset = function(value) {\r\n        messagesOffset = value;\r\n        stateCache[viewState.id].messagesOffset = value;\r\n    };\r\n\r\n    /**\r\n     * Check if all messages have been loaded.\r\n     *\r\n     * @return {Bool}\r\n     */\r\n    var hasLoadedAllMessages = function() {\r\n        return loadedAllMessages;\r\n    };\r\n\r\n    /**\r\n     * Set whether all messages have been loaded or not.\r\n     *\r\n     * @param {Bool} value If all messages have been loaded.\r\n     */\r\n    var setLoadedAllMessages = function(value) {\r\n        loadedAllMessages = value;\r\n        stateCache[viewState.id].loadedAllMessages = value;\r\n    };\r\n\r\n    /**\r\n     * Get the messages container element.\r\n     *\r\n     * @param  {Object} body Conversation body container element.\r\n     * @return {Object} The messages container element.\r\n     */\r\n    var getMessagesContainer = function(body) {\r\n        return body.find(SELECTORS.MESSAGES_CONTAINER);\r\n    };\r\n\r\n    /**\r\n     * Reformat the conversation for an event payload.\r\n     *\r\n     * @param  {Object} state The view state.\r\n     * @return {Object} New formatted conversation.\r\n     */\r\n    var formatConversationForEvent = function(state) {\r\n        return {\r\n            id: state.id,\r\n            name: state.name,\r\n            subname: state.subname,\r\n            imageUrl: state.imageUrl,\r\n            isFavourite: state.isFavourite,\r\n            isMuted: state.isMuted,\r\n            type: state.type,\r\n            totalMemberCount: state.totalMemberCount,\r\n            loggedInUserId: state.loggedInUserId,\r\n            messages: state.messages.map(function(message) {\r\n                return $.extend({}, message);\r\n            }),\r\n            members: Object.keys(state.members).map(function(id) {\r\n                var formattedMember = $.extend({}, state.members[id]);\r\n                formattedMember.contactrequests = state.members[id].contactrequests.map(function(request) {\r\n                    return $.extend({}, request);\r\n                });\r\n                return formattedMember;\r\n            })\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Load up an empty private conversation between the logged in user and the\r\n     * other user. Sets all of the conversation details based on the other user.\r\n     *\r\n     * A conversation isn't created until the user sends the first message.\r\n     *\r\n     * @param  {Object} loggedInUserProfile The logged in user profile.\r\n     * @param  {Number} otherUserId The other user id.\r\n     * @return {Object} Profile returned from repository.\r\n     */\r\n    var loadEmptyPrivateConversation = function(loggedInUserProfile, otherUserId) {\r\n        var loggedInUserId = loggedInUserProfile.id;\r\n        // If the other user id is the same as the logged in user then this is a self\r\n        // conversation.\r\n        var conversationType = loggedInUserId == otherUserId ? CONVERSATION_TYPES.SELF : CONVERSATION_TYPES.PRIVATE;\r\n        var newState = StateManager.setLoadingMembers(viewState, true);\r\n        newState = StateManager.setLoadingMessages(newState, true);\r\n        render(newState);\r\n\r\n        return Repository.getMemberInfo(loggedInUserId, [otherUserId], true, true)\r\n            .then(function(profiles) {\r\n                if (profiles.length) {\r\n                    return profiles[0];\r\n                } else {\r\n                    throw new Error('Unable to load other user profile');\r\n                }\r\n            })\r\n            .then(function(profile) {\r\n                // If the conversation is a self conversation then the profile loaded is the\r\n                // logged in user so only add that to the members array.\r\n                var members = conversationType == CONVERSATION_TYPES.SELF ? [profile] : [profile, loggedInUserProfile];\r\n                var newState = StateManager.addMembers(viewState, members);\r\n                newState = StateManager.setLoadingMembers(newState, false);\r\n                newState = StateManager.setLoadingMessages(newState, false);\r\n                newState = StateManager.setName(newState, profile.fullname);\r\n                newState = StateManager.setType(newState, conversationType);\r\n                newState = StateManager.setImageUrl(newState, profile.profileimageurl);\r\n                newState = StateManager.setTotalMemberCount(newState, members.length);\r\n                render(newState);\r\n                return profile;\r\n            })\r\n            .catch(function(error) {\r\n                var newState = StateManager.setLoadingMembers(viewState, false);\r\n                render(newState);\r\n                Notification.exception(error);\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Create a new state from a conversation object.\r\n     *\r\n     * @param {Object} conversation The conversation object.\r\n     * @param {Number} loggedInUserId The logged in user id.\r\n     * @return {Object} new state.\r\n     */\r\n    var updateStateFromConversation = function(conversation, loggedInUserId) {\r\n        var otherUser = null;\r\n        if (conversation.type == CONVERSATION_TYPES.PRIVATE) {\r\n            // For private conversations, remove current logged in user from the members list to get the other user.\r\n            var otherUsers = conversation.members.filter(function(member) {\r\n                return member.id != loggedInUserId;\r\n            });\r\n            otherUser = otherUsers.length ? otherUsers[0] : null;\r\n        } else if (conversation.type == CONVERSATION_TYPES.SELF) {\r\n            // Self-conversations have only one member.\r\n            otherUser = conversation.members[0];\r\n        }\r\n\r\n        var name = conversation.name;\r\n        var imageUrl = conversation.imageurl;\r\n\r\n        if (conversation.type != CONVERSATION_TYPES.PUBLIC) {\r\n            name = name || otherUser ? otherUser.fullname : '';\r\n            imageUrl = imageUrl || otherUser ? otherUser.profileimageurl : '';\r\n        }\r\n\r\n        var newState = StateManager.addMembers(viewState, conversation.members);\r\n        newState = StateManager.setName(newState, name);\r\n        newState = StateManager.setSubname(newState, conversation.subname);\r\n        newState = StateManager.setType(newState, conversation.type);\r\n        newState = StateManager.setImageUrl(newState, imageUrl);\r\n        newState = StateManager.setTotalMemberCount(newState, conversation.membercount);\r\n        newState = StateManager.setIsFavourite(newState, conversation.isfavourite);\r\n        newState = StateManager.setIsMuted(newState, conversation.ismuted);\r\n        newState = StateManager.addMessages(newState, conversation.messages);\r\n        newState = StateManager.setCanDeleteMessagesForAllUsers(newState, conversation.candeletemessagesforallusers);\r\n        newState = StateManager.setCanSendMessageToConversation(newState, conversation.cansendmessagetoconversation);\r\n        return newState;\r\n    };\r\n\r\n    /**\r\n     * Get the details for a conversation from the conversation id.\r\n     *\r\n     * @param  {Number} conversationId The conversation id.\r\n     * @param  {Object} loggedInUserProfile The logged in user profile.\r\n     * @param  {Number} messageLimit The number of messages to include.\r\n     * @param  {Number} messageOffset The number of messages to skip.\r\n     * @param  {Bool} newestFirst Order messages newest first.\r\n     * @return {Object} Promise resolved when loaded.\r\n     */\r\n    var loadNewConversation = function(\r\n        conversationId,\r\n        loggedInUserProfile,\r\n        messageLimit,\r\n        messageOffset,\r\n        newestFirst\r\n    ) {\r\n        var loggedInUserId = loggedInUserProfile.id;\r\n        var newState = StateManager.setLoadingMembers(viewState, true);\r\n        newState = StateManager.setLoadingMessages(newState, true);\r\n        render(newState);\r\n\r\n        return Repository.getConversation(\r\n            loggedInUserId,\r\n            conversationId,\r\n            true,\r\n            true,\r\n            0,\r\n            0,\r\n            messageLimit + 1,\r\n            messageOffset,\r\n            newestFirst\r\n        )\r\n            .then(function(conversation) {\r\n                if (conversation.messages.length > messageLimit) {\r\n                    conversation.messages = conversation.messages.slice(1);\r\n                } else {\r\n                    setLoadedAllMessages(true);\r\n                }\r\n\r\n                setMessagesOffset(messageOffset + messageLimit);\r\n\r\n                return conversation;\r\n            })\r\n            .then(function(conversation) {\r\n                var hasLoggedInUser = conversation.members.filter(function(member) {\r\n                    return member.id == loggedInUserProfile.id;\r\n                });\r\n\r\n                if (hasLoggedInUser.length < 1) {\r\n                    conversation.members = conversation.members.concat([loggedInUserProfile]);\r\n                }\r\n\r\n                var newState = updateStateFromConversation(conversation, loggedInUserProfile.id);\r\n                newState = StateManager.setLoadingMembers(newState, false);\r\n                newState = StateManager.setLoadingMessages(newState, false);\r\n                return render(newState)\r\n                    .then(function() {\r\n                        return conversation;\r\n                    });\r\n            })\r\n            .then(function() {\r\n                return markConversationAsRead(conversationId);\r\n            })\r\n            .catch(function(error) {\r\n                var newState = StateManager.setLoadingMembers(viewState, false);\r\n                newState = StateManager.setLoadingMessages(newState, false);\r\n                render(newState);\r\n                Notification.exception(error);\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Get the details for a conversation from and existing conversation object.\r\n     *\r\n     * @param  {Object} conversation The conversation object.\r\n     * @param  {Object} loggedInUserProfile The logged in user profile.\r\n     * @param  {Number} messageLimit The number of messages to include.\r\n     * @param  {Bool} newestFirst Order messages newest first.\r\n     * @return {Object} Promise resolved when loaded.\r\n     */\r\n    var loadExistingConversation = function(\r\n        conversation,\r\n        loggedInUserProfile,\r\n        messageLimit,\r\n        newestFirst\r\n    ) {\r\n        var hasLoggedInUser = conversation.members.filter(function(member) {\r\n            return member.id == loggedInUserProfile.id;\r\n        });\r\n\r\n        if (hasLoggedInUser.length < 1) {\r\n            conversation.members = conversation.members.concat([loggedInUserProfile]);\r\n        }\r\n\r\n        var messageCount = conversation.messages.length;\r\n        var hasLoadedEnoughMessages = messageCount >= messageLimit;\r\n        var newState = updateStateFromConversation(conversation, loggedInUserProfile.id);\r\n        newState = StateManager.setLoadingMembers(newState, false);\r\n        newState = StateManager.setLoadingMessages(newState, !hasLoadedEnoughMessages);\r\n        var renderPromise = render(newState);\r\n\r\n        return renderPromise.then(function() {\r\n                if (!hasLoadedEnoughMessages) {\r\n                    // We haven't got enough messages so let's load some more.\r\n                    return loadMessages(conversation.id, messageLimit, messageCount, newestFirst, []);\r\n                } else {\r\n                    // We've got enough messages. No need to load any more for now.\r\n                    return {messages: conversation.messages};\r\n                }\r\n            })\r\n            .then(function() {\r\n                var messages = viewState.messages;\r\n                // Update the offset to reflect the number of messages we've loaded.\r\n                setMessagesOffset(messages.length);\r\n                markConversationAsRead(viewState.id);\r\n\r\n                return messages;\r\n            })\r\n            .catch(Notification.exception);\r\n    };\r\n\r\n    /**\r\n     * Load messages for this conversation and pass them to the renderer.\r\n     *\r\n     * @param  {Number} conversationId Conversation id.\r\n     * @param  {Number} limit Number of messages to load.\r\n     * @param  {Number} offset Get messages from offset.\r\n     * @param  {Bool} newestFirst Get newest messages first.\r\n     * @param  {Array} ignoreList Ignore any messages with ids in this list.\r\n     * @param  {Number|null} timeFrom Only get messages from this time onwards.\r\n     * @return {Promise} renderer promise.\r\n     */\r\n    var loadMessages = function(conversationId, limit, offset, newestFirst, ignoreList, timeFrom) {\r\n        return Repository.getMessages(\r\n                viewState.loggedInUserId,\r\n                conversationId,\r\n                limit ? limit + 1 : limit,\r\n                offset,\r\n                newestFirst,\r\n                timeFrom\r\n            )\r\n            .then(function(result) {\r\n                // Prevent older requests from contaminating the current view.\r\n                if (result.id != viewState.id) {\r\n                    result.messages = [];\r\n                    // Purge old conversation cache to prevent messages lose.\r\n                    if (result.id in stateCache) {\r\n                        delete stateCache[result.id];\r\n                    }\r\n                }\r\n\r\n                return result;\r\n            })\r\n            .then(function(result) {\r\n                if (result.messages.length && ignoreList.length) {\r\n                    result.messages = result.messages.filter(function(message) {\r\n                        // Skip any messages in our ignore list.\r\n                        return ignoreList.indexOf(parseInt(message.id, 10)) < 0;\r\n                    });\r\n                }\r\n\r\n                return result;\r\n            })\r\n            .then(function(result) {\r\n                if (!limit) {\r\n                    return result;\r\n                } else if (result.messages.length > limit) {\r\n                    // Ignore the last result which was just to test if there are more\r\n                    // to load.\r\n                    result.messages = result.messages.slice(0, -1);\r\n                } else {\r\n                    setLoadedAllMessages(true);\r\n                }\r\n\r\n                return result;\r\n            })\r\n            .then(function(result) {\r\n                var membersToAdd = result.members.filter(function(member) {\r\n                    return !(member.id in viewState.members);\r\n                });\r\n                var newState = StateManager.addMembers(viewState, membersToAdd);\r\n                newState = StateManager.addMessages(newState, result.messages);\r\n                newState = StateManager.setLoadingMessages(newState, false);\r\n                return render(newState)\r\n                    .then(function() {\r\n                        return result;\r\n                    });\r\n            })\r\n            .catch(function(error) {\r\n                var newState = StateManager.setLoadingMessages(viewState, false);\r\n                render(newState);\r\n                // Re-throw the error for other error handlers.\r\n                throw error;\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Create a callback function for getting new messages for this conversation.\r\n     *\r\n     * @param  {Number} conversationId Conversation id.\r\n     * @param  {Bool} newestFirst Show newest messages first\r\n     * @return {Function} Callback function that returns a renderer promise.\r\n     */\r\n    var getLoadNewMessagesCallback = function(conversationId, newestFirst) {\r\n        return function() {\r\n            var messages = viewState.messages;\r\n            var mostRecentMessage = messages.length ? messages[messages.length - 1] : null;\r\n            var lastTimeCreated = mostRecentMessage ? mostRecentMessage.timeCreated : null;\r\n\r\n            if (lastTimeCreated && !isResetting && !isSendingMessage && !isDeletingConversationContent) {\r\n                // There may be multiple messages with the same time created value since\r\n                // the accuracy is only down to the second. The server will include these\r\n                // messages in the result (since it does a >= comparison on time from) so\r\n                // we need to filter them back out of the result so that we're left only\r\n                // with the new messages.\r\n                var ignoreMessageIds = [];\r\n                for (var i = messages.length - 1; i >= 0; i--) {\r\n                    var message = messages[i];\r\n                    if (message.timeCreated === lastTimeCreated) {\r\n                        ignoreMessageIds.push(message.id);\r\n                    } else {\r\n                        // Since the messages are ordered in ascending order of time created\r\n                        // we can break as soon as we hit a message with a different time created\r\n                        // because we know all other messages will have lower values.\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                return loadMessages(\r\n                        conversationId,\r\n                        0,\r\n                        0,\r\n                        newestFirst,\r\n                        ignoreMessageIds,\r\n                        lastTimeCreated\r\n                    )\r\n                    .then(function(result) {\r\n                        if (result.messages.length) {\r\n                            // If we found some results then restart the polling timer\r\n                            // because the other user might be sending messages.\r\n                            newMessagesPollTimer.restart();\r\n                            // We've also got a new last message so publish that for other\r\n                            // components to update.\r\n                            var conversation = formatConversationForEvent(viewState);\r\n                            PubSub.publish(MessageDrawerEvents.CONVERSATION_NEW_LAST_MESSAGE, conversation);\r\n                            return markConversationAsRead(conversationId);\r\n                        } else {\r\n                            return result;\r\n                        }\r\n                    });\r\n            }\r\n\r\n            return $.Deferred().resolve().promise();\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Mark a conversation as read.\r\n     *\r\n     * @param  {Number} conversationId The conversation id.\r\n     * @return {Promise} The renderer promise.\r\n     */\r\n    var markConversationAsRead = function(conversationId) {\r\n        var loggedInUserId = viewState.loggedInUserId;\r\n        var pendingPromise = new Pending('core_message/message_drawer_view_conversation:markConversationAsRead');\r\n\r\n        return Repository.markAllConversationMessagesAsRead(loggedInUserId, conversationId)\r\n            .then(function() {\r\n                var newState = StateManager.markMessagesAsRead(viewState, viewState.messages);\r\n                PubSub.publish(MessageDrawerEvents.CONVERSATION_READ, conversationId);\r\n                return render(newState);\r\n            })\r\n            .then(function(result) {\r\n                pendingPromise.resolve();\r\n\r\n                return result;\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Tell the statemanager there is request to block a user and run the renderer\r\n     * to show the block user dialogue.\r\n     *\r\n     * @param {Number} userId User id.\r\n     */\r\n    var requestBlockUser = function(userId) {\r\n        cancelRequest(userId);\r\n        var newState = StateManager.addPendingBlockUsersById(viewState, [userId]);\r\n        render(newState);\r\n    };\r\n\r\n    /**\r\n     * Send the repository a request to block a user, update the statemanager and publish\r\n     * a contact has been blocked.\r\n     *\r\n     * @param  {Number} userId User id of user to block.\r\n     * @return {Promise} Renderer promise.\r\n     */\r\n    var blockUser = function(userId) {\r\n        var newState = StateManager.setLoadingConfirmAction(viewState, true);\r\n        var pendingPromise = new Pending('core_message/message_drawer_view_conversation:blockUser');\r\n\r\n        render(newState);\r\n\r\n        return Repository.blockUser(viewState.loggedInUserId, userId)\r\n            .then(function(profile) {\r\n                var newState = StateManager.addMembers(viewState, [profile]);\r\n                newState = StateManager.removePendingBlockUsersById(newState, [userId]);\r\n                newState = StateManager.setLoadingConfirmAction(newState, false);\r\n                PubSub.publish(MessageDrawerEvents.CONTACT_BLOCKED, userId);\r\n                return render(newState);\r\n            })\r\n            .then(function(result) {\r\n                pendingPromise.resolve();\r\n\r\n                return result;\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Tell the statemanager there is a request to unblock a user and run the renderer\r\n     * to show the unblock user dialogue.\r\n     *\r\n     * @param {Number} userId User id of user to unblock.\r\n     */\r\n    var requestUnblockUser = function(userId) {\r\n        cancelRequest(userId);\r\n        var newState = StateManager.addPendingUnblockUsersById(viewState, [userId]);\r\n        render(newState);\r\n    };\r\n\r\n    /**\r\n     * Send the repository a request to unblock a user, update the statemanager and publish\r\n     * a contact has been unblocked.\r\n     *\r\n     * @param  {Number} userId User id of user to unblock.\r\n     * @return {Promise} Renderer promise.\r\n     */\r\n    var unblockUser = function(userId) {\r\n        var newState = StateManager.setLoadingConfirmAction(viewState, true);\r\n        var pendingPromise = new Pending('core_message/message_drawer_view_conversation:unblockUser');\r\n        render(newState);\r\n\r\n        return Repository.unblockUser(viewState.loggedInUserId, userId)\r\n            .then(function(profile) {\r\n                var newState = StateManager.addMembers(viewState, [profile]);\r\n                newState = StateManager.removePendingUnblockUsersById(newState, [userId]);\r\n                newState = StateManager.setLoadingConfirmAction(newState, false);\r\n                PubSub.publish(MessageDrawerEvents.CONTACT_UNBLOCKED, userId);\r\n                return render(newState);\r\n            })\r\n            .then(function(result) {\r\n                pendingPromise.resolve();\r\n\r\n                return result;\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Tell the statemanager there is a request to remove a user from the contact list\r\n     * and run the renderer to show the remove user from contacts dialogue.\r\n     *\r\n     * @param {Number} userId User id of user to remove from contacts.\r\n     */\r\n    var requestRemoveContact = function(userId) {\r\n        cancelRequest(userId);\r\n        var newState = StateManager.addPendingRemoveContactsById(viewState, [userId]);\r\n        render(newState);\r\n    };\r\n\r\n    /**\r\n     * Send the repository a request to remove a user from the contacts list. update the statemanager\r\n     * and publish a contact has been removed.\r\n     *\r\n     * @param  {Number} userId User id of user to remove from contacts.\r\n     * @return {Promise} Renderer promise.\r\n     */\r\n    var removeContact = function(userId) {\r\n        var newState = StateManager.setLoadingConfirmAction(viewState, true);\r\n        var pendingPromise = new Pending('core_message/message_drawer_view_conversation:removeContact');\r\n        render(newState);\r\n\r\n        return Repository.deleteContacts(viewState.loggedInUserId, [userId])\r\n            .then(function(profiles) {\r\n                var newState = StateManager.addMembers(viewState, profiles);\r\n                newState = StateManager.removePendingRemoveContactsById(newState, [userId]);\r\n                newState = StateManager.setLoadingConfirmAction(newState, false);\r\n                PubSub.publish(MessageDrawerEvents.CONTACT_REMOVED, userId);\r\n                return render(newState);\r\n            })\r\n            .then(function(result) {\r\n                pendingPromise.resolve();\r\n\r\n                return result;\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Tell the statemanager there is a request to add a user to the contact list\r\n     * and run the renderer to show the add user to contacts dialogue.\r\n     *\r\n     * @param {Number} userId User id of user to add to contacts.\r\n     */\r\n    var requestAddContact = function(userId) {\r\n        cancelRequest(userId);\r\n        var newState = StateManager.addPendingAddContactsById(viewState, [userId]);\r\n        render(newState);\r\n    };\r\n\r\n    /**\r\n     * Send the repository a request to add a user to the contacts list. update the statemanager\r\n     * and publish a contact has been added.\r\n     *\r\n     * @param  {Number} userId User id of user to add to contacts.\r\n     * @return {Promise} Renderer promise.\r\n     */\r\n    var addContact = function(userId) {\r\n        var newState = StateManager.setLoadingConfirmAction(viewState, true);\r\n        var pendingPromise = new Pending('core_message/message_drawer_view_conversation:addContactRequests');\r\n        render(newState);\r\n\r\n        return Repository.createContactRequest(viewState.loggedInUserId, userId)\r\n            .then(function(response) {\r\n                if (!response.request) {\r\n                    throw new Error(response.warnings[0].message);\r\n                }\r\n\r\n                return response.request;\r\n            })\r\n            .then(function(request) {\r\n                var newState = StateManager.removePendingAddContactsById(viewState, [userId]);\r\n                newState = StateManager.addContactRequests(newState, [request]);\r\n                newState = StateManager.setLoadingConfirmAction(newState, false);\r\n                return render(newState);\r\n            })\r\n            .then(function(result) {\r\n                pendingPromise.resolve();\r\n\r\n                return result;\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Set the current conversation as a favourite conversation.\r\n     *\r\n     * @return {Promise} Renderer promise.\r\n     */\r\n    var setFavourite = function() {\r\n        var userId = viewState.loggedInUserId;\r\n        var conversationId = viewState.id;\r\n        var pendingPromise = new Pending('core_message/message_drawer_view_conversation:setFavourite');\r\n\r\n        return Repository.setFavouriteConversations(userId, [conversationId])\r\n            .then(function() {\r\n                var newState = StateManager.setIsFavourite(viewState, true);\r\n                return render(newState);\r\n            })\r\n            .then(function() {\r\n                return PubSub.publish(\r\n                    MessageDrawerEvents.CONVERSATION_SET_FAVOURITE,\r\n                    formatConversationForEvent(viewState)\r\n                );\r\n            })\r\n            .then(function(result) {\r\n                pendingPromise.resolve();\r\n\r\n                return result;\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Unset the current conversation as a favourite conversation.\r\n     *\r\n     * @return {Promise} Renderer promise.\r\n     */\r\n    var unsetFavourite = function() {\r\n        var userId = viewState.loggedInUserId;\r\n        var conversationId = viewState.id;\r\n        var pendingPromise = new Pending('core_message/message_drawer_view_conversation:unsetFavourite');\r\n\r\n        return Repository.unsetFavouriteConversations(userId, [conversationId])\r\n            .then(function() {\r\n                var newState = StateManager.setIsFavourite(viewState, false);\r\n                return render(newState);\r\n            })\r\n            .then(function() {\r\n                return PubSub.publish(\r\n                    MessageDrawerEvents.CONVERSATION_UNSET_FAVOURITE,\r\n                    formatConversationForEvent(viewState)\r\n                );\r\n            })\r\n            .then(function(result) {\r\n                pendingPromise.resolve();\r\n\r\n                return result;\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Set the current conversation as a muted conversation.\r\n     *\r\n     * @return {Promise} Renderer promise.\r\n     */\r\n    var setMuted = function() {\r\n        var userId = viewState.loggedInUserId;\r\n        var conversationId = viewState.id;\r\n        var pendingPromise = new Pending('core_message/message_drawer_view_conversation:markConversationAsRead');\r\n\r\n        return Repository.setMutedConversations(userId, [conversationId])\r\n            .then(function() {\r\n                var newState = StateManager.setIsMuted(viewState, true);\r\n                return render(newState);\r\n            })\r\n            .then(function() {\r\n                return PubSub.publish(\r\n                    MessageDrawerEvents.CONVERSATION_SET_MUTED,\r\n                    formatConversationForEvent(viewState)\r\n                );\r\n            })\r\n            .then(function(result) {\r\n                pendingPromise.resolve();\r\n\r\n                return result;\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Unset the current conversation as a muted conversation.\r\n     *\r\n     * @return {Promise} Renderer promise.\r\n     */\r\n    var unsetMuted = function() {\r\n        var userId = viewState.loggedInUserId;\r\n        var conversationId = viewState.id;\r\n\r\n        return Repository.unsetMutedConversations(userId, [conversationId])\r\n            .then(function() {\r\n                var newState = StateManager.setIsMuted(viewState, false);\r\n                return render(newState);\r\n            })\r\n            .then(function() {\r\n                return PubSub.publish(\r\n                    MessageDrawerEvents.CONVERSATION_UNSET_MUTED,\r\n                    formatConversationForEvent(viewState)\r\n                );\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Tell the statemanager there is a request to delete the selected messages\r\n     * and run the renderer to show confirm delete messages dialogue.\r\n     *\r\n     * @param {Number} userId User id.\r\n     */\r\n    var requestDeleteSelectedMessages = function(userId) {\r\n        var selectedMessageIds = viewState.selectedMessageIds;\r\n        cancelRequest(userId);\r\n        var newState = StateManager.addPendingDeleteMessagesById(viewState, selectedMessageIds);\r\n        render(newState);\r\n    };\r\n\r\n    /**\r\n     * Send the repository a request to delete the messages pending deletion. Update the statemanager\r\n     * and publish a message deletion event.\r\n     *\r\n     * @return {Promise} Renderer promise.\r\n     */\r\n    var deleteSelectedMessages = function() {\r\n        var pendingPromise = new Pending('core_message/message_drawer_view_conversation:deleteSelectedMessages');\r\n        var messageIds = viewState.pendingDeleteMessageIds;\r\n        var sentMessages = viewState.messages.filter(function(message) {\r\n            // If a message sendState is null then it means it was loaded from the server or if it's\r\n            // set to sent then it means the user has successfully sent it in this page load.\r\n            return messageIds.indexOf(message.id) >= 0 && (message.sendState == 'sent' || message.sendState === null);\r\n        });\r\n        var newState = StateManager.setLoadingConfirmAction(viewState, true);\r\n\r\n        render(newState);\r\n\r\n        var deleteMessagesPromise = $.Deferred().resolve().promise();\r\n\r\n\r\n        if (sentMessages.length) {\r\n            // We only need to send a request to the server if we're trying to delete messages that\r\n            // have successfully been sent.\r\n            var sentMessageIds = sentMessages.map(function(message) {\r\n                return message.id;\r\n            });\r\n            if (newState.deleteMessagesForAllUsers) {\r\n                deleteMessagesPromise = Repository.deleteMessagesForAllUsers(viewState.loggedInUserId, sentMessageIds);\r\n            } else {\r\n                deleteMessagesPromise = Repository.deleteMessages(viewState.loggedInUserId, sentMessageIds);\r\n            }\r\n        }\r\n\r\n        // Mark that we are deleting content from the  conversation to prevent updates of it.\r\n        isDeletingConversationContent = true;\r\n\r\n        // Stop polling for new messages to the open conversation.\r\n        if (newMessagesPollTimer) {\r\n            newMessagesPollTimer.stop();\r\n        }\r\n\r\n        return deleteMessagesPromise.then(function() {\r\n                var newState = StateManager.removeMessagesById(viewState, messageIds);\r\n                newState = StateManager.removePendingDeleteMessagesById(newState, messageIds);\r\n                newState = StateManager.removeSelectedMessagesById(newState, messageIds);\r\n                newState = StateManager.setLoadingConfirmAction(newState, false);\r\n                newState = StateManager.setDeleteMessagesForAllUsers(newState, false);\r\n\r\n                var prevLastMessage = viewState.messages[viewState.messages.length - 1];\r\n                var newLastMessage = newState.messages.length ? newState.messages[newState.messages.length - 1] : null;\r\n\r\n                if (newLastMessage && newLastMessage.id != prevLastMessage.id) {\r\n                    var conversation = formatConversationForEvent(newState);\r\n                    PubSub.publish(MessageDrawerEvents.CONVERSATION_NEW_LAST_MESSAGE, conversation);\r\n                } else if (!newState.messages.length) {\r\n                    PubSub.publish(MessageDrawerEvents.CONVERSATION_DELETED, newState.id);\r\n                }\r\n\r\n                isDeletingConversationContent = false;\r\n                return render(newState);\r\n            })\r\n            .then(function(result) {\r\n                pendingPromise.resolve();\r\n\r\n                return result;\r\n            })\r\n            .catch(Notification.exception);\r\n    };\r\n\r\n    /**\r\n     * Tell the statemanager there is a request to delete a conversation\r\n     * and run the renderer to show confirm delete conversation dialogue.\r\n     *\r\n     * @param {Number} userId User id of other user.\r\n     */\r\n    var requestDeleteConversation = function(userId) {\r\n        cancelRequest(userId);\r\n        var newState = StateManager.setPendingDeleteConversation(viewState, true);\r\n        render(newState);\r\n    };\r\n\r\n    /**\r\n     * Send the repository a request to delete a conversation. Update the statemanager\r\n     * and publish a conversation deleted event.\r\n     *\r\n     * @return {Promise} Renderer promise.\r\n     */\r\n    var deleteConversation = function() {\r\n        var pendingPromise = new Pending('core_message/message_drawer_view_conversation:markConversationAsRead');\r\n        var newState = StateManager.setLoadingConfirmAction(viewState, true);\r\n        render(newState);\r\n\r\n        // Mark that we are deleting the conversation to prevent updates of it.\r\n        isDeletingConversationContent = true;\r\n\r\n        // Stop polling for new messages to the open conversation.\r\n        if (newMessagesPollTimer) {\r\n            newMessagesPollTimer.stop();\r\n        }\r\n\r\n        return Repository.deleteConversation(viewState.loggedInUserId, viewState.id)\r\n            .then(function() {\r\n                var newState = StateManager.removeMessages(viewState, viewState.messages);\r\n                newState = StateManager.removeSelectedMessagesById(newState, viewState.selectedMessageIds);\r\n                newState = StateManager.setPendingDeleteConversation(newState, false);\r\n                newState = StateManager.setLoadingConfirmAction(newState, false);\r\n                PubSub.publish(MessageDrawerEvents.CONVERSATION_DELETED, newState.id);\r\n\r\n                isDeletingConversationContent = false;\r\n\r\n                return render(newState);\r\n            })\r\n            .then(function(result) {\r\n                pendingPromise.resolve();\r\n\r\n                return result;\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Tell the statemanager to cancel all pending actions.\r\n     *\r\n     * @param  {Number} userId User id.\r\n     */\r\n    var cancelRequest = function(userId) {\r\n        var pendingDeleteMessageIds = viewState.pendingDeleteMessageIds;\r\n        var newState = StateManager.removePendingAddContactsById(viewState, [userId]);\r\n        newState = StateManager.removePendingRemoveContactsById(newState, [userId]);\r\n        newState = StateManager.removePendingUnblockUsersById(newState, [userId]);\r\n        newState = StateManager.removePendingBlockUsersById(newState, [userId]);\r\n        newState = StateManager.removePendingDeleteMessagesById(newState, pendingDeleteMessageIds);\r\n        newState = StateManager.setPendingDeleteConversation(newState, false);\r\n        newState = StateManager.setDeleteMessagesForAllUsers(newState, false);\r\n        render(newState);\r\n    };\r\n\r\n    /**\r\n     * Accept the contact request from the given user.\r\n     *\r\n     * @param  {Number} userId User id of other user.\r\n     * @return {Promise} Renderer promise.\r\n     */\r\n    var acceptContactRequest = function(userId) {\r\n        var pendingPromise = new Pending('core_message/message_drawer_view_conversation:acceptContactRequest');\r\n\r\n        // Search the list of the logged in user's contact requests to find the\r\n        // one from this user.\r\n        var loggedInUserId = viewState.loggedInUserId;\r\n        var requests = viewState.members[userId].contactrequests.filter(function(request) {\r\n            return request.requesteduserid == loggedInUserId;\r\n        });\r\n        var request = requests[0];\r\n        var newState = StateManager.setLoadingConfirmAction(viewState, true);\r\n        render(newState);\r\n\r\n        return Repository.acceptContactRequest(userId, loggedInUserId)\r\n            .then(function(profile) {\r\n                var newState = StateManager.removeContactRequests(viewState, [request]);\r\n                newState = StateManager.addMembers(viewState, [profile]);\r\n                newState = StateManager.setLoadingConfirmAction(newState, false);\r\n                return render(newState);\r\n            })\r\n            .then(function() {\r\n                PubSub.publish(MessageDrawerEvents.CONTACT_ADDED, viewState.members[userId]);\r\n                PubSub.publish(MessageDrawerEvents.CONTACT_REQUEST_ACCEPTED, request);\r\n                return;\r\n            })\r\n            .then(function(result) {\r\n                pendingPromise.resolve();\r\n\r\n                return result;\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Decline the contact request from the given user.\r\n     *\r\n     * @param  {Number} userId User id of other user.\r\n     * @return {Promise} Renderer promise.\r\n     */\r\n    var declineContactRequest = function(userId) {\r\n        var pendingPromise = new Pending('core_message/message_drawer_view_conversation:declineContactRequest');\r\n\r\n        // Search the list of the logged in user's contact requests to find the\r\n        // one from this user.\r\n        var loggedInUserId = viewState.loggedInUserId;\r\n        var requests = viewState.members[userId].contactrequests.filter(function(request) {\r\n            return request.requesteduserid == loggedInUserId;\r\n        });\r\n        var request = requests[0];\r\n        var newState = StateManager.setLoadingConfirmAction(viewState, true);\r\n        render(newState);\r\n\r\n        return Repository.declineContactRequest(userId, loggedInUserId)\r\n            .then(function(profile) {\r\n                var newState = StateManager.removeContactRequests(viewState, [request]);\r\n                newState = StateManager.addMembers(viewState, [profile]);\r\n                newState = StateManager.setLoadingConfirmAction(newState, false);\r\n                return render(newState);\r\n            })\r\n            .then(function() {\r\n                PubSub.publish(MessageDrawerEvents.CONTACT_REQUEST_DECLINED, request);\r\n                return;\r\n            })\r\n            .then(function(result) {\r\n                pendingPromise.resolve();\r\n\r\n                return result;\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Send all of the messages in the buffer to the server to be created. Update the\r\n     * UI with the newly created message information.\r\n     *\r\n     * This function will recursively call itself in order to make sure the buffer is\r\n     * always being processed.\r\n     */\r\n    var processSendMessageBuffer = function() {\r\n        if (isSendingMessage) {\r\n            // We're already sending messages so nothing to do.\r\n            return;\r\n        }\r\n        if (!sendMessageBuffer.length) {\r\n            // No messages waiting to send. Nothing to do.\r\n            return;\r\n        }\r\n\r\n        var pendingPromise = new Pending('core_message/message_drawer_view_conversation:processSendMessageBuffer');\r\n\r\n        // Flag that we're processing the queue.\r\n        isSendingMessage = true;\r\n        // Grab all of the messages in the buffer.\r\n        var messagesToSend = sendMessageBuffer.slice();\r\n        // Empty the buffer since we're processing it.\r\n        sendMessageBuffer = [];\r\n        var conversationId = viewState.id;\r\n        var newConversationId = null;\r\n        var messagesText = messagesToSend.map(function(message) {\r\n            return message.text;\r\n        });\r\n        var messageIds = messagesToSend.map(function(message) {\r\n            return message.id;\r\n        });\r\n        var sendMessagePromise = null;\r\n        var newCanDeleteMessagesForAllUsers = null;\r\n        if (!conversationId && (viewState.type != CONVERSATION_TYPES.PUBLIC)) {\r\n            // If it's a new private conversation then we need to use the old\r\n            // web service function to create the conversation.\r\n            var otherUserId = getOtherUserId();\r\n            sendMessagePromise = Repository.sendMessagesToUser(otherUserId, messagesText)\r\n                .then(function(messages) {\r\n                    if (messages.length) {\r\n                        newConversationId = parseInt(messages[0].conversationid, 10);\r\n                        newCanDeleteMessagesForAllUsers = messages[0].candeletemessagesforallusers;\r\n                    }\r\n                    return messages;\r\n                });\r\n        } else {\r\n            sendMessagePromise = Repository.sendMessagesToConversation(conversationId, messagesText);\r\n        }\r\n\r\n        sendMessagePromise\r\n            .then(function(messages) {\r\n                var newMessageIds = messages.map(function(message) {\r\n                    return message.id;\r\n                });\r\n                var data = [];\r\n                var selectedToRemove = [];\r\n                var selectedToAdd = [];\r\n\r\n                messagesToSend.forEach(function(oldMessage, index) {\r\n                    var newMessage = messages[index];\r\n                    // Update messages expects and array of arrays where the first value\r\n                    // is the old message to update and the second value is the new values\r\n                    // to set.\r\n                    data.push([oldMessage, newMessage]);\r\n\r\n                    if (viewState.selectedMessageIds.indexOf(oldMessage.id) >= 0) {\r\n                        // If the message was added to the \"selected messages\" list while it was still\r\n                        // being sent then we should update it's id in that list now to make sure future\r\n                        // actions work.\r\n                        selectedToRemove.push(oldMessage.id);\r\n                        selectedToAdd.push(newMessage.id);\r\n                    }\r\n                });\r\n                var newState = StateManager.updateMessages(viewState, data);\r\n                newState = StateManager.setMessagesSendSuccessById(newState, newMessageIds);\r\n\r\n                if (selectedToRemove.length) {\r\n                    newState = StateManager.removeSelectedMessagesById(newState, selectedToRemove);\r\n                }\r\n\r\n                if (selectedToAdd.length) {\r\n                    newState = StateManager.addSelectedMessagesById(newState, selectedToAdd);\r\n                }\r\n\r\n                var conversation = formatConversationForEvent(newState);\r\n\r\n                if (!newState.id) {\r\n                    // If this message created the conversation then save the conversation\r\n                    // id.\r\n                    newState = StateManager.setId(newState, newConversationId);\r\n                    conversation.id = newConversationId;\r\n                    resetMessagePollTimer(newConversationId);\r\n                    PubSub.publish(MessageDrawerEvents.CONVERSATION_CREATED, conversation);\r\n                    newState = StateManager.setCanDeleteMessagesForAllUsers(newState, newCanDeleteMessagesForAllUsers);\r\n                }\r\n\r\n                // Update the UI with the new message values from the server.\r\n                render(newState);\r\n                // Recurse just in case there has been more messages added to the buffer.\r\n                isSendingMessage = false;\r\n                processSendMessageBuffer();\r\n                PubSub.publish(MessageDrawerEvents.CONVERSATION_NEW_LAST_MESSAGE, conversation);\r\n                return;\r\n            })\r\n            .then(function(result) {\r\n                pendingPromise.resolve();\r\n\r\n                return result;\r\n            })\r\n            .catch(function(e) {\r\n                var errorMessage;\r\n                if (e.message) {\r\n                    errorMessage = $.Deferred().resolve(e.message).promise();\r\n                } else {\r\n                    errorMessage = Str.get_string('unknownerror', 'core');\r\n                }\r\n\r\n                var handleFailedMessages = function(errorMessage) {\r\n                    // We failed to create messages so remove the old messages from the pending queue\r\n                    // and update the UI to indicate that the message failed.\r\n                    var newState = StateManager.setMessagesSendFailById(viewState, messageIds, errorMessage);\r\n                    render(newState);\r\n                    isSendingMessage = false;\r\n                    processSendMessageBuffer();\r\n                };\r\n\r\n                errorMessage.then(handleFailedMessages)\r\n                    .then(function(result) {\r\n                        pendingPromise.resolve();\r\n\r\n                        return result;\r\n                    })\r\n                    .catch(function(e) {\r\n                        // Hrmm, we can't even load the error messages string! We'll have to\r\n                        // hard code something in English here if we still haven't got a message\r\n                        // to show.\r\n                        var finalError = e.message || 'Something went wrong!';\r\n                        handleFailedMessages(finalError);\r\n                    });\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Create a plain version of an HTML text.\r\n     *\r\n     * This texts is used as a message preview while is sent to the server. This way\r\n     * it is possible to prevent self-xss.\r\n     *\r\n     * @param {String} text Text to send.\r\n     * @return {String} The plain text version of the text.\r\n     */\r\n    const previewText = function(text) {\r\n        // Remove all script and styles from text (we don't want it there).\r\n        let plaintext = text.replace(/<style([\\s\\S]*?)<\\/style>/gi, '');\r\n        plaintext = plaintext.replace(/<script([\\s\\S]*?)<\\/script>/gi, '');\r\n        // Beautify a bit the output adding some line breaks.\r\n        plaintext = plaintext.replace(/<\\/div>/ig, '\\n');\r\n        plaintext = plaintext.replace(/<\\/li>/ig, '\\n');\r\n        plaintext = plaintext.replace(/<li>/ig, '  *  ');\r\n        plaintext = plaintext.replace(/<\\/ul>/ig, '\\n');\r\n        plaintext = plaintext.replace(/<\\/p>/ig, '\\n');\r\n        plaintext = plaintext.replace(/<br[^>]*>/gi, '\\n');\r\n        // Remove all remaining tags and convert line breaks into html.\r\n        plaintext = plaintext.replace(/<[^>]+>/ig, '');\r\n        plaintext = plaintext.replace(/\\n+/ig, '\\n');\r\n        return plaintext.replace(/\\n/ig, '<br>');\r\n    };\r\n\r\n    /**\r\n     * Buffers messages to be sent to the server. We use a buffer here to allow the\r\n     * user to freely input messages without blocking the interface for them.\r\n     *\r\n     * Instead we just queue all of their messages up and send them as fast as we can.\r\n     *\r\n     * @param {String} text Text to send.\r\n     */\r\n    var sendMessage = function(text) {\r\n        var id = 'temp' + Date.now();\r\n        // Render a preview version of the message while sending.\r\n        let loadingmessage = {\r\n            id: id,\r\n            useridfrom: viewState.loggedInUserId,\r\n            text:  previewText(text),\r\n            timecreated: null\r\n        };\r\n        var newState = StateManager.addMessages(viewState, [loadingmessage]);\r\n        render(newState);\r\n        // Send the real message.\r\n        var message = {\r\n            id: id,\r\n            useridfrom: viewState.loggedInUserId,\r\n            text: text,\r\n            timecreated: null\r\n        };\r\n        sendMessageBuffer.push(message);\r\n        processSendMessageBuffer();\r\n\r\n        // Remove the unsent message attribute so we can be notified of new unsent messages (see storeUnsentMessage).\r\n        const textArea = document.querySelector(SELECTORS.MESSAGE_TEXT_AREA);\r\n        if (textArea) {\r\n            textArea.removeAttribute('data-unsent-message-viewed');\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Retry sending a message that failed.\r\n     *\r\n     * @param {Object} message The message to send.\r\n     */\r\n    var retrySendMessage = function(message) {\r\n        var newState = StateManager.setMessagesSendPendingById(viewState, [message.id]);\r\n        render(newState);\r\n        sendMessageBuffer.push(message);\r\n        processSendMessageBuffer();\r\n    };\r\n\r\n    /**\r\n     * Toggle the selected messages update the statemanager and render the result.\r\n     *\r\n     * @param  {Number} messageId The id of the message to be toggled\r\n     */\r\n    var toggleSelectMessage = function(messageId) {\r\n        var newState = viewState;\r\n\r\n        if (viewState.selectedMessageIds.indexOf(messageId) > -1) {\r\n            newState = StateManager.removeSelectedMessagesById(viewState, [messageId]);\r\n        } else {\r\n            newState = StateManager.addSelectedMessagesById(viewState, [messageId]);\r\n        }\r\n\r\n        render(newState);\r\n    };\r\n\r\n    /**\r\n     * Cancel edit mode (selecting the messages).\r\n     */\r\n    var cancelEditMode = function() {\r\n        cancelRequest(getOtherUserId());\r\n        var newState = StateManager.removeSelectedMessagesById(viewState, viewState.selectedMessageIds);\r\n        render(newState);\r\n    };\r\n\r\n    /**\r\n     * Process the patches in the render buffer one at a time in order until the\r\n     * buffer is empty.\r\n     *\r\n     * @param {Object} header The conversation header container element.\r\n     * @param {Object} body The conversation body container element.\r\n     * @param {Object} footer The conversation footer container element.\r\n     */\r\n    var processRenderBuffer = function(header, body, footer) {\r\n        if (isRendering) {\r\n            return;\r\n        }\r\n\r\n        if (!renderBuffer.length) {\r\n            return;\r\n        }\r\n\r\n        isRendering = true;\r\n        var renderable = renderBuffer.shift();\r\n        var renderPromises = renderers.map(function(renderFunc) {\r\n            return renderFunc(renderable.patch);\r\n        });\r\n\r\n        $.when.apply(null, renderPromises)\r\n            .then(function() {\r\n                isRendering = false;\r\n                renderable.deferred.resolve(true);\r\n                // Keep processing the buffer until it's empty.\r\n                processRenderBuffer(header, body, footer);\r\n\r\n                return;\r\n            })\r\n            .catch(function(error) {\r\n                isRendering = false;\r\n                renderable.deferred.reject(error);\r\n                Notification.exception(error);\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Create a function to render the Conversation.\r\n     *\r\n     * @param  {Object} header The conversation header container element.\r\n     * @param  {Object} body The conversation body container element.\r\n     * @param  {Object} footer The conversation footer container element.\r\n     * @param  {Bool} isNewConversation Has someone else already initialised a conversation?\r\n     * @return {Promise} Renderer promise.\r\n     */\r\n    var generateRenderFunction = function(header, body, footer, isNewConversation) {\r\n        var rendererFunc = function(patch) {\r\n            return Renderer.render(header, body, footer, patch);\r\n        };\r\n\r\n        if (!isNewConversation) {\r\n            // Looks like someone got here before us! We'd better update our\r\n            // UI to make sure it matches.\r\n            var initialState = StateManager.buildInitialState(viewState.midnight, viewState.loggedInUserId, viewState.id);\r\n            var syncPatch = Patcher.buildPatch(initialState, viewState);\r\n            rendererFunc(syncPatch);\r\n        }\r\n\r\n        renderers.push(rendererFunc);\r\n\r\n        return function(newState) {\r\n            var patch = Patcher.buildPatch(viewState, newState);\r\n            var deferred = $.Deferred();\r\n\r\n            // Check if the patch has any data. Ignore empty patches.\r\n            if (Object.keys(patch).length) {\r\n                // Add the patch to the render buffer which gets processed in order.\r\n                renderBuffer.push({\r\n                    patch: patch,\r\n                    deferred: deferred\r\n                });\r\n            } else {\r\n                deferred.resolve(true);\r\n            }\r\n            // This is a great place to add in some console logging if you need\r\n            // to debug something. You can log the current state, the next state,\r\n            // and the generated patch and see exactly what will be updated.\r\n\r\n            // Optimistically update the state. We're going to assume that the rendering\r\n            // will always succeed. The rendering is asynchronous (annoyingly) so it's buffered\r\n            // but it'll reach eventual consistency with the current state.\r\n            viewState = newState;\r\n            if (newState.id) {\r\n                // Only cache created conversations.\r\n                stateCache[newState.id] = {\r\n                    state: newState,\r\n                    messagesOffset: getMessagesOffset(),\r\n                    loadedAllMessages: hasLoadedAllMessages()\r\n                };\r\n            }\r\n\r\n            // Start processing the buffer.\r\n            processRenderBuffer(header, body, footer);\r\n\r\n            return deferred.promise();\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Create a confirm action function.\r\n     *\r\n     * @param {Function} actionCallback The callback function.\r\n     * @return {Function} Confirm action handler.\r\n     */\r\n    var generateConfirmActionHandler = function(actionCallback) {\r\n        return function(e, data) {\r\n            if (!viewState.loadingConfirmAction) {\r\n                actionCallback(getOtherUserId());\r\n                var newState = StateManager.setLoadingConfirmAction(viewState, false);\r\n                render(newState);\r\n            }\r\n            data.originalEvent.preventDefault();\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Send message event handler.\r\n     *\r\n     * @param {Object} e Element this event handler is called on.\r\n     * @param {Object} data Data for this event.\r\n     */\r\n    var handleSendMessage = function(e, data) {\r\n        var target = $(e.target);\r\n        var footerContainer = target.closest(SELECTORS.FOOTER_CONTAINER);\r\n        var textArea = footerContainer.find(SELECTORS.MESSAGE_TEXT_AREA);\r\n        var text = textArea.val().trim();\r\n\r\n        if (text !== '') {\r\n            sendMessage(text);\r\n            textArea.val('');\r\n            textArea.focus();\r\n        }\r\n\r\n        data.originalEvent.preventDefault();\r\n    };\r\n\r\n    /**\r\n     * Select message event handler.\r\n     *\r\n     * @param {Object} e Element this event handler is called on.\r\n     * @param {Object} data Data for this event.\r\n     */\r\n    var handleSelectMessage = function(e, data) {\r\n        var selection = window.getSelection();\r\n        var target = $(e.target);\r\n\r\n        if (selection.toString() != '') {\r\n            // Bail if we're selecting.\r\n            return;\r\n        }\r\n\r\n        if (target.is('a')) {\r\n            // Clicking on a link in the message so ignore it.\r\n            return;\r\n        }\r\n\r\n        var element = target.closest(SELECTORS.MESSAGE);\r\n        var messageId = element.attr('data-message-id');\r\n\r\n        toggleSelectMessage(messageId);\r\n\r\n        data.originalEvent.preventDefault();\r\n    };\r\n\r\n    /**\r\n     * Handle retry sending of message.\r\n     *\r\n     * @param {Object} e Element this event handler is called on.\r\n     * @param {Object} data Data for this event.\r\n     */\r\n    var handleRetrySendMessage = function(e, data) {\r\n        var target = $(e.target);\r\n        var element = target.closest(SELECTORS.MESSAGE);\r\n        var messageId = element.attr('data-message-id');\r\n        var messages = viewState.messages.filter(function(message) {\r\n            return message.id == messageId;\r\n        });\r\n        var message = messages.length ? messages[0] : null;\r\n\r\n        if (message) {\r\n            retrySendMessage(message);\r\n        }\r\n\r\n        data.originalEvent.preventDefault();\r\n        data.originalEvent.stopPropagation();\r\n        e.stopPropagation();\r\n    };\r\n\r\n    /**\r\n     * Cancel edit mode event handler.\r\n     *\r\n     * @param {Object} e Element this event handler is called on.\r\n     * @param {Object} data Data for this event.\r\n     */\r\n    var handleCancelEditMode = function(e, data) {\r\n        cancelEditMode();\r\n        data.originalEvent.preventDefault();\r\n    };\r\n\r\n    /**\r\n     * Show the view contact page.\r\n     *\r\n     * @param {String} namespace Unique identifier for the Routes\r\n     * @return {Function} View contact handler.\r\n     */\r\n    var generateHandleViewContact = function(namespace) {\r\n        return function(e, data) {\r\n            var otherUserId = getOtherUserId();\r\n            var otherUser = viewState.members[otherUserId];\r\n            MessageDrawerRouter.go(namespace, MessageDrawerRoutes.VIEW_CONTACT, otherUser);\r\n            data.originalEvent.preventDefault();\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Set this conversation as a favourite.\r\n     *\r\n     * @param {Object} e Element this event handler is called on.\r\n     * @param {Object} data Data for this event.\r\n     */\r\n    var handleSetFavourite = function(e, data) {\r\n        setFavourite().catch(Notification.exception);\r\n        data.originalEvent.preventDefault();\r\n    };\r\n\r\n    /**\r\n     * Unset this conversation as a favourite.\r\n     *\r\n     * @param {Object} e Element this event handler is called on.\r\n     * @param {Object} data Data for this event.\r\n     */\r\n    var handleUnsetFavourite = function(e, data) {\r\n        unsetFavourite().catch(Notification.exception);\r\n        data.originalEvent.preventDefault();\r\n    };\r\n\r\n    /**\r\n     * Show the view group info page.\r\n     * Set this conversation as muted.\r\n     *\r\n     * @param {Object} e Element this event handler is called on.\r\n     * @param {Object} data Data for this event.\r\n     */\r\n    var handleSetMuted = function(e, data) {\r\n        setMuted().catch(Notification.exception);\r\n        data.originalEvent.preventDefault();\r\n    };\r\n\r\n    /**\r\n     * Unset this conversation as muted.\r\n     *\r\n     * @param {Object} e Element this event handler is called on.\r\n     * @param {Object} data Data for this event.\r\n     */\r\n    var handleUnsetMuted = function(e, data) {\r\n        unsetMuted().catch(Notification.exception);\r\n        data.originalEvent.preventDefault();\r\n    };\r\n\r\n    /**\r\n     * Handle clicking on the checkbox that toggles deleting messages for\r\n     * all users.\r\n     *\r\n     * @param {Object} e Element this event handler is called on.\r\n     */\r\n    var handleDeleteMessagesForAllUsersToggle = function(e) {\r\n        var newValue = $(e.target).prop('checked');\r\n        var newState = StateManager.setDeleteMessagesForAllUsers(viewState, newValue);\r\n        render(newState);\r\n    };\r\n\r\n    /**\r\n     * Show the view contact page.\r\n     *\r\n     * @param {String} namespace Unique identifier for the Routes\r\n     * @return {Function} View group info handler.\r\n     */\r\n    var generateHandleViewGroupInfo = function(namespace) {\r\n        return function(e, data) {\r\n            MessageDrawerRouter.go(\r\n                namespace,\r\n                MessageDrawerRoutes.VIEW_GROUP_INFO,\r\n                {\r\n                    id: viewState.id,\r\n                    name: viewState.name,\r\n                    subname: viewState.subname,\r\n                    imageUrl: viewState.imageUrl,\r\n                    totalMemberCount: viewState.totalMemberCount\r\n                },\r\n                viewState.loggedInUserId\r\n            );\r\n            data.originalEvent.preventDefault();\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Handle clicking on the emoji toggle button.\r\n     *\r\n     * @param {Object} e The event\r\n     * @param {Object} data The custom interaction event data\r\n     */\r\n    var handleToggleEmojiPicker = function(e, data) {\r\n        var newState = StateManager.setShowEmojiPicker(viewState, !viewState.showEmojiPicker);\r\n        render(newState);\r\n        data.originalEvent.preventDefault();\r\n    };\r\n\r\n    /**\r\n     * Handle clicking outside the emoji picker to close it.\r\n     *\r\n     * @param {Object} e The event\r\n     */\r\n    var handleCloseEmojiPicker = function(e) {\r\n        var target = $(e.target);\r\n\r\n        if (\r\n            viewState.showEmojiPicker &&\r\n            !target.closest(SELECTORS.EMOJI_PICKER_CONTAINER).length &&\r\n            !target.closest(SELECTORS.TOGGLE_EMOJI_PICKER_BUTTON).length\r\n        ) {\r\n            var newState = StateManager.setShowEmojiPicker(viewState, false);\r\n            render(newState);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Listen to, and handle events for conversations.\r\n     *\r\n     * @param {string} namespace The route namespace.\r\n     * @param {Object} header Conversation header container element.\r\n     * @param {Object} body Conversation body container element.\r\n     * @param {Object} footer Conversation footer container element.\r\n     */\r\n    var registerEventListeners = function(namespace, header, body, footer) {\r\n        var isLoadingMoreMessages = false;\r\n        var messagesContainer = getMessagesContainer(body);\r\n        var emojiPickerElement = footer.find(SELECTORS.EMOJI_PICKER);\r\n        var emojiAutoCompleteContainer = footer.find(SELECTORS.EMOJI_AUTO_COMPLETE_CONTAINER);\r\n        var messageTextArea = footer.find(SELECTORS.MESSAGE_TEXT_AREA);\r\n        var headerActivateHandlers = [\r\n            [SELECTORS.ACTION_REQUEST_BLOCK, generateConfirmActionHandler(requestBlockUser)],\r\n            [SELECTORS.ACTION_REQUEST_UNBLOCK, generateConfirmActionHandler(requestUnblockUser)],\r\n            [SELECTORS.ACTION_REQUEST_ADD_CONTACT, generateConfirmActionHandler(requestAddContact)],\r\n            [SELECTORS.ACTION_REQUEST_REMOVE_CONTACT, generateConfirmActionHandler(requestRemoveContact)],\r\n            [SELECTORS.ACTION_REQUEST_DELETE_CONVERSATION, generateConfirmActionHandler(requestDeleteConversation)],\r\n            [SELECTORS.ACTION_CANCEL_EDIT_MODE, handleCancelEditMode],\r\n            [SELECTORS.ACTION_VIEW_CONTACT, generateHandleViewContact(namespace)],\r\n            [SELECTORS.ACTION_VIEW_GROUP_INFO, generateHandleViewGroupInfo(namespace)],\r\n            [SELECTORS.ACTION_CONFIRM_FAVOURITE, handleSetFavourite],\r\n            [SELECTORS.ACTION_CONFIRM_MUTE, handleSetMuted],\r\n            [SELECTORS.ACTION_CONFIRM_UNFAVOURITE, handleUnsetFavourite],\r\n            [SELECTORS.ACTION_CONFIRM_UNMUTE, handleUnsetMuted]\r\n        ];\r\n        var bodyActivateHandlers = [\r\n            [SELECTORS.ACTION_CANCEL_CONFIRM, generateConfirmActionHandler(cancelRequest)],\r\n            [SELECTORS.ACTION_CONFIRM_BLOCK, generateConfirmActionHandler(blockUser)],\r\n            [SELECTORS.ACTION_CONFIRM_UNBLOCK, generateConfirmActionHandler(unblockUser)],\r\n            [SELECTORS.ACTION_CONFIRM_ADD_CONTACT, generateConfirmActionHandler(addContact)],\r\n            [SELECTORS.ACTION_CONFIRM_REMOVE_CONTACT, generateConfirmActionHandler(removeContact)],\r\n            [SELECTORS.ACTION_CONFIRM_DELETE_SELECTED_MESSAGES, generateConfirmActionHandler(deleteSelectedMessages)],\r\n            [SELECTORS.ACTION_CONFIRM_DELETE_CONVERSATION, generateConfirmActionHandler(deleteConversation)],\r\n            [SELECTORS.ACTION_OKAY_CONFIRM, generateConfirmActionHandler(cancelRequest)],\r\n            [SELECTORS.ACTION_REQUEST_ADD_CONTACT, generateConfirmActionHandler(requestAddContact)],\r\n            [SELECTORS.ACTION_ACCEPT_CONTACT_REQUEST, generateConfirmActionHandler(acceptContactRequest)],\r\n            [SELECTORS.ACTION_DECLINE_CONTACT_REQUEST, generateConfirmActionHandler(declineContactRequest)],\r\n            [SELECTORS.MESSAGE, handleSelectMessage],\r\n            [SELECTORS.DELETE_MESSAGES_FOR_ALL_USERS_TOGGLE, handleDeleteMessagesForAllUsersToggle],\r\n            [SELECTORS.RETRY_SEND, handleRetrySendMessage]\r\n        ];\r\n        var footerActivateHandlers = [\r\n            [SELECTORS.SEND_MESSAGE_BUTTON, handleSendMessage],\r\n            [SELECTORS.TOGGLE_EMOJI_PICKER_BUTTON, handleToggleEmojiPicker],\r\n            [SELECTORS.ACTION_REQUEST_DELETE_SELECTED_MESSAGES, generateConfirmActionHandler(requestDeleteSelectedMessages)],\r\n            [SELECTORS.ACTION_REQUEST_ADD_CONTACT, generateConfirmActionHandler(requestAddContact)],\r\n            [SELECTORS.ACTION_REQUEST_UNBLOCK, generateConfirmActionHandler(requestUnblockUser)],\r\n        ];\r\n\r\n        AutoRows.init(footer);\r\n\r\n        if (emojiAutoCompleteContainer.length) {\r\n            initialiseEmojiAutoComplete(\r\n                emojiAutoCompleteContainer[0],\r\n                messageTextArea[0],\r\n                function(hasSuggestions) {\r\n                    var newState = StateManager.setShowEmojiAutoComplete(viewState, hasSuggestions);\r\n                    render(newState);\r\n                },\r\n                function(emoji) {\r\n                    var newState = StateManager.setShowEmojiAutoComplete(viewState, false);\r\n                    render(newState);\r\n\r\n                    messageTextArea.focus();\r\n                    var cursorPos = messageTextArea.prop('selectionStart');\r\n                    var currentText = messageTextArea.val();\r\n                    var textBefore = currentText.substring(0, cursorPos).replace(/\\S*$/, '');\r\n                    var textAfter = currentText.substring(cursorPos).replace(/^\\S*/, '');\r\n\r\n                    messageTextArea.val(textBefore + emoji + textAfter);\r\n                    // Set the cursor position to after the inserted emoji.\r\n                    messageTextArea.prop('selectionStart', textBefore.length + emoji.length);\r\n                    messageTextArea.prop('selectionEnd', textBefore.length + emoji.length);\r\n                }\r\n            );\r\n        }\r\n\r\n        if (emojiPickerElement.length) {\r\n            initialiseEmojiPicker(emojiPickerElement[0], function(emoji) {\r\n                var newState = StateManager.setShowEmojiPicker(viewState, !viewState.showEmojiPicker);\r\n                render(newState);\r\n\r\n                messageTextArea.focus();\r\n                var cursorPos = messageTextArea.prop('selectionStart');\r\n                var currentText = messageTextArea.val();\r\n                var textBefore = currentText.substring(0, cursorPos);\r\n                var textAfter = currentText.substring(cursorPos, currentText.length);\r\n\r\n                messageTextArea.val(textBefore + emoji + textAfter);\r\n                // Set the cursor position to after the inserted emoji.\r\n                messageTextArea.prop('selectionStart', cursorPos + emoji.length);\r\n                messageTextArea.prop('selectionEnd', cursorPos + emoji.length);\r\n            });\r\n        }\r\n\r\n        CustomEvents.define(header, [\r\n            CustomEvents.events.activate\r\n        ]);\r\n        CustomEvents.define(body, [\r\n            CustomEvents.events.activate\r\n        ]);\r\n        CustomEvents.define(footer, [\r\n            CustomEvents.events.activate,\r\n            CustomEvents.events.enter,\r\n            CustomEvents.events.escape\r\n        ]);\r\n        CustomEvents.define(messagesContainer, [\r\n            CustomEvents.events.scrollTop,\r\n            CustomEvents.events.scrollLock\r\n        ]);\r\n\r\n        messagesContainer.on(CustomEvents.events.scrollTop, function(e, data) {\r\n            var hasMembers = Object.keys(viewState.members).length > 1;\r\n\r\n            if (!isResetting && !isLoadingMoreMessages && !hasLoadedAllMessages() && hasMembers) {\r\n                isLoadingMoreMessages = true;\r\n                var newState = StateManager.setLoadingMessages(viewState, true);\r\n                render(newState);\r\n\r\n                loadMessages(viewState.id, LOAD_MESSAGE_LIMIT, getMessagesOffset(), NEWEST_FIRST, [])\r\n                    .then(function() {\r\n                        isLoadingMoreMessages = false;\r\n                        setMessagesOffset(getMessagesOffset() + LOAD_MESSAGE_LIMIT);\r\n                        return;\r\n                    })\r\n                    .catch(function(error) {\r\n                        isLoadingMoreMessages = false;\r\n                        Notification.exception(error);\r\n                    });\r\n            }\r\n\r\n            data.originalEvent.preventDefault();\r\n        });\r\n\r\n        headerActivateHandlers.forEach(function(handler) {\r\n            var selector = handler[0];\r\n            var handlerFunction = handler[1];\r\n            header.on(CustomEvents.events.activate, selector, handlerFunction);\r\n        });\r\n\r\n        bodyActivateHandlers.forEach(function(handler) {\r\n            var selector = handler[0];\r\n            var handlerFunction = handler[1];\r\n            body.on(CustomEvents.events.activate, selector, handlerFunction);\r\n        });\r\n\r\n        footerActivateHandlers.forEach(function(handler) {\r\n            var selector = handler[0];\r\n            var handlerFunction = handler[1];\r\n            footer.on(CustomEvents.events.activate, selector, handlerFunction);\r\n        });\r\n\r\n        footer.on(CustomEvents.events.enter, SELECTORS.MESSAGE_TEXT_AREA, function(e, data) {\r\n            var enterToSend = footer.attr('data-enter-to-send');\r\n            if (enterToSend && enterToSend != 'false' && enterToSend != '0') {\r\n                handleSendMessage(e, data);\r\n            }\r\n        });\r\n\r\n        footer.on(CustomEvents.events.escape, SELECTORS.EMOJI_PICKER_CONTAINER, handleToggleEmojiPicker);\r\n        $(document.body).on('click', handleCloseEmojiPicker);\r\n\r\n        PubSub.subscribe(MessageDrawerEvents.ROUTE_CHANGED, function(newRouteData) {\r\n            if (newMessagesPollTimer) {\r\n                if (newRouteData.route != MessageDrawerRoutes.VIEW_CONVERSATION) {\r\n                    newMessagesPollTimer.stop();\r\n                }\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Reset the timer that polls for new messages.\r\n     *\r\n     * @param  {Number} conversationId The conversation id\r\n     */\r\n    var resetMessagePollTimer = function(conversationId) {\r\n        if (newMessagesPollTimer) {\r\n            newMessagesPollTimer.stop();\r\n        }\r\n\r\n        newMessagesPollTimer = new BackOffTimer(\r\n            getLoadNewMessagesCallback(conversationId, NEWEST_FIRST),\r\n            BackOffTimer.getIncrementalCallback(\r\n                viewState.messagePollMin * MILLISECONDS_IN_SEC,\r\n                MILLISECONDS_IN_SEC,\r\n                viewState.messagePollMax * MILLISECONDS_IN_SEC,\r\n                viewState.messagePollAfterMax * MILLISECONDS_IN_SEC\r\n            )\r\n        );\r\n\r\n        newMessagesPollTimer.start();\r\n    };\r\n\r\n    /**\r\n     * Reset the state to the initial state and render the UI.\r\n     *\r\n     * @param  {Object} body Conversation body container element.\r\n     * @param  {Number|null} conversationId The conversation id.\r\n     * @param  {Object} loggedInUserProfile The logged in user's profile.\r\n     */\r\n    var resetState = function(body, conversationId, loggedInUserProfile) {\r\n        // Reset all of the states back to the beginning if we're loading a new\r\n        // conversation.\r\n        if (newMessagesPollTimer) {\r\n            newMessagesPollTimer.stop();\r\n        }\r\n        loadedAllMessages = false;\r\n        messagesOffset = 0;\r\n        newMessagesPollTimer = null;\r\n        isRendering = false;\r\n        renderBuffer = [];\r\n        isResetting = true;\r\n        isSendingMessage = false;\r\n        isDeletingConversationContent = false;\r\n        sendMessageBuffer = [];\r\n\r\n        var loggedInUserId = loggedInUserProfile.id;\r\n        var midnight = parseInt(body.attr('data-midnight'), 10);\r\n        var messagePollMin = parseInt(body.attr('data-message-poll-min'), 10);\r\n        var messagePollMax = parseInt(body.attr('data-message-poll-max'), 10);\r\n        var messagePollAfterMax = parseInt(body.attr('data-message-poll-after-max'), 10);\r\n        var initialState = StateManager.buildInitialState(\r\n            midnight,\r\n            loggedInUserId,\r\n            conversationId,\r\n            messagePollMin,\r\n            messagePollMax,\r\n            messagePollAfterMax\r\n        );\r\n\r\n        if (!viewState) {\r\n            viewState = initialState;\r\n        }\r\n\r\n        render(initialState);\r\n    };\r\n\r\n    /**\r\n     * Load a new empty private conversation between two users or self-conversation.\r\n     *\r\n     * @param  {Object} body Conversation body container element.\r\n     * @param  {Object} loggedInUserProfile The logged in user's profile.\r\n     * @param  {Int} otherUserId The other user's id.\r\n     * @return {Promise} Renderer promise.\r\n     */\r\n    var resetNoConversation = function(body, loggedInUserProfile, otherUserId) {\r\n        // Always reset the state back to the initial state so that the\r\n        // state manager and patcher can work correctly.\r\n        resetState(body, null, loggedInUserProfile);\r\n\r\n        var resetNoConversationPromise = null;\r\n\r\n        if (loggedInUserProfile.id != otherUserId) {\r\n            // Private conversation between two different users.\r\n            resetNoConversationPromise = Repository.getConversationBetweenUsers(\r\n                loggedInUserProfile.id,\r\n                otherUserId,\r\n                true,\r\n                true,\r\n                0,\r\n                0,\r\n                LOAD_MESSAGE_LIMIT,\r\n                0,\r\n                NEWEST_FIRST\r\n            );\r\n        } else {\r\n            // Self conversation.\r\n            resetNoConversationPromise = Repository.getSelfConversation(\r\n                loggedInUserProfile.id,\r\n                LOAD_MESSAGE_LIMIT,\r\n                0,\r\n                NEWEST_FIRST\r\n            );\r\n        }\r\n\r\n        return resetNoConversationPromise.then(function(conversation) {\r\n                // Looks like we have a conversation after all! Let's use that.\r\n                return resetByConversation(body, conversation, loggedInUserProfile);\r\n            })\r\n            .catch(function() {\r\n                // Can't find a conversation. Oh well. Just load up a blank one.\r\n                return loadEmptyPrivateConversation(loggedInUserProfile, otherUserId);\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Load new messages into the conversation based on a time interval.\r\n     *\r\n     * @param  {Object} body Conversation body container element.\r\n     * @param  {Number} conversationId The conversation id.\r\n     * @param  {Object} loggedInUserProfile The logged in user's profile.\r\n     * @return {Promise} Renderer promise.\r\n     */\r\n    var resetById = function(body, conversationId, loggedInUserProfile) {\r\n        var cache = null;\r\n        if (conversationId in stateCache) {\r\n            cache = stateCache[conversationId];\r\n        }\r\n\r\n        // Always reset the state back to the initial state so that the\r\n        // state manager and patcher can work correctly.\r\n        resetState(body, conversationId, loggedInUserProfile);\r\n\r\n        var promise = $.Deferred().resolve({}).promise();\r\n        if (cache) {\r\n            // We've seen this conversation before so there is no need to\r\n            // send any network requests.\r\n            var newState = cache.state;\r\n            // Reset some loading states just in case they were left weirdly.\r\n            newState = StateManager.setLoadingMessages(newState, false);\r\n            newState = StateManager.setLoadingMembers(newState, false);\r\n            setMessagesOffset(cache.messagesOffset);\r\n            setLoadedAllMessages(cache.loadedAllMessages);\r\n            render(newState);\r\n        } else {\r\n            promise = loadNewConversation(\r\n                conversationId,\r\n                loggedInUserProfile,\r\n                LOAD_MESSAGE_LIMIT,\r\n                0,\r\n                NEWEST_FIRST\r\n            );\r\n        }\r\n\r\n        return promise.then(function() {\r\n            return resetMessagePollTimer(conversationId);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Load new messages into the conversation based on a time interval.\r\n     *\r\n     * @param  {Object} body Conversation body container element.\r\n     * @param  {Object} conversation The conversation.\r\n     * @param  {Object} loggedInUserProfile The logged in user's profile.\r\n     * @return {Promise} Renderer promise.\r\n     */\r\n    var resetByConversation = function(body, conversation, loggedInUserProfile) {\r\n        var cache = null;\r\n        if (conversation.id in stateCache) {\r\n            cache = stateCache[conversation.id];\r\n        }\r\n\r\n        // Always reset the state back to the initial state so that the\r\n        // state manager and patcher can work correctly.\r\n        resetState(body, conversation.id, loggedInUserProfile);\r\n\r\n        var promise = $.Deferred().resolve({}).promise();\r\n        if (cache) {\r\n            // We've seen this conversation before so there is no need to\r\n            // send any network requests.\r\n            var newState = cache.state;\r\n            // Reset some loading states just in case they were left weirdly.\r\n            newState = StateManager.setLoadingMessages(newState, false);\r\n            newState = StateManager.setLoadingMembers(newState, false);\r\n            setMessagesOffset(cache.messagesOffset);\r\n            setLoadedAllMessages(cache.loadedAllMessages);\r\n            render(newState);\r\n        } else {\r\n            promise = loadExistingConversation(\r\n                conversation,\r\n                loggedInUserProfile,\r\n                LOAD_MESSAGE_LIMIT,\r\n                NEWEST_FIRST\r\n            );\r\n        }\r\n\r\n        return promise.then(function() {\r\n            return resetMessagePollTimer(conversation.id);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Setup the conversation page. This is a rather complex function because there are a\r\n     * few combinations of arguments that can be provided to this function to show the\r\n     * conversation.\r\n     *\r\n     * There are:\r\n     * 1.) A conversation object with no action or other user id (e.g. from the overview page)\r\n     * 2.) A conversation id with no action or other user id (e.g. from the contacts page)\r\n     * 3.) No conversation/id with an action and other other user id. (e.g. from contact page)\r\n     *\r\n     * @param {string} namespace The route namespace.\r\n     * @param {Object} header Conversation header container element.\r\n     * @param {Object} body Conversation body container element.\r\n     * @param {Object} footer Conversation footer container element.\r\n     * @param {Object|Number|null} conversationOrId Conversation or id or null\r\n     * @param {String} action An action to take on the conversation\r\n     * @param {Number} otherUserId The other user id for a private conversation\r\n     * @return {Object} jQuery promise\r\n     */\r\n    var show = function(namespace, header, body, footer, conversationOrId, action, otherUserId) {\r\n        var conversation = null;\r\n        var conversationId = null;\r\n\r\n        // Check what we were given to identify the conversation.\r\n        if (conversationOrId && conversationOrId !== null && typeof conversationOrId == 'object') {\r\n            conversation = conversationOrId;\r\n            conversationId = parseInt(conversation.id, 10);\r\n        } else {\r\n            conversation = null;\r\n            conversationId = parseInt(conversationOrId, 10);\r\n            conversationId = isNaN(conversationId) ? null : conversationId;\r\n        }\r\n\r\n        if (!conversationId && action && otherUserId) {\r\n            // If we didn't get a conversation id got a user id then let's see if we've\r\n            // previously loaded a private conversation with this user.\r\n            conversationId = getCachedPrivateConversationIdFromUserId(otherUserId);\r\n        }\r\n\r\n        // Set attributes to aid in the restoration of unsent messages.\r\n        setConversationAttributes(footer, conversationId, otherUserId);\r\n\r\n        // This is a new conversation if:\r\n        // 1. We don't already have a state\r\n        // 2. The given conversation doesn't match the one currently loaded\r\n        // 3. We have a view state without a conversation id and we weren't given one\r\n        //    but we were given a different other user id. This happens when the user\r\n        //    goes from viewing a user that they haven't yet initialised a conversation\r\n        //    with to viewing a different user that they also haven't initialised a\r\n        //    conversation with.\r\n        var isNewConversation = !viewState || (viewState.id != conversationId) || (otherUserId && otherUserId != getOtherUserId());\r\n\r\n        if (!body.attr('data-init')) {\r\n            // Generate the render function to bind the header, body, and footer\r\n            // elements to it so that we don't need to pass them around this module.\r\n            render = generateRenderFunction(header, body, footer, isNewConversation);\r\n            registerEventListeners(namespace, header, body, footer);\r\n            body.attr('data-init', true);\r\n        }\r\n\r\n        if (isNewConversation) {\r\n            var renderPromise = null;\r\n            var loggedInUserProfile = getLoggedInUserProfile(body);\r\n\r\n            if (conversation) {\r\n                renderPromise = resetByConversation(body, conversation, loggedInUserProfile, otherUserId);\r\n            } else if (conversationId) {\r\n                renderPromise = resetById(body, conversationId, loggedInUserProfile, otherUserId);\r\n            } else {\r\n                renderPromise = resetNoConversation(body, loggedInUserProfile, otherUserId);\r\n            }\r\n\r\n            return renderPromise\r\n                .then(function() {\r\n                    isResetting = false;\r\n                    // Focus the first element that can receieve it in the header.\r\n                    header.find(Constants.SELECTORS.CAN_RECEIVE_FOCUS).first().focus();\r\n                    return;\r\n                })\r\n                .catch(function(error) {\r\n                    isResetting = false;\r\n                    Notification.exception(error);\r\n                });\r\n        }\r\n\r\n        // We're not loading a new conversation so we should reset the poll timer to try to load\r\n        // new messages.\r\n        resetMessagePollTimer(conversationId);\r\n\r\n        if (viewState.type == CONVERSATION_TYPES.PRIVATE && action) {\r\n            // There are special actions that the user can perform in a private (aka 1-to-1)\r\n            // conversation.\r\n            var currentOtherUserId = getOtherUserId();\r\n\r\n            switch (action) {\r\n                case 'block':\r\n                    return requestBlockUser(currentOtherUserId);\r\n                case 'unblock':\r\n                    return requestUnblockUser(currentOtherUserId);\r\n                case 'add-contact':\r\n                    return requestAddContact(currentOtherUserId);\r\n                case 'remove-contact':\r\n                    return requestRemoveContact(currentOtherUserId);\r\n            }\r\n        }\r\n\r\n        // Final fallback to return a promise if we didn't need to do anything.\r\n        return $.Deferred().resolve().promise();\r\n    };\r\n\r\n    /**\r\n     * String describing this page used for aria-labels.\r\n     *\r\n     * @return {Object} jQuery promise\r\n     */\r\n    var description = function() {\r\n        return Str.get_string('messagedrawerviewconversation', 'core_message', viewState.name);\r\n    };\r\n\r\n    /**\r\n     * Set some attributes that will help reboot a conversation.\r\n     *\r\n     * These attributes aid in the storage and retrieval of unsent messages.\r\n     * When a conversationid is not present, otheruserid can be used to create a conversation.\r\n     *\r\n     * @param {Object} element The element to target.\r\n     * @param {Number|null} conversationId The conversationid.\r\n     * @param {Number|null} otherUserId The otheruserid.\r\n     */\r\n    const setConversationAttributes = function(element, conversationId, otherUserId) {\r\n        element.removeAttr('data-conversation-id');\r\n        element.removeAttr('data-other-user-id');\r\n        if (conversationId) {\r\n            element.attr('data-conversation-id', conversationId);\r\n        } else if (otherUserId) {\r\n            element.attr('data-other-user-id', otherUserId);\r\n        }\r\n    };\r\n\r\n    return {\r\n        show: show,\r\n        description: description\r\n    };\r\n});\r\n"],"names":["define","$","AutoRows","BackOffTimer","CustomEvents","Notification","Pending","PubSub","Str","Repository","MessageDrawerEvents","Constants","Patcher","Renderer","StateManager","MessageDrawerRouter","MessageDrawerRoutes","initialiseEmojiAutoComplete","initialiseEmojiPicker","stateCache","viewState","loadedAllMessages","messagesOffset","newMessagesPollTimer","isRendering","renderBuffer","isResetting","isSendingMessage","isDeletingConversationContent","sendMessageBuffer","render","renderers","NEWEST_FIRST","NEWEST_MESSAGES_FIRST","LOAD_MESSAGE_LIMIT","MILLISECONDS_IN_SEC","SELECTORS","CONVERSATION_TYPES","getOtherUserId","type","PUBLIC","loggedInUserId","SELF","otherUserIds","Object","keys","members","filter","userId","length","getMessagesOffset","setMessagesOffset","value","id","hasLoadedAllMessages","setLoadedAllMessages","formatConversationForEvent","state","name","subname","imageUrl","isFavourite","isMuted","totalMemberCount","messages","map","message","extend","formattedMember","contactrequests","request","updateStateFromConversation","conversation","otherUser","PRIVATE","otherUsers","member","imageurl","fullname","profileimageurl","newState","addMembers","setName","setSubname","setType","setImageUrl","setTotalMemberCount","membercount","setIsFavourite","isfavourite","setIsMuted","ismuted","addMessages","setCanDeleteMessagesForAllUsers","candeletemessagesforallusers","setCanSendMessageToConversation","cansendmessagetoconversation","loadMessages","conversationId","limit","offset","newestFirst","ignoreList","timeFrom","getMessages","then","result","indexOf","parseInt","slice","membersToAdd","setLoadingMessages","catch","error","markConversationAsRead","pendingPromise","markAllConversationMessagesAsRead","markMessagesAsRead","publish","CONVERSATION_READ","resolve","requestBlockUser","cancelRequest","addPendingBlockUsersById","blockUser","setLoadingConfirmAction","profile","removePendingBlockUsersById","CONTACT_BLOCKED","requestUnblockUser","addPendingUnblockUsersById","unblockUser","removePendingUnblockUsersById","CONTACT_UNBLOCKED","requestRemoveContact","addPendingRemoveContactsById","removeContact","deleteContacts","profiles","removePendingRemoveContactsById","CONTACT_REMOVED","requestAddContact","addPendingAddContactsById","addContact","createContactRequest","response","Error","warnings","removePendingAddContactsById","addContactRequests","requestDeleteSelectedMessages","selectedMessageIds","addPendingDeleteMessagesById","deleteSelectedMessages","messageIds","pendingDeleteMessageIds","sentMessages","sendState","deleteMessagesPromise","Deferred","promise","sentMessageIds","deleteMessagesForAllUsers","deleteMessages","stop","removeMessagesById","removePendingDeleteMessagesById","removeSelectedMessagesById","setDeleteMessagesForAllUsers","prevLastMessage","newLastMessage","CONVERSATION_NEW_LAST_MESSAGE","CONVERSATION_DELETED","exception","requestDeleteConversation","setPendingDeleteConversation","deleteConversation","removeMessages","acceptContactRequest","requests","requesteduserid","removeContactRequests","CONTACT_ADDED","CONTACT_REQUEST_ACCEPTED","declineContactRequest","CONTACT_REQUEST_DECLINED","processSendMessageBuffer","messagesToSend","newConversationId","messagesText","text","sendMessagePromise","newCanDeleteMessagesForAllUsers","sendMessagesToConversation","otherUserId","sendMessagesToUser","conversationid","newMessageIds","data","selectedToRemove","selectedToAdd","forEach","oldMessage","index","newMessage","push","updateMessages","setMessagesSendSuccessById","addSelectedMessagesById","setId","resetMessagePollTimer","CONVERSATION_CREATED","e","errorMessage","get_string","handleFailedMessages","setMessagesSendFailById","finalError","previewText","plaintext","replace","processRenderBuffer","header","body","footer","renderable","shift","renderPromises","renderFunc","patch","when","apply","deferred","reject","generateConfirmActionHandler","actionCallback","loadingConfirmAction","originalEvent","preventDefault","handleSendMessage","textArea","target","closest","FOOTER_CONTAINER","find","MESSAGE_TEXT_AREA","val","trim","Date","now","loadingmessage","useridfrom","timecreated","document","querySelector","removeAttribute","sendMessage","focus","handleSelectMessage","selection","window","getSelection","toString","is","messageId","toggleSelectMessage","MESSAGE","attr","handleRetrySendMessage","setMessagesSendPendingById","retrySendMessage","stopPropagation","handleCancelEditMode","cancelEditMode","generateHandleViewContact","namespace","go","VIEW_CONTACT","handleSetFavourite","setFavouriteConversations","CONVERSATION_SET_FAVOURITE","handleUnsetFavourite","unsetFavouriteConversations","CONVERSATION_UNSET_FAVOURITE","handleSetMuted","setMutedConversations","CONVERSATION_SET_MUTED","handleUnsetMuted","unsetMutedConversations","CONVERSATION_UNSET_MUTED","handleDeleteMessagesForAllUsersToggle","newValue","prop","generateHandleViewGroupInfo","VIEW_GROUP_INFO","handleToggleEmojiPicker","setShowEmojiPicker","showEmojiPicker","handleCloseEmojiPicker","EMOJI_PICKER_CONTAINER","TOGGLE_EMOJI_PICKER_BUTTON","registerEventListeners","isLoadingMoreMessages","messagesContainer","MESSAGES_CONTAINER","getMessagesContainer","emojiPickerElement","EMOJI_PICKER","emojiAutoCompleteContainer","EMOJI_AUTO_COMPLETE_CONTAINER","messageTextArea","headerActivateHandlers","ACTION_REQUEST_BLOCK","ACTION_REQUEST_UNBLOCK","ACTION_REQUEST_ADD_CONTACT","ACTION_REQUEST_REMOVE_CONTACT","ACTION_REQUEST_DELETE_CONVERSATION","ACTION_CANCEL_EDIT_MODE","ACTION_VIEW_CONTACT","ACTION_VIEW_GROUP_INFO","ACTION_CONFIRM_FAVOURITE","ACTION_CONFIRM_MUTE","ACTION_CONFIRM_UNFAVOURITE","ACTION_CONFIRM_UNMUTE","bodyActivateHandlers","ACTION_CANCEL_CONFIRM","ACTION_CONFIRM_BLOCK","ACTION_CONFIRM_UNBLOCK","ACTION_CONFIRM_ADD_CONTACT","ACTION_CONFIRM_REMOVE_CONTACT","ACTION_CONFIRM_DELETE_SELECTED_MESSAGES","ACTION_CONFIRM_DELETE_CONVERSATION","ACTION_OKAY_CONFIRM","ACTION_ACCEPT_CONTACT_REQUEST","ACTION_DECLINE_CONTACT_REQUEST","DELETE_MESSAGES_FOR_ALL_USERS_TOGGLE","RETRY_SEND","footerActivateHandlers","SEND_MESSAGE_BUTTON","ACTION_REQUEST_DELETE_SELECTED_MESSAGES","init","hasSuggestions","setShowEmojiAutoComplete","emoji","cursorPos","currentText","textBefore","substring","textAfter","events","activate","enter","escape","scrollTop","scrollLock","on","hasMembers","handler","selector","handlerFunction","enterToSend","subscribe","ROUTE_CHANGED","newRouteData","route","VIEW_CONVERSATION","mostRecentMessage","lastTimeCreated","timeCreated","ignoreMessageIds","i","restart","getLoadNewMessagesCallback","getIncrementalCallback","messagePollMin","messagePollMax","messagePollAfterMax","start","resetState","loggedInUserProfile","midnight","initialState","buildInitialState","resetNoConversation","getConversationBetweenUsers","getSelfConversation","resetByConversation","conversationType","setLoadingMembers","getMemberInfo","loadEmptyPrivateConversation","resetById","cache","messageLimit","messageOffset","getConversation","concat","loadNewConversation","messageCount","hasLoadedEnoughMessages","loadExistingConversation","setConversationAttributes","element","removeAttr","show","conversationOrId","action","isNaN","reduce","carry","isNewConversation","rendererFunc","buildPatch","generateRenderFunction","profileimageurlsmall","isonline","showonlinestatus","isblocked","iscontact","isdeleted","canmessage","canmessageevenifblocked","requirescontact","cancreatecontact","getLoggedInUserProfile","CAN_RECEIVE_FOCUS","first","currentOtherUserId","description"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsDAA,uDACA,CACI,SACA,iBACA,qBACA,iCACA,oBACA,eACA,cACA,WACA,kCACA,qCACA,0DACA,wDACA,yDACA,8DACA,qCACA,qCACA,2BACA,sBAEJ,SACIC,EACAC,SACAC,aACAC,aACAC,aACAC,QACAC,OACAC,IACAC,WACAC,oBACAC,UACAC,QACAC,SACAC,aACAC,oBACAC,oBACAC,4BACAC,2BAMIC,WAAa,GAEbC,UAAY,KACZC,mBAAoB,EACpBC,eAAiB,EACjBC,qBAAuB,KACvBC,aAAc,EACdC,aAAe,GAEfC,aAAc,EAEdC,kBAAmB,EAEnBC,+BAAgC,EAEhCC,kBAAoB,GAGpBC,OAAS,KAGTC,UAAY,GAEZC,aAAerB,UAAUsB,sBACzBC,mBAAqBvB,UAAUuB,mBAC/BC,oBAAsBxB,UAAUwB,oBAChCC,UAAYzB,UAAUyB,UACtBC,mBAAqB1B,UAAU0B,mBAO/BC,eAAiB,eACZlB,WAAaA,UAAUmB,MAAQF,mBAAmBG,cAC5C,SAGPC,eAAiBrB,UAAUqB,kBAC3BrB,UAAUmB,MAAQF,mBAAmBK,YAE9BD,mBAGPE,aAAeC,OAAOC,KAAKzB,UAAU0B,SAASC,QAAO,SAASC,eACvDP,gBAAkBO,iBAGtBL,aAAaM,OAASN,aAAa,GAAK,MAyD/CO,kBAAoB,kBACb5B,gBAQP6B,kBAAoB,SAASC,OAC7B9B,eAAiB8B,MACjBjC,WAAWC,UAAUiC,IAAI/B,eAAiB8B,OAQ1CE,qBAAuB,kBAChBjC,mBAQPkC,qBAAuB,SAASH,OAChC/B,kBAAoB+B,MACpBjC,WAAWC,UAAUiC,IAAIhC,kBAAoB+B,OAmB7CI,2BAA6B,SAASC,aAC/B,CACHJ,GAAII,MAAMJ,GACVK,KAAMD,MAAMC,KACZC,QAASF,MAAME,QACfC,SAAUH,MAAMG,SAChBC,YAAaJ,MAAMI,YACnBC,QAASL,MAAMK,QACfvB,KAAMkB,MAAMlB,KACZwB,iBAAkBN,MAAMM,iBACxBtB,eAAgBgB,MAAMhB,eACtBuB,SAAUP,MAAMO,SAASC,KAAI,SAASC,gBAC3BjE,EAAEkE,OAAO,GAAID,YAExBpB,QAASF,OAAOC,KAAKY,MAAMX,SAASmB,KAAI,SAASZ,QACzCe,gBAAkBnE,EAAEkE,OAAO,GAAIV,MAAMX,QAAQO,YACjDe,gBAAgBC,gBAAkBZ,MAAMX,QAAQO,IAAIgB,gBAAgBJ,KAAI,SAASK,gBACtErE,EAAEkE,OAAO,GAAIG,YAEjBF,qBA4DfG,4BAA8B,SAASC,aAAc/B,oBACjDgC,UAAY,QACZD,aAAajC,MAAQF,mBAAmBqC,QAAS,KAE7CC,WAAaH,aAAa1B,QAAQC,QAAO,SAAS6B,eAC3CA,OAAOvB,IAAMZ,kBAExBgC,UAAYE,WAAW1B,OAAS0B,WAAW,GAAK,UACzCH,aAAajC,MAAQF,mBAAmBK,OAE/C+B,UAAYD,aAAa1B,QAAQ,QAGjCY,KAAOc,aAAad,KACpBE,SAAWY,aAAaK,SAExBL,aAAajC,MAAQF,mBAAmBG,SACxCkB,KAAOA,MAAQe,UAAYA,UAAUK,SAAW,GAChDlB,SAAWA,UAAYa,UAAYA,UAAUM,gBAAkB,QAG/DC,SAAWlE,aAAamE,WAAW7D,UAAWoD,aAAa1B,gBAC/DkC,SAAWlE,aAAaoE,QAAQF,SAAUtB,MAC1CsB,SAAWlE,aAAaqE,WAAWH,SAAUR,aAAab,SAC1DqB,SAAWlE,aAAasE,QAAQJ,SAAUR,aAAajC,MACvDyC,SAAWlE,aAAauE,YAAYL,SAAUpB,UAC9CoB,SAAWlE,aAAawE,oBAAoBN,SAAUR,aAAae,aACnEP,SAAWlE,aAAa0E,eAAeR,SAAUR,aAAaiB,aAC9DT,SAAWlE,aAAa4E,WAAWV,SAAUR,aAAamB,SAC1DX,SAAWlE,aAAa8E,YAAYZ,SAAUR,aAAaR,UAC3DgB,SAAWlE,aAAa+E,gCAAgCb,SAAUR,aAAasB,8BAC/Ed,SAAWlE,aAAaiF,gCAAgCf,SAAUR,aAAawB,+BAyI/EC,aAAe,SAASC,eAAgBC,MAAOC,OAAQC,YAAaC,WAAYC,iBACzE9F,WAAW+F,YACVpF,UAAUqB,eACVyD,eACAC,MAAQA,MAAQ,EAAIA,MACpBC,OACAC,YACAE,UAEHE,MAAK,SAASC,eAEPA,OAAOrD,IAAMjC,UAAUiC,KACvBqD,OAAO1C,SAAW,GAEd0C,OAAOrD,MAAMlC,mBACNA,WAAWuF,OAAOrD,KAI1BqD,UAEVD,MAAK,SAASC,eACPA,OAAO1C,SAASf,QAAUqD,WAAWrD,SACrCyD,OAAO1C,SAAW0C,OAAO1C,SAASjB,QAAO,SAASmB,gBAEvCoC,WAAWK,QAAQC,SAAS1C,QAAQb,GAAI,KAAO,MAIvDqD,UAEVD,MAAK,SAASC,eACNP,OAEMO,OAAO1C,SAASf,OAASkD,MAGhCO,OAAO1C,SAAW0C,OAAO1C,SAAS6C,MAAM,GAAI,GAE5CtD,sBAAqB,GAGlBmD,QATIA,UAWdD,MAAK,SAASC,YACPI,aAAeJ,OAAO5D,QAAQC,QAAO,SAAS6B,gBACrCA,OAAOvB,MAAMjC,UAAU0B,YAEhCkC,SAAWlE,aAAamE,WAAW7D,UAAW0F,qBAClD9B,SAAWlE,aAAa8E,YAAYZ,SAAU0B,OAAO1C,UACrDgB,SAAWlE,aAAaiG,mBAAmB/B,UAAU,GAC9ClD,OAAOkD,UACTyB,MAAK,kBACKC,aAGlBM,OAAM,SAASC,WACRjC,SAAWlE,aAAaiG,mBAAmB3F,WAAW,SAC1DU,OAAOkD,UAEDiC,UAsEdC,uBAAyB,SAAShB,oBAC9BzD,eAAiBrB,UAAUqB,eAC3B0E,eAAiB,IAAI7G,QAAQ,+EAE1BG,WAAW2G,kCAAkC3E,eAAgByD,gBAC/DO,MAAK,eACEzB,SAAWlE,aAAauG,mBAAmBjG,UAAWA,UAAU4C,iBACpEzD,OAAO+G,QAAQ5G,oBAAoB6G,kBAAmBrB,gBAC/CpE,OAAOkD,aAEjByB,MAAK,SAASC,eACXS,eAAeK,UAERd,WAUfe,iBAAmB,SAASzE,QAC5B0E,cAAc1E,YACVgC,SAAWlE,aAAa6G,yBAAyBvG,UAAW,CAAC4B,SACjElB,OAAOkD,WAUP4C,UAAY,SAAS5E,YACjBgC,SAAWlE,aAAa+G,wBAAwBzG,WAAW,GAC3D+F,eAAiB,IAAI7G,QAAQ,kEAEjCwB,OAAOkD,UAEAvE,WAAWmH,UAAUxG,UAAUqB,eAAgBO,QACjDyD,MAAK,SAASqB,aACP9C,SAAWlE,aAAamE,WAAW7D,UAAW,CAAC0G,iBACnD9C,SAAWlE,aAAaiH,4BAA4B/C,SAAU,CAAChC,SAC/DgC,SAAWlE,aAAa+G,wBAAwB7C,UAAU,GAC1DzE,OAAO+G,QAAQ5G,oBAAoBsH,gBAAiBhF,QAC7ClB,OAAOkD,aAEjByB,MAAK,SAASC,eACXS,eAAeK,UAERd,WAUfuB,mBAAqB,SAASjF,QAC9B0E,cAAc1E,YACVgC,SAAWlE,aAAaoH,2BAA2B9G,UAAW,CAAC4B,SACnElB,OAAOkD,WAUPmD,YAAc,SAASnF,YACnBgC,SAAWlE,aAAa+G,wBAAwBzG,WAAW,GAC3D+F,eAAiB,IAAI7G,QAAQ,oEACjCwB,OAAOkD,UAEAvE,WAAW0H,YAAY/G,UAAUqB,eAAgBO,QACnDyD,MAAK,SAASqB,aACP9C,SAAWlE,aAAamE,WAAW7D,UAAW,CAAC0G,iBACnD9C,SAAWlE,aAAasH,8BAA8BpD,SAAU,CAAChC,SACjEgC,SAAWlE,aAAa+G,wBAAwB7C,UAAU,GAC1DzE,OAAO+G,QAAQ5G,oBAAoB2H,kBAAmBrF,QAC/ClB,OAAOkD,aAEjByB,MAAK,SAASC,eACXS,eAAeK,UAERd,WAUf4B,qBAAuB,SAAStF,QAChC0E,cAAc1E,YACVgC,SAAWlE,aAAayH,6BAA6BnH,UAAW,CAAC4B,SACrElB,OAAOkD,WAUPwD,cAAgB,SAASxF,YACrBgC,SAAWlE,aAAa+G,wBAAwBzG,WAAW,GAC3D+F,eAAiB,IAAI7G,QAAQ,sEACjCwB,OAAOkD,UAEAvE,WAAWgI,eAAerH,UAAUqB,eAAgB,CAACO,SACvDyD,MAAK,SAASiC,cACP1D,SAAWlE,aAAamE,WAAW7D,UAAWsH,iBAClD1D,SAAWlE,aAAa6H,gCAAgC3D,SAAU,CAAChC,SACnEgC,SAAWlE,aAAa+G,wBAAwB7C,UAAU,GAC1DzE,OAAO+G,QAAQ5G,oBAAoBkI,gBAAiB5F,QAC7ClB,OAAOkD,aAEjByB,MAAK,SAASC,eACXS,eAAeK,UAERd,WAUfmC,kBAAoB,SAAS7F,QAC7B0E,cAAc1E,YACVgC,SAAWlE,aAAagI,0BAA0B1H,UAAW,CAAC4B,SAClElB,OAAOkD,WAUP+D,WAAa,SAAS/F,YAClBgC,SAAWlE,aAAa+G,wBAAwBzG,WAAW,GAC3D+F,eAAiB,IAAI7G,QAAQ,2EACjCwB,OAAOkD,UAEAvE,WAAWuI,qBAAqB5H,UAAUqB,eAAgBO,QAC5DyD,MAAK,SAASwC,cACNA,SAAS3E,cACJ,IAAI4E,MAAMD,SAASE,SAAS,GAAGjF,gBAGlC+E,SAAS3E,WAEnBmC,MAAK,SAASnC,aACPU,SAAWlE,aAAasI,6BAA6BhI,UAAW,CAAC4B,gBACrEgC,SAAWlE,aAAauI,mBAAmBrE,SAAU,CAACV,UACtDU,SAAWlE,aAAa+G,wBAAwB7C,UAAU,GACnDlD,OAAOkD,aAEjByB,MAAK,SAASC,eACXS,eAAeK,UAERd,WAoHf4C,8BAAgC,SAAStG,YACrCuG,mBAAqBnI,UAAUmI,mBACnC7B,cAAc1E,YACVgC,SAAWlE,aAAa0I,6BAA6BpI,UAAWmI,oBACpEzH,OAAOkD,WASPyE,uBAAyB,eACrBtC,eAAiB,IAAI7G,QAAQ,wEAC7BoJ,WAAatI,UAAUuI,wBACvBC,aAAexI,UAAU4C,SAASjB,QAAO,SAASmB,gBAG3CwF,WAAW/C,QAAQzC,QAAQb,KAAO,IAA2B,QAArBa,QAAQ2F,WAA6C,OAAtB3F,QAAQ2F,cAEtF7E,SAAWlE,aAAa+G,wBAAwBzG,WAAW,GAE/DU,OAAOkD,cAEH8E,sBAAwB7J,EAAE8J,WAAWvC,UAAUwC,aAG/CJ,aAAa3G,OAAQ,KAGjBgH,eAAiBL,aAAa3F,KAAI,SAASC,gBACpCA,QAAQb,MAGfyG,sBADA9E,SAASkF,0BACezJ,WAAWyJ,0BAA0B9I,UAAUqB,eAAgBwH,gBAE/DxJ,WAAW0J,eAAe/I,UAAUqB,eAAgBwH,uBAKpFrI,+BAAgC,EAG5BL,sBACAA,qBAAqB6I,OAGlBN,sBAAsBrD,MAAK,eACtBzB,SAAWlE,aAAauJ,mBAAmBjJ,UAAWsI,YAC1D1E,SAAWlE,aAAawJ,gCAAgCtF,SAAU0E,YAClE1E,SAAWlE,aAAayJ,2BAA2BvF,SAAU0E,YAC7D1E,SAAWlE,aAAa+G,wBAAwB7C,UAAU,GAC1DA,SAAWlE,aAAa0J,6BAA6BxF,UAAU,OAE3DyF,gBAAkBrJ,UAAU4C,SAAS5C,UAAU4C,SAASf,OAAS,GACjEyH,eAAiB1F,SAAShB,SAASf,OAAS+B,SAAShB,SAASgB,SAAShB,SAASf,OAAS,GAAK,QAE9FyH,gBAAkBA,eAAerH,IAAMoH,gBAAgBpH,GAAI,KACvDmB,aAAehB,2BAA2BwB,UAC9CzE,OAAO+G,QAAQ5G,oBAAoBiK,8BAA+BnG,mBAC1DQ,SAAShB,SAASf,QAC1B1C,OAAO+G,QAAQ5G,oBAAoBkK,qBAAsB5F,SAAS3B,WAGtEzB,+BAAgC,EACzBE,OAAOkD,aAEjByB,MAAK,SAASC,eACXS,eAAeK,UAERd,UAEVM,MAAM3G,aAAawK,YASxBC,0BAA4B,SAAS9H,QACrC0E,cAAc1E,YACVgC,SAAWlE,aAAaiK,6BAA6B3J,WAAW,GACpEU,OAAOkD,WASPgG,mBAAqB,eACjB7D,eAAiB,IAAI7G,QAAQ,wEAC7B0E,SAAWlE,aAAa+G,wBAAwBzG,WAAW,UAC/DU,OAAOkD,UAGPpD,+BAAgC,EAG5BL,sBACAA,qBAAqB6I,OAGlB3J,WAAWuK,mBAAmB5J,UAAUqB,eAAgBrB,UAAUiC,IACpEoD,MAAK,eACEzB,SAAWlE,aAAamK,eAAe7J,UAAWA,UAAU4C,iBAChEgB,SAAWlE,aAAayJ,2BAA2BvF,SAAU5D,UAAUmI,oBACvEvE,SAAWlE,aAAaiK,6BAA6B/F,UAAU,GAC/DA,SAAWlE,aAAa+G,wBAAwB7C,UAAU,GAC1DzE,OAAO+G,QAAQ5G,oBAAoBkK,qBAAsB5F,SAAS3B,IAElEzB,+BAAgC,EAEzBE,OAAOkD,aAEjByB,MAAK,SAASC,eACXS,eAAeK,UAERd,WASfgB,cAAgB,SAAS1E,YACrB2G,wBAA0BvI,UAAUuI,wBACpC3E,SAAWlE,aAAasI,6BAA6BhI,UAAW,CAAC4B,SACrEgC,SAAWlE,aAAa6H,gCAAgC3D,SAAU,CAAChC,SACnEgC,SAAWlE,aAAasH,8BAA8BpD,SAAU,CAAChC,SACjEgC,SAAWlE,aAAaiH,4BAA4B/C,SAAU,CAAChC,SAC/DgC,SAAWlE,aAAawJ,gCAAgCtF,SAAU2E,yBAClE3E,SAAWlE,aAAaiK,6BAA6B/F,UAAU,GAC/DA,SAAWlE,aAAa0J,6BAA6BxF,UAAU,GAC/DlD,OAAOkD,WASPkG,qBAAuB,SAASlI,YAC5BmE,eAAiB,IAAI7G,QAAQ,sEAI7BmC,eAAiBrB,UAAUqB,eAC3B0I,SAAW/J,UAAU0B,QAAQE,QAAQqB,gBAAgBtB,QAAO,SAASuB,gBAC9DA,QAAQ8G,iBAAmB3I,kBAElC6B,QAAU6G,SAAS,GACnBnG,SAAWlE,aAAa+G,wBAAwBzG,WAAW,UAC/DU,OAAOkD,UAEAvE,WAAWyK,qBAAqBlI,OAAQP,gBAC1CgE,MAAK,SAASqB,aACP9C,SAAWlE,aAAauK,sBAAsBjK,UAAW,CAACkD,iBAC9DU,SAAWlE,aAAamE,WAAW7D,UAAW,CAAC0G,UAC/C9C,SAAWlE,aAAa+G,wBAAwB7C,UAAU,GACnDlD,OAAOkD,aAEjByB,MAAK,WACFlG,OAAO+G,QAAQ5G,oBAAoB4K,cAAelK,UAAU0B,QAAQE,SACpEzC,OAAO+G,QAAQ5G,oBAAoB6K,yBAA0BjH,YAGhEmC,MAAK,SAASC,eACXS,eAAeK,UAERd,WAUf8E,sBAAwB,SAASxI,YAC7BmE,eAAiB,IAAI7G,QAAQ,uEAI7BmC,eAAiBrB,UAAUqB,eAC3B0I,SAAW/J,UAAU0B,QAAQE,QAAQqB,gBAAgBtB,QAAO,SAASuB,gBAC9DA,QAAQ8G,iBAAmB3I,kBAElC6B,QAAU6G,SAAS,GACnBnG,SAAWlE,aAAa+G,wBAAwBzG,WAAW,UAC/DU,OAAOkD,UAEAvE,WAAW+K,sBAAsBxI,OAAQP,gBAC3CgE,MAAK,SAASqB,aACP9C,SAAWlE,aAAauK,sBAAsBjK,UAAW,CAACkD,iBAC9DU,SAAWlE,aAAamE,WAAW7D,UAAW,CAAC0G,UAC/C9C,SAAWlE,aAAa+G,wBAAwB7C,UAAU,GACnDlD,OAAOkD,aAEjByB,MAAK,WACFlG,OAAO+G,QAAQ5G,oBAAoB+K,yBAA0BnH,YAGhEmC,MAAK,SAASC,eACXS,eAAeK,UAERd,WAWfgF,yBAA2B,eACvB/J,kBAICE,kBAAkBoB,YAKnBkE,eAAiB,IAAI7G,QAAQ,0EAGjCqB,kBAAmB,MAEfgK,eAAiB9J,kBAAkBgF,QAEvChF,kBAAoB,OAChBqE,eAAiB9E,UAAUiC,GAC3BuI,kBAAoB,KACpBC,aAAeF,eAAe1H,KAAI,SAASC,gBACpCA,QAAQ4H,QAEfpC,WAAaiC,eAAe1H,KAAI,SAASC,gBAClCA,QAAQb,MAEf0I,mBAAqB,KACrBC,gCAAkC,QACjC9F,gBAAmB9E,UAAUmB,MAAQF,mBAAmBG,OAazDuJ,mBAAqBtL,WAAWwL,2BAA2B/F,eAAgB2F,kBAbT,KAG9DK,YAAc5J,iBAClByJ,mBAAqBtL,WAAW0L,mBAAmBD,YAAaL,cAC3DpF,MAAK,SAASzC,iBACPA,SAASf,SACT2I,kBAAoBhF,SAAS5C,SAAS,GAAGoI,eAAgB,IACzDJ,gCAAkChI,SAAS,GAAG8B,8BAE3C9B,YAMnB+H,mBACKtF,MAAK,SAASzC,cACPqI,cAAgBrI,SAASC,KAAI,SAASC,gBAC/BA,QAAQb,MAEfiJ,KAAO,GACPC,iBAAmB,GACnBC,cAAgB,GAEpBb,eAAec,SAAQ,SAASC,WAAYC,WACpCC,WAAa5I,SAAS2I,OAI1BL,KAAKO,KAAK,CAACH,WAAYE,aAEnBxL,UAAUmI,mBAAmB5C,QAAQ+F,WAAWrJ,KAAO,IAIvDkJ,iBAAiBM,KAAKH,WAAWrJ,IACjCmJ,cAAcK,KAAKD,WAAWvJ,YAGlC2B,SAAWlE,aAAagM,eAAe1L,UAAWkL,MACtDtH,SAAWlE,aAAaiM,2BAA2B/H,SAAUqH,eAEzDE,iBAAiBtJ,SACjB+B,SAAWlE,aAAayJ,2BAA2BvF,SAAUuH,mBAG7DC,cAAcvJ,SACd+B,SAAWlE,aAAakM,wBAAwBhI,SAAUwH,oBAG1DhI,aAAehB,2BAA2BwB,UAEzCA,SAAS3B,KAGV2B,SAAWlE,aAAamM,MAAMjI,SAAU4G,mBACxCpH,aAAanB,GAAKuI,kBAClBsB,sBAAsBtB,mBACtBrL,OAAO+G,QAAQ5G,oBAAoByM,qBAAsB3I,cACzDQ,SAAWlE,aAAa+E,gCAAgCb,SAAUgH,kCAItElK,OAAOkD,UAEPrD,kBAAmB,EACnB+J,2BACAnL,OAAO+G,QAAQ5G,oBAAoBiK,8BAA+BnG,iBAGrEiC,MAAK,SAASC,eACXS,eAAeK,UAERd,UAEVM,OAAM,SAASoG,OACRC,aAEAA,aADAD,EAAElJ,QACajE,EAAE8J,WAAWvC,QAAQ4F,EAAElJ,SAAS8F,UAEhCxJ,IAAI8M,WAAW,eAAgB,YAG9CC,qBAAuB,SAASF,kBAG5BrI,SAAWlE,aAAa0M,wBAAwBpM,UAAWsI,WAAY2D,cAC3EvL,OAAOkD,UACPrD,kBAAmB,EACnB+J,4BAGJ2B,aAAa5G,KAAK8G,sBACb9G,MAAK,SAASC,eACXS,eAAeK,UAERd,UAEVM,OAAM,SAASoG,OAIRK,WAAaL,EAAElJ,SAAW,wBAC9BqJ,qBAAqBE,0BAcnCC,YAAc,SAAS5B,UAErB6B,UAAY7B,KAAK8B,QAAQ,8BAA+B,WAC5DD,UAAYA,UAAUC,QAAQ,gCAAiC,IAE/DD,UAAYA,UAAUC,QAAQ,YAAa,MAC3CD,UAAYA,UAAUC,QAAQ,WAAY,MAC1CD,UAAYA,UAAUC,QAAQ,SAAU,SACxCD,UAAYA,UAAUC,QAAQ,WAAY,MAC1CD,UAAYA,UAAUC,QAAQ,UAAW,MACzCD,UAAYA,UAAUC,QAAQ,cAAe,MAE7CD,UAAYA,UAAUC,QAAQ,YAAa,IAC3CD,UAAYA,UAAUC,QAAQ,QAAS,MAChCD,UAAUC,QAAQ,OAAQ,aAqFjCC,oBAAsB,SAASC,OAAQC,KAAMC,YACzCxM,aAICC,aAAawB,QAIlBzB,aAAc,MACVyM,WAAaxM,aAAayM,QAC1BC,eAAiBpM,UAAUkC,KAAI,SAASmK,mBACjCA,WAAWH,WAAWI,UAGjCpO,EAAEqO,KAAKC,MAAM,KAAMJ,gBACd1H,MAAK,WACFjF,aAAc,EACdyM,WAAWO,SAAShH,SAAQ,GAE5BqG,oBAAoBC,OAAQC,KAAMC,WAIrChH,OAAM,SAASC,OACZzF,aAAc,EACdyM,WAAWO,SAASC,OAAOxH,OAC3B5G,aAAawK,UAAU5D,YAwE/ByH,6BAA+B,SAASC,uBACjC,SAASvB,EAAGd,UACVlL,UAAUwN,qBAAsB,CACjCD,eAAerM,sBACX0C,SAAWlE,aAAa+G,wBAAwBzG,WAAW,GAC/DU,OAAOkD,UAEXsH,KAAKuC,cAAcC,mBAUvBC,kBAAoB,SAAS3B,EAAGd,UAG5B0C,SAFS/O,EAAEmN,EAAE6B,QACYC,QAAQ9M,UAAU+M,kBAChBC,KAAKhN,UAAUiN,mBAC1CvD,KAAOkD,SAASM,MAAMC,OAEb,KAATzD,QApMU,SAASA,UACnBzI,GAAK,OAASmM,KAAKC,UAEnBC,eAAiB,CACjBrM,GAAIA,GACJsM,WAAYvO,UAAUqB,eACtBqJ,KAAO4B,YAAY5B,MACnB8D,YAAa,UAEb5K,SAAWlE,aAAa8E,YAAYxE,UAAW,CAACsO,iBACpD5N,OAAOkD,cAEHd,QAAU,CACVb,GAAIA,GACJsM,WAAYvO,UAAUqB,eACtBqJ,KAAMA,KACN8D,YAAa,MAEjB/N,kBAAkBgL,KAAK3I,SACvBwH,iCAGMsD,SAAWa,SAASC,cAAc1N,UAAUiN,mBAC9CL,UACAA,SAASe,gBAAgB,8BA6KzBC,CAAYlE,MACZkD,SAASM,IAAI,IACbN,SAASiB,SAGb3D,KAAKuC,cAAcC,kBASnBoB,oBAAsB,SAAS9C,EAAGd,UAC9B6D,UAAYC,OAAOC,eACnBpB,OAAShP,EAAEmN,EAAE6B,QAEW,IAAxBkB,UAAUG,aAKVrB,OAAOsB,GAAG,QA/KQ,SAASC,eAC3BxL,SAAW5D,UAGX4D,SADA5D,UAAUmI,mBAAmB5C,QAAQ6J,YAAc,EACxC1P,aAAayJ,2BAA2BnJ,UAAW,CAACoP,YAEpD1P,aAAakM,wBAAwB5L,UAAW,CAACoP,YAGhE1O,OAAOkD,UA8KPyL,CAHcxB,OAAOC,QAAQ9M,UAAUsO,SACfC,KAAK,oBAI7BrE,KAAKuC,cAAcC,oBASnB8B,uBAAyB,SAASxD,EAAGd,UAGjCkE,UAFSvQ,EAAEmN,EAAE6B,QACIC,QAAQ9M,UAAUsO,SACfC,KAAK,mBACzB3M,SAAW5C,UAAU4C,SAASjB,QAAO,SAASmB,gBACvCA,QAAQb,IAAMmN,aAErBtM,QAAUF,SAASf,OAASe,SAAS,GAAK,KAE1CE,SAvNe,SAASA,aACxBc,SAAWlE,aAAa+P,2BAA2BzP,UAAW,CAAC8C,QAAQb,KAC3EvB,OAAOkD,UACPnD,kBAAkBgL,KAAK3I,SACvBwH,2BAoNIoF,CAAiB5M,SAGrBoI,KAAKuC,cAAcC,iBACnBxC,KAAKuC,cAAckC,kBACnB3D,EAAE2D,mBASFC,qBAAuB,SAAS5D,EAAGd,OA3MlB,WACjB5E,cAAcpF,sBACV0C,SAAWlE,aAAayJ,2BAA2BnJ,UAAWA,UAAUmI,oBAC5EzH,OAAOkD,UAyMPiM,GACA3E,KAAKuC,cAAcC,kBASnBoC,0BAA4B,SAASC,kBAC9B,SAAS/D,EAAGd,UACXJ,YAAc5J,iBACdmC,UAAYrD,UAAU0B,QAAQoJ,aAClCnL,oBAAoBqQ,GAAGD,UAAWnQ,oBAAoBqQ,aAAc5M,WACpE6H,KAAKuC,cAAcC,mBAUvBwC,mBAAqB,SAASlE,EAAGd,MAzxBlB,IACXtJ,OACAkD,eACAiB,gBAFAnE,OAAS5B,UAAUqB,eACnByD,eAAiB9E,UAAUiC,GAC3B8D,eAAiB,IAAI7G,QAAQ,8DAE1BG,WAAW8Q,0BAA0BvO,OAAQ,CAACkD,iBAChDO,MAAK,eACEzB,SAAWlE,aAAa0E,eAAepE,WAAW,UAC/CU,OAAOkD,aAEjByB,MAAK,kBACKlG,OAAO+G,QACV5G,oBAAoB8Q,2BACpBhO,2BAA2BpC,eAGlCqF,MAAK,SAASC,eACXS,eAAeK,UAERd,WAuwBAM,MAAM3G,aAAawK,WAClCyB,KAAKuC,cAAcC,kBASnB2C,qBAAuB,SAASrE,EAAGd,MAxwBlB,IACbtJ,OACAkD,eACAiB,gBAFAnE,OAAS5B,UAAUqB,eACnByD,eAAiB9E,UAAUiC,GAC3B8D,eAAiB,IAAI7G,QAAQ,gEAE1BG,WAAWiR,4BAA4B1O,OAAQ,CAACkD,iBAClDO,MAAK,eACEzB,SAAWlE,aAAa0E,eAAepE,WAAW,UAC/CU,OAAOkD,aAEjByB,MAAK,kBACKlG,OAAO+G,QACV5G,oBAAoBiR,6BACpBnO,2BAA2BpC,eAGlCqF,MAAK,SAASC,eACXS,eAAeK,UAERd,WAsvBEM,MAAM3G,aAAawK,WACpCyB,KAAKuC,cAAcC,kBAUnB8C,eAAiB,SAASxE,EAAGd,MAxvBlB,IACPtJ,OACAkD,eACAiB,gBAFAnE,OAAS5B,UAAUqB,eACnByD,eAAiB9E,UAAUiC,GAC3B8D,eAAiB,IAAI7G,QAAQ,wEAE1BG,WAAWoR,sBAAsB7O,OAAQ,CAACkD,iBAC5CO,MAAK,eACEzB,SAAWlE,aAAa4E,WAAWtE,WAAW,UAC3CU,OAAOkD,aAEjByB,MAAK,kBACKlG,OAAO+G,QACV5G,oBAAoBoR,uBACpBtO,2BAA2BpC,eAGlCqF,MAAK,SAASC,eACXS,eAAeK,UAERd,WAsuBJM,MAAM3G,aAAawK,WAC9ByB,KAAKuC,cAAcC,kBASnBiD,iBAAmB,SAAS3E,EAAGd,MAvuBlB,IACTtJ,OACAkD,gBADAlD,OAAS5B,UAAUqB,eACnByD,eAAiB9E,UAAUiC,GAExB5C,WAAWuR,wBAAwBhP,OAAQ,CAACkD,iBAC9CO,MAAK,eACEzB,SAAWlE,aAAa4E,WAAWtE,WAAW,UAC3CU,OAAOkD,aAEjByB,MAAK,kBACKlG,OAAO+G,QACV5G,oBAAoBuR,yBACpBzO,2BAA2BpC,gBA4tB1B4F,MAAM3G,aAAawK,WAChCyB,KAAKuC,cAAcC,kBASnBoD,sCAAwC,SAAS9E,OAC7C+E,SAAWlS,EAAEmN,EAAE6B,QAAQmD,KAAK,WAC5BpN,SAAWlE,aAAa0J,6BAA6BpJ,UAAW+Q,UACpErQ,OAAOkD,WASPqN,4BAA8B,SAASlB,kBAChC,SAAS/D,EAAGd,MACfvL,oBAAoBqQ,GAChBD,UACAnQ,oBAAoBsR,gBACpB,CACIjP,GAAIjC,UAAUiC,GACdK,KAAMtC,UAAUsC,KAChBC,QAASvC,UAAUuC,QACnBC,SAAUxC,UAAUwC,SACpBG,iBAAkB3C,UAAU2C,kBAEhC3C,UAAUqB,gBAEd6J,KAAKuC,cAAcC,mBAUvByD,wBAA0B,SAASnF,EAAGd,UAClCtH,SAAWlE,aAAa0R,mBAAmBpR,WAAYA,UAAUqR,iBACrE3Q,OAAOkD,UACPsH,KAAKuC,cAAcC,kBAQnB4D,uBAAyB,SAAStF,OAC9B6B,OAAShP,EAAEmN,EAAE6B,WAGb7N,UAAUqR,kBACTxD,OAAOC,QAAQ9M,UAAUuQ,wBAAwB1P,SACjDgM,OAAOC,QAAQ9M,UAAUwQ,4BAA4B3P,OACxD,KACM+B,SAAWlE,aAAa0R,mBAAmBpR,WAAW,GAC1DU,OAAOkD,YAYX6N,uBAAyB,SAAS1B,UAAWrD,OAAQC,KAAMC,YACvD8E,uBAAwB,EACxBC,kBAx8CmB,SAAShF,aACzBA,KAAKqB,KAAKhN,UAAU4Q,oBAu8CHC,CAAqBlF,MACzCmF,mBAAqBlF,OAAOoB,KAAKhN,UAAU+Q,cAC3CC,2BAA6BpF,OAAOoB,KAAKhN,UAAUiR,+BACnDC,gBAAkBtF,OAAOoB,KAAKhN,UAAUiN,mBACxCkE,uBAAyB,CACzB,CAACnR,UAAUoR,qBAAsB9E,6BAA6BjH,mBAC9D,CAACrF,UAAUqR,uBAAwB/E,6BAA6BzG,qBAChE,CAAC7F,UAAUsR,2BAA4BhF,6BAA6B7F,oBACpE,CAACzG,UAAUuR,8BAA+BjF,6BAA6BpG,uBACvE,CAAClG,UAAUwR,mCAAoClF,6BAA6B5D,4BAC5E,CAAC1I,UAAUyR,wBAAyB7C,sBACpC,CAAC5O,UAAU0R,oBAAqB5C,0BAA0BC,YAC1D,CAAC/O,UAAU2R,uBAAwB1B,4BAA4BlB,YAC/D,CAAC/O,UAAU4R,yBAA0B1C,oBACrC,CAAClP,UAAU6R,oBAAqBrC,gBAChC,CAACxP,UAAU8R,2BAA4BzC,sBACvC,CAACrP,UAAU+R,sBAAuBpC,mBAElCqC,qBAAuB,CACvB,CAAChS,UAAUiS,sBAAuB3F,6BAA6BhH,gBAC/D,CAACtF,UAAUkS,qBAAsB5F,6BAA6B9G,YAC9D,CAACxF,UAAUmS,uBAAwB7F,6BAA6BvG,cAChE,CAAC/F,UAAUoS,2BAA4B9F,6BAA6B3F,aACpE,CAAC3G,UAAUqS,8BAA+B/F,6BAA6BlG,gBACvE,CAACpG,UAAUsS,wCAAyChG,6BAA6BjF,yBACjF,CAACrH,UAAUuS,mCAAoCjG,6BAA6B1D,qBAC5E,CAAC5I,UAAUwS,oBAAqBlG,6BAA6BhH,gBAC7D,CAACtF,UAAUsR,2BAA4BhF,6BAA6B7F,oBACpE,CAACzG,UAAUyS,8BAA+BnG,6BAA6BxD,uBACvE,CAAC9I,UAAU0S,+BAAgCpG,6BAA6BlD,wBACxE,CAACpJ,UAAUsO,QAASR,qBACpB,CAAC9N,UAAU2S,qCAAsC7C,uCACjD,CAAC9P,UAAU4S,WAAYpE,yBAEvBqE,uBAAyB,CACzB,CAAC7S,UAAU8S,oBAAqBnG,mBAChC,CAAC3M,UAAUwQ,2BAA4BL,yBACvC,CAACnQ,UAAU+S,wCAAyCzG,6BAA6BpF,gCACjF,CAAClH,UAAUsR,2BAA4BhF,6BAA6B7F,oBACpE,CAACzG,UAAUqR,uBAAwB/E,6BAA6BzG,sBAGpE/H,SAASkV,KAAKpH,QAEVoF,2BAA2BnQ,QAC3BhC,4BACImS,2BAA2B,GAC3BE,gBAAgB,IAChB,SAAS+B,oBACDrQ,SAAWlE,aAAawU,yBAAyBlU,UAAWiU,gBAChEvT,OAAOkD,aAEX,SAASuQ,WACDvQ,SAAWlE,aAAawU,yBAAyBlU,WAAW,GAChEU,OAAOkD,UAEPsO,gBAAgBrD,YACZuF,UAAYlC,gBAAgBlB,KAAK,kBACjCqD,YAAcnC,gBAAgBhE,MAC9BoG,WAAaD,YAAYE,UAAU,EAAGH,WAAW5H,QAAQ,OAAQ,IACjEgI,UAAYH,YAAYE,UAAUH,WAAW5H,QAAQ,OAAQ,IAEjE0F,gBAAgBhE,IAAIoG,WAAaH,MAAQK,WAEzCtC,gBAAgBlB,KAAK,iBAAkBsD,WAAWzS,OAASsS,MAAMtS,QACjEqQ,gBAAgBlB,KAAK,eAAgBsD,WAAWzS,OAASsS,MAAMtS,WAKvEiQ,mBAAmBjQ,QACnB/B,sBAAsBgS,mBAAmB,IAAI,SAASqC,WAC9CvQ,SAAWlE,aAAa0R,mBAAmBpR,WAAYA,UAAUqR,iBACrE3Q,OAAOkD,UAEPsO,gBAAgBrD,YACZuF,UAAYlC,gBAAgBlB,KAAK,kBACjCqD,YAAcnC,gBAAgBhE,MAC9BoG,WAAaD,YAAYE,UAAU,EAAGH,WACtCI,UAAYH,YAAYE,UAAUH,UAAWC,YAAYxS,QAE7DqQ,gBAAgBhE,IAAIoG,WAAaH,MAAQK,WAEzCtC,gBAAgBlB,KAAK,iBAAkBoD,UAAYD,MAAMtS,QACzDqQ,gBAAgBlB,KAAK,eAAgBoD,UAAYD,MAAMtS,WAI/D7C,aAAaJ,OAAO8N,OAAQ,CACxB1N,aAAayV,OAAOC,WAExB1V,aAAaJ,OAAO+N,KAAM,CACtB3N,aAAayV,OAAOC,WAExB1V,aAAaJ,OAAOgO,OAAQ,CACxB5N,aAAayV,OAAOC,SACpB1V,aAAayV,OAAOE,MACpB3V,aAAayV,OAAOG,SAExB5V,aAAaJ,OAAO+S,kBAAmB,CACnC3S,aAAayV,OAAOI,UACpB7V,aAAayV,OAAOK,aAGxBnD,kBAAkBoD,GAAG/V,aAAayV,OAAOI,WAAW,SAAS7I,EAAGd,UACxD8J,WAAaxT,OAAOC,KAAKzB,UAAU0B,SAASG,OAAS,MAEpDvB,cAAgBoR,wBAA0BxP,wBAA0B8S,WAAY,CACjFtD,uBAAwB,MACpB9N,SAAWlE,aAAaiG,mBAAmB3F,WAAW,GAC1DU,OAAOkD,UAEPiB,aAAa7E,UAAUiC,GAAInB,mBAAoBgB,oBAAqBlB,aAAc,IAC7EyE,MAAK,WACFqM,uBAAwB,EACxB3P,kBAAkBD,oBAAsBhB,uBAG3C8E,OAAM,SAASC,OACZ6L,uBAAwB,EACxBzS,aAAawK,UAAU5D,UAInCqF,KAAKuC,cAAcC,oBAGvByE,uBAAuB9G,SAAQ,SAAS4J,aAChCC,SAAWD,QAAQ,GACnBE,gBAAkBF,QAAQ,GAC9BvI,OAAOqI,GAAG/V,aAAayV,OAAOC,SAAUQ,SAAUC,oBAGtDnC,qBAAqB3H,SAAQ,SAAS4J,aAC9BC,SAAWD,QAAQ,GACnBE,gBAAkBF,QAAQ,GAC9BtI,KAAKoI,GAAG/V,aAAayV,OAAOC,SAAUQ,SAAUC,oBAGpDtB,uBAAuBxI,SAAQ,SAAS4J,aAChCC,SAAWD,QAAQ,GACnBE,gBAAkBF,QAAQ,GAC9BrI,OAAOmI,GAAG/V,aAAayV,OAAOC,SAAUQ,SAAUC,oBAGtDvI,OAAOmI,GAAG/V,aAAayV,OAAOE,MAAO3T,UAAUiN,mBAAmB,SAASjC,EAAGd,UACtEkK,YAAcxI,OAAO2C,KAAK,sBAC1B6F,aAA8B,SAAfA,aAAyC,KAAfA,aACzCzH,kBAAkB3B,EAAGd,SAI7B0B,OAAOmI,GAAG/V,aAAayV,OAAOG,OAAQ5T,UAAUuQ,uBAAwBJ,yBACxEtS,EAAE4P,SAAS9B,MAAMoI,GAAG,QAASzD,wBAE7BnS,OAAOkW,UAAU/V,oBAAoBgW,eAAe,SAASC,cACrDpV,sBACIoV,aAAaC,OAAS5V,oBAAoB6V,mBAC1CtV,qBAAqB6I,WAWjC8C,sBAAwB,SAAShH,gBAC7B3E,sBACAA,qBAAqB6I,OAGzB7I,qBAAuB,IAAIpB,aA9yCE,SAAS+F,eAAgBG,oBAC/C,eACCrC,SAAW5C,UAAU4C,SACrB8S,kBAAoB9S,SAASf,OAASe,SAASA,SAASf,OAAS,GAAK,KACtE8T,gBAAkBD,kBAAoBA,kBAAkBE,YAAc,QAEtED,kBAAoBrV,cAAgBC,mBAAqBC,8BAA+B,SAMpFqV,iBAAmB,GACdC,EAAIlT,SAASf,OAAS,EAAGiU,GAAK,EAAGA,IAAK,KACvChT,QAAUF,SAASkT,MACnBhT,QAAQ8S,cAAgBD,sBACxBE,iBAAiBpK,KAAK3I,QAAQb,WAS/B4C,aACCC,eACA,EACA,EACAG,YACA4Q,iBACAF,iBAEHtQ,MAAK,SAASC,WACPA,OAAO1C,SAASf,OAAQ,CAGxB1B,qBAAqB4V,cAGjB3S,aAAehB,2BAA2BpC,kBAC9Cb,OAAO+G,QAAQ5G,oBAAoBiK,8BAA+BnG,cAC3D0C,uBAAuBhB,uBAEvBQ,iBAKhBzG,EAAE8J,WAAWvC,UAAUwC,WA8vC9BoN,CAA2BlR,eAAgBlE,cAC3C7B,aAAakX,uBACTjW,UAAUkW,eAAiBnV,oBAC3BA,oBACAf,UAAUmW,eAAiBpV,oBAC3Bf,UAAUoW,oBAAsBrV,sBAIxCZ,qBAAqBkW,SAUrBC,WAAa,SAAS3J,KAAM7H,eAAgByR,qBAGxCpW,sBACAA,qBAAqB6I,OAEzB/I,mBAAoB,EACpBC,eAAiB,EACjBC,qBAAuB,KACvBC,aAAc,EACdC,aAAe,GACfC,aAAc,EACdC,kBAAmB,EACnBC,+BAAgC,EAChCC,kBAAoB,OAEhBY,eAAiBkV,oBAAoBtU,GACrCuU,SAAWhR,SAASmH,KAAK4C,KAAK,iBAAkB,IAChD2G,eAAiB1Q,SAASmH,KAAK4C,KAAK,yBAA0B,IAC9D4G,eAAiB3Q,SAASmH,KAAK4C,KAAK,yBAA0B,IAC9D6G,oBAAsB5Q,SAASmH,KAAK4C,KAAK,+BAAgC,IACzEkH,aAAe/W,aAAagX,kBAC5BF,SACAnV,eACAyD,eACAoR,eACAC,eACAC,qBAGCpW,YACDA,UAAYyW,cAGhB/V,OAAO+V,eAWPE,oBAAsB,SAAShK,KAAM4J,oBAAqBzL,aAG1DwL,WAAW3J,KAAM,KAAM4J,4BAInBA,oBAAoBtU,IAAM6I,YAEGzL,WAAWuX,4BACpCL,oBAAoBtU,GACpB6I,aACA,GACA,EACA,EACA,EACAhK,mBACA,EACAF,cAIyBvB,WAAWwX,oBACpCN,oBAAoBtU,GACpBnB,mBACA,EACAF,eAI0ByE,MAAK,SAASjC,qBAEjC0T,oBAAoBnK,KAAMvJ,aAAcmT,wBAElD3Q,OAAM,kBA7qDoB,SAAS2Q,oBAAqBzL,iBACzDzJ,eAAiBkV,oBAAoBtU,GAGrC8U,iBAAmB1V,gBAAkByJ,YAAc7J,mBAAmBK,KAAOL,mBAAmBqC,QAChGM,SAAWlE,aAAasX,kBAAkBhX,WAAW,UACzD4D,SAAWlE,aAAaiG,mBAAmB/B,UAAU,GACrDlD,OAAOkD,UAEAvE,WAAW4X,cAAc5V,eAAgB,CAACyJ,cAAc,GAAM,GAChEzF,MAAK,SAASiC,aACPA,SAASzF,cACFyF,SAAS,SAEV,IAAIQ,MAAM,wCAGvBzC,MAAK,SAASqB,aAGPhF,QAAUqV,kBAAoB9V,mBAAmBK,KAAO,CAACoF,SAAW,CAACA,QAAS6P,qBAC9E3S,SAAWlE,aAAamE,WAAW7D,UAAW0B,gBAClDkC,SAAWlE,aAAasX,kBAAkBpT,UAAU,GACpDA,SAAWlE,aAAaiG,mBAAmB/B,UAAU,GACrDA,SAAWlE,aAAaoE,QAAQF,SAAU8C,QAAQhD,UAClDE,SAAWlE,aAAasE,QAAQJ,SAAUmT,kBAC1CnT,SAAWlE,aAAauE,YAAYL,SAAU8C,QAAQ/C,iBACtDC,SAAWlE,aAAawE,oBAAoBN,SAAUlC,QAAQG,QAC9DnB,OAAOkD,UACA8C,WAEVd,OAAM,SAASC,WACRjC,SAAWlE,aAAasX,kBAAkBhX,WAAW,GACzDU,OAAOkD,UACP3E,aAAawK,UAAU5D,UA6oDhBqR,CAA6BX,oBAAqBzL,iBAYjEqM,UAAY,SAASxK,KAAM7H,eAAgByR,yBACvCa,MAAQ,KACRtS,kBAAkB/E,aAClBqX,MAAQrX,WAAW+E,iBAKvBwR,WAAW3J,KAAM7H,eAAgByR,yBAE7B3N,QAAU/J,EAAE8J,WAAWvC,QAAQ,IAAIwC,aACnCwO,MAAO,KAGHxT,SAAWwT,MAAM/U,MAErBuB,SAAWlE,aAAaiG,mBAAmB/B,UAAU,GACrDA,SAAWlE,aAAasX,kBAAkBpT,UAAU,GACpD7B,kBAAkBqV,MAAMlX,gBACxBiC,qBAAqBiV,MAAMnX,mBAC3BS,OAAOkD,eAEPgF,QAvnDkB,SACtB9D,eACAyR,oBACAc,aACAC,cACArS,iBAEI5D,eAAiBkV,oBAAoBtU,GACrC2B,SAAWlE,aAAasX,kBAAkBhX,WAAW,UACzD4D,SAAWlE,aAAaiG,mBAAmB/B,UAAU,GACrDlD,OAAOkD,UAEAvE,WAAWkY,gBACdlW,eACAyD,gBACA,GACA,EACA,EACA,EACAuS,aAAe,EACfC,cACArS,aAECI,MAAK,SAASjC,qBACPA,aAAaR,SAASf,OAASwV,aAC/BjU,aAAaR,SAAWQ,aAAaR,SAAS6C,MAAM,GAEpDtD,sBAAqB,GAGzBJ,kBAAkBuV,cAAgBD,cAE3BjU,gBAEViC,MAAK,SAASjC,cACWA,aAAa1B,QAAQC,QAAO,SAAS6B,eAChDA,OAAOvB,IAAMsU,oBAAoBtU,MAGxBJ,OAAS,IACzBuB,aAAa1B,QAAU0B,aAAa1B,QAAQ8V,OAAO,CAACjB,2BAGpD3S,SAAWT,4BAA4BC,aAAcmT,oBAAoBtU,WAC7E2B,SAAWlE,aAAasX,kBAAkBpT,UAAU,GACpDA,SAAWlE,aAAaiG,mBAAmB/B,UAAU,GAC9ClD,OAAOkD,UACTyB,MAAK,kBACKjC,mBAGlBiC,MAAK,kBACKS,uBAAuBhB,mBAEjCc,OAAM,SAASC,WACRjC,SAAWlE,aAAasX,kBAAkBhX,WAAW,GACzD4D,SAAWlE,aAAaiG,mBAAmB/B,UAAU,GACrDlD,OAAOkD,UACP3E,aAAawK,UAAU5D,UA6jDjB4R,CACN3S,eACAyR,oBACAzV,mBACA,EACAF,qBAIDgI,QAAQvD,MAAK,kBACTyG,sBAAsBhH,oBAYjCgS,oBAAsB,SAASnK,KAAMvJ,aAAcmT,yBAC/Ca,MAAQ,KACRhU,aAAanB,MAAMlC,aACnBqX,MAAQrX,WAAWqD,aAAanB,KAKpCqU,WAAW3J,KAAMvJ,aAAanB,GAAIsU,yBAE9B3N,QAAU/J,EAAE8J,WAAWvC,QAAQ,IAAIwC,aACnCwO,MAAO,KAGHxT,SAAWwT,MAAM/U,MAErBuB,SAAWlE,aAAaiG,mBAAmB/B,UAAU,GACrDA,SAAWlE,aAAasX,kBAAkBpT,UAAU,GACpD7B,kBAAkBqV,MAAMlX,gBACxBiC,qBAAqBiV,MAAMnX,mBAC3BS,OAAOkD,eAEPgF,QA5lDuB,SAC3BxF,aACAmT,oBACAc,aACApS,aAEsB7B,aAAa1B,QAAQC,QAAO,SAAS6B,eAChDA,OAAOvB,IAAMsU,oBAAoBtU,MAGxBJ,OAAS,IACzBuB,aAAa1B,QAAU0B,aAAa1B,QAAQ8V,OAAO,CAACjB,2BAGpDmB,aAAetU,aAAaR,SAASf,OACrC8V,wBAA0BD,cAAgBL,aAC1CzT,SAAWT,4BAA4BC,aAAcmT,oBAAoBtU,WAC7E2B,SAAWlE,aAAasX,kBAAkBpT,UAAU,GACpDA,SAAWlE,aAAaiG,mBAAmB/B,UAAW+T,yBAClCjX,OAAOkD,UAENyB,MAAK,kBACbsS,wBAKM,CAAC/U,SAAUQ,aAAaR,UAHxBiC,aAAazB,aAAanB,GAAIoV,aAAcK,aAAczS,YAAa,OAMrFI,MAAK,eACEzC,SAAW5C,UAAU4C,gBAEzBb,kBAAkBa,SAASf,QAC3BiE,uBAAuB9F,UAAUiC,IAE1BW,YAEVgD,MAAM3G,aAAawK,WAsjDVmO,CACNxU,aACAmT,oBACAzV,mBACAF,qBAIDgI,QAAQvD,MAAK,kBACTyG,sBAAsB1I,aAAanB,cAqI5C4V,0BAA4B,SAASC,QAAShT,eAAgBgG,aAChEgN,QAAQC,WAAW,wBACnBD,QAAQC,WAAW,sBACfjT,eACAgT,QAAQvI,KAAK,uBAAwBzK,gBAC9BgG,aACPgN,QAAQvI,KAAK,qBAAsBzE,oBAIpC,CACHkN,KAzHO,SAASjI,UAAWrD,OAAQC,KAAMC,OAAQqL,iBAAkBC,OAAQpN,iBA/5DvBlJ,OAg6DhDwB,aAAe,KACf0B,eAAiB,KAGjBmT,kBAAyC,OAArBA,kBAAwD,iBAApBA,kBACxD7U,aAAe6U,iBACfnT,eAAiBU,SAASpC,aAAanB,GAAI,MAE3CmB,aAAe,KACf0B,eAAiBU,SAASyS,iBAAkB,IAC5CnT,eAAiBqT,MAAMrT,gBAAkB,KAAOA,iBAG/CA,gBAAkBoT,QAAUpN,cA76DmBlJ,OAg7DUkJ,YAA1DhG,eA/6DGtD,OAAOC,KAAK1B,YAAYqY,QAAO,SAASC,MAAOpW,QAC7CoW,MAAO,KACJhW,MAAQtC,WAAWkC,IAAII,MAEvBA,MAAMlB,MAAQF,mBAAmBG,QAC7BQ,UAAUS,MAAMX,UAEhB2W,MAAQhW,MAAMJ,WAKnBoW,QACR,OAs6DHR,0BAA0BjL,OAAQ9H,eAAgBgG,iBAU9CwN,mBAAqBtY,WAAcA,UAAUiC,IAAM6C,gBAAoBgG,aAAeA,aAAe5J,oBAEpGyL,KAAK4C,KAAK,eAGX7O,OAvsBqB,SAASgM,OAAQC,KAAMC,OAAQ0L,uBACpDC,aAAe,SAAStL,cACjBxN,SAASiB,OAAOgM,OAAQC,KAAMC,OAAQK,YAG5CqL,kBAAmB,KAGhB7B,aAAe/W,aAAagX,kBAAkB1W,UAAUwW,SAAUxW,UAAUqB,eAAgBrB,UAAUiC,IAE1GsW,aADgB/Y,QAAQgZ,WAAW/B,aAAczW,mBAIrDW,UAAU8K,KAAK8M,cAER,SAAS3U,cACRqJ,MAAQzN,QAAQgZ,WAAWxY,UAAW4D,UACtCwJ,SAAWvO,EAAE8J,kBAGbnH,OAAOC,KAAKwL,OAAOpL,OAEnBxB,aAAaoL,KAAK,CACdwB,MAAOA,MACPG,SAAUA,WAGdA,SAAShH,SAAQ,GASrBpG,UAAY4D,SACRA,SAAS3B,KAETlC,WAAW6D,SAAS3B,IAAM,CACtBI,MAAOuB,SACP1D,eAAgB4B,oBAChB7B,kBAAmBiC,yBAK3BuK,oBAAoBC,OAAQC,KAAMC,QAE3BQ,SAASxE,WAspBP6P,CAAuB/L,OAAQC,KAAMC,OAAQ0L,mBACtD7G,uBAAuB1B,UAAWrD,OAAQC,KAAMC,QAChDD,KAAK4C,KAAK,aAAa,IAGvB+I,kBAAmB,KAEf/B,oBAn7DiB,SAAS5J,YAC3B,CACH1K,GAAIuD,SAASmH,KAAK4C,KAAK,gBAAiB,IACxC7L,SAAU,KACVC,gBAAiB,KACjB+U,qBAAsB,KACtBC,SAAW,KACXC,iBAAkB,KAClBC,UAAW,KACXC,UAAW,KACXC,UAAW,KACXC,WAAY,KACZC,wBAAyB,KACzBC,gBAAiB,KACjBjW,gBAAiB,GACjBkW,iBAAkB,MAo6DQC,CAAuBzM,aAE7CvJ,aACgB0T,oBAAoBnK,KAAMvJ,aAAcmT,oBAAqBzL,aACtEhG,eACSqS,UAAUxK,KAAM7H,eAAgByR,qBAEhCI,oBAAoBhK,KAAM4J,oBAAqBzL,cAI9DzF,MAAK,WACF/E,aAAc,EAEdoM,OAAOsB,KAAKzO,UAAUyB,UAAUqY,mBAAmBC,QAAQzK,WAG9DjJ,OAAM,SAASC,OACZvF,aAAc,EACdrB,aAAawK,UAAU5D,aAMnCiG,sBAAsBhH,gBAElB9E,UAAUmB,MAAQF,mBAAmBqC,SAAW4U,OAAQ,KAGpDqB,mBAAqBrY,wBAEjBgX,YACC,eACM7R,iBAAiBkT,wBACvB,iBACM1S,mBAAmB0S,wBACzB,qBACM9R,kBAAkB8R,wBACxB,wBACMrS,qBAAqBqS,4BAKjC1a,EAAE8J,WAAWvC,UAAUwC,WAkC9B4Q,YA1Bc,kBACPpa,IAAI8M,WAAW,gCAAiC,eAAgBlM,UAAUsC"}