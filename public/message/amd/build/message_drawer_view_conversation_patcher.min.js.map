{"version":3,"file":"message_drawer_view_conversation_patcher.min.js","sources":["../src/message_drawer_view_conversation_patcher.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * This module will take 2 view states from the message_drawer_view_conversation\r\n * module and generate a patch that can be given to the\r\n * message_drawer_view_conversation_renderer module to update the UI.\r\n *\r\n * This module should never modify either state. It's purely a read only\r\n * module.\r\n *\r\n * @module     core_message/message_drawer_view_conversation_patcher\r\n * @copyright  2018 Ryan Wyllie <ryan@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\ndefine(\r\n[\r\n    'jquery',\r\n    'core/user_date',\r\n    'core_message/message_drawer_view_conversation_constants'\r\n],\r\nfunction(\r\n    $,\r\n    UserDate,\r\n    Constants\r\n) {\r\n    /**\r\n     * Sort messages by day.\r\n     *\r\n     * @param  {Array} messages The list of messages to sort.\r\n     * @param  {Number} midnight User's midnight timestamp.\r\n     * @return {Array} messages sorted by day.\r\n     */\r\n    var sortMessagesByDay = function(messages, midnight) {\r\n        var messagesByDay = messages.reduce(function(carry, message) {\r\n            var timeCreated = message.timeCreated ? message.timeCreated : midnight;\r\n            var dayTimestamp = UserDate.getUserMidnightForTimestamp(timeCreated, midnight);\r\n\r\n            if (carry.hasOwnProperty(dayTimestamp)) {\r\n                carry[dayTimestamp].push(message);\r\n            } else {\r\n                carry[dayTimestamp] = [message];\r\n            }\r\n\r\n            return carry;\r\n        }, {});\r\n\r\n        return Object.keys(messagesByDay).map(function(dayTimestamp) {\r\n            return {\r\n                timestamp: dayTimestamp,\r\n                messages: messagesByDay[dayTimestamp]\r\n            };\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Diff 2 arrays using a match function\r\n     *\r\n     * @param  {Array} a The first array.\r\n     * @param  {Array} b The second array.\r\n     * @param  {Function} matchFunction Function used for matching array items.\r\n     * @return {Object} Object containing array items missing from a, array items missing from b\r\n     * and matches\r\n     */\r\n    var diffArrays = function(a, b, matchFunction) {\r\n        // Make copy of it.\r\n        b = b.slice();\r\n        var missingFromA = [];\r\n        var missingFromB = [];\r\n        var matches = [];\r\n\r\n        a.forEach(function(current) {\r\n            var found = false;\r\n            var index = 0;\r\n\r\n            for (; index < b.length; index++) {\r\n                var next = b[index];\r\n\r\n                if (matchFunction(current, next)) {\r\n                    found = true;\r\n                    matches.push({\r\n                        a: current,\r\n                        b: next\r\n                    });\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (found) {\r\n                // This day has been processed so removed it from the list.\r\n                b.splice(index, 1);\r\n            } else {\r\n                // If we couldn't find it in the next messages then it means\r\n                // it needs to be added.\r\n                missingFromB.push(current);\r\n            }\r\n        });\r\n\r\n        missingFromA = b;\r\n\r\n        return {\r\n            missingFromA: missingFromA,\r\n            missingFromB: missingFromB,\r\n            matches: matches\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Find an element in a array based on a matching function.\r\n     *\r\n     * @param  {array} array Array to search.\r\n     * @param  {Function} breakFunction Function to run on array item.\r\n     * @return {*} The array item.\r\n     */\r\n    var findPositionInArray = function(array, breakFunction) {\r\n        var before = null;\r\n\r\n        for (var i = 0; i < array.length; i++) {\r\n            var candidate = array[i];\r\n\r\n            if (breakFunction(candidate)) {\r\n                return candidate;\r\n            }\r\n        }\r\n\r\n        return before;\r\n    };\r\n\r\n    /**\r\n     * Check if 2 arrays are equal.\r\n     *\r\n     * @param  {Array} a The first array.\r\n     * @param  {Array} b The second array.\r\n     * @return {Boolean} Are arrays equal.\r\n     */\r\n    var isArrayEqual = function(a, b) {\r\n        // Make shallow copies so that we don't mess with the array sorting.\r\n        a = a.slice();\r\n        b = b.slice();\r\n        a.sort();\r\n        b.sort();\r\n        var aLength = a.length;\r\n        var bLength = b.length;\r\n\r\n        if (aLength < 1 && bLength < 1) {\r\n            return true;\r\n        }\r\n\r\n        if (aLength != bLength) {\r\n            return false;\r\n        }\r\n\r\n        return a.every(function(item, index) {\r\n            return item == b[index];\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Do a shallow check to see if two objects appear to be equal. This should\r\n     * only be used for pretty basic objects.\r\n     *\r\n     * @param {Object} a First object to compare.\r\n     * @param {Object} b Second object to compare\r\n     * @return {Bool}\r\n     */\r\n    var isObjectEqual = function(a, b) {\r\n        var aKeys = Object.keys(a);\r\n        var bKeys = Object.keys(b);\r\n\r\n        if (aKeys.length != bKeys.length) {\r\n            return false;\r\n        }\r\n\r\n        return aKeys.every(function(key) {\r\n            var aVal = a[key];\r\n            var bVal = b[key];\r\n            var aType = typeof aVal;\r\n            var bType = typeof bVal;\r\n            aType = (aVal === null) ? 'null' : aType;\r\n            bType = (aVal === null) ? 'null' : bType;\r\n            aType = (aType === 'object' && Array.isArray(aType)) ? 'array' : aType;\r\n            bType = (bType === 'object' && Array.isArray(bType)) ? 'array' : bType;\r\n\r\n            if (aType !== bType) {\r\n                return false;\r\n            }\r\n\r\n            switch (aType) {\r\n                case 'object':\r\n                    return isObjectEqual(aVal, bVal);\r\n                case 'array':\r\n                    return isArrayEqual(aVal, bVal);\r\n                default:\r\n                    return a[key] == b[key];\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Compare two messages to check if they are equal. This function only checks a subset\r\n     * of the message properties which we know will change rather than all properties.\r\n     *\r\n     * @param {Object} a The first message\r\n     * @param {Object} b The second message\r\n     * @return {Bool}\r\n     */\r\n    var isMessageEqual = function(a, b) {\r\n        return isObjectEqual(\r\n            {\r\n                id: a.id,\r\n                state: a.sendState,\r\n                text: a.text,\r\n                timeCreated: a.timeCreated\r\n            },\r\n            {\r\n                id: b.id,\r\n                state: b.sendState,\r\n                text: b.text,\r\n                timeCreated: b.timeCreated\r\n            }\r\n        );\r\n    };\r\n\r\n    /**\r\n     * Build a patch based on days.\r\n     *\r\n     * @param  {Object} current Current list current items.\r\n     * @param  {Array} remove List of days to remove.\r\n     * @param  {Array} add List of days to add.\r\n     * @return {Object} Patch with elements to add and remove.\r\n     */\r\n    var buildDaysPatch = function(current, remove, add) {\r\n        return {\r\n            remove: remove,\r\n            add: add.map(function(day) {\r\n                // Any days left over in the \"next\" list weren't in the \"current\" list\r\n                // so they will need to be added.\r\n                var before = findPositionInArray(current, function(candidate) {\r\n                    return day.timestamp < candidate.timestamp;\r\n                });\r\n\r\n                return {\r\n                    before: before,\r\n                    value: day\r\n                };\r\n            })\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Build the messages patch for each day.\r\n     *\r\n     * @param {Array} matchingDays Array of old and new messages sorted by day.\r\n     * @return {Object} patch.\r\n     */\r\n    var buildMessagesPatch = function(matchingDays) {\r\n        var remove = [];\r\n        var add = [];\r\n        var update = [];\r\n\r\n        // Iterate over the list of days and determine which messages in those days\r\n        // have been changed.\r\n        matchingDays.forEach(function(days) {\r\n            var dayCurrent = days.a;\r\n            var dayNext = days.b;\r\n            // Find out which messages have changed in this day. This will return a list of messages\r\n            // from the current state that couldn't be found in the next state and a list of messages in\r\n            // the next state which couldn't be count in the current state.\r\n            var messagesDiff = diffArrays(dayCurrent.messages, dayNext.messages, isMessageEqual);\r\n            // Take the two arrays (list of messages changed from dayNext and list of messages changed\r\n            // from dayCurrent) any work out which messages have been added/removed from the list and\r\n            // which messages were just updated.\r\n            var patch = diffArrays(\r\n                // The messages from dayCurrent.message that weren't in dayNext.messages.\r\n                messagesDiff.missingFromB,\r\n                // The messages from dayNext.message that weren't in dayCurrent.messages.\r\n                messagesDiff.missingFromA,\r\n                function(a, b) {\r\n                    // This function is going to determine if the messages were\r\n                    // added/removed from either list or if they were simply an updated.\r\n                    //\r\n                    // If the IDs match or it was a state change (i.e. message with a temp\r\n                    // ID goes from pending to sent and receives an actual id) then they are\r\n                    // the same message which should be an update not an add/remove.\r\n                    return a.id == b.id || (a.sendState != b.sendState && a.timeAdded == b.timeAdded);\r\n                }\r\n            );\r\n\r\n            // Any messages from the current state for this day which aren't in the next state\r\n            // for this day (i.e. the user deleted the message) means we need to remove them from\r\n            // the UI.\r\n            remove = remove.concat(patch.missingFromB);\r\n\r\n            // Any messages not in the current state for this day which are in the next state\r\n            // for this day (i.e. it's a new message) means we need to add it to the UI so work\r\n            // out where in the list of messages it should appear (it could be a new message the\r\n            // user has sent or older messages loaded as part of the conversation scroll back).\r\n            patch.missingFromA.forEach(function(message) {\r\n                // By default a null value for before will render the message at the bottom of\r\n                // the message UI (i.e. it's the newest message).\r\n                var before = null;\r\n\r\n                if (message.timeCreated) {\r\n                    // If this message has a time created then find where it sits in the list of\r\n                    // message to insert it into the correct position.\r\n                    before = findPositionInArray(dayCurrent.messages, function(candidate) {\r\n                        if (message.timeCreated == candidate.timeCreated) {\r\n                            return message.id < candidate.id;\r\n                        } else {\r\n                            return message.timeCreated < candidate.timeCreated;\r\n                        }\r\n                    });\r\n                }\r\n\r\n                add.push({\r\n                    before: before,\r\n                    value: message,\r\n                    day: dayCurrent\r\n                });\r\n            });\r\n\r\n            // Any message that appears in both the current state for this day and the next state\r\n            // for this day means something in the message was updated.\r\n            update = update.concat(patch.matches.map(function(message) {\r\n                return {\r\n                    before: message.a,\r\n                    after: message.b\r\n                };\r\n            }));\r\n        });\r\n\r\n        return {\r\n            add: add,\r\n            remove: remove,\r\n            update: update\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Build a patch for this conversation.\r\n     *\r\n     * @param  {Object} state The current state of this conversation.\r\n     * @param  {Object} newState The new state of this conversation.\r\n     * @returns {Object} Patch with days and messsages for each day.\r\n     */\r\n    var buildConversationPatch = function(state, newState) {\r\n        var diff = diffArrays(state.messages, newState.messages, isMessageEqual);\r\n\r\n        if (diff.missingFromA.length || diff.missingFromB.length) {\r\n            // Some messages have changed so let's work out which ones by sorting\r\n            // them into their respective days.\r\n            var current = sortMessagesByDay(state.messages, state.midnight);\r\n            var next = sortMessagesByDay(newState.messages, newState.midnight);\r\n            // This diffs the arrays to work out if there are any missing days that need\r\n            // to be added (i.e. we've got some new messages on a new day) or if there\r\n            // are any days that need to be deleted (i.e. the user has deleted some old messages).\r\n            var daysDiff = diffArrays(current, next, function(dayCurrent, dayNext) {\r\n                return dayCurrent.timestamp == dayNext.timestamp;\r\n            });\r\n\r\n            return {\r\n                // Handle adding or removing whole days.\r\n                days: buildDaysPatch(current, daysDiff.missingFromB, daysDiff.missingFromA),\r\n                // Handle updating messages that don't require adding/removing a whole day.\r\n                messages: buildMessagesPatch(daysDiff.matches),\r\n                unableToMessage: buildUnableToMessagePatch(state, newState),\r\n            };\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Build a patch for the header of this conversation. Check if this conversation\r\n     * is a group conversation.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object} patch\r\n     */\r\n    var buildHeaderPatchTypePrivate = function(state, newState) {\r\n        var requireAddContact = buildRequireAddContact(state, newState);\r\n        var confirmContactRequest = buildConfirmContactRequest(state, newState);\r\n        var oldOtherUser = getOtherUserFromState(state);\r\n        var newOtherUser = getOtherUserFromState(newState);\r\n        var requiresAddContact = requireAddContact && requireAddContact.show && !requireAddContact.hasMessages;\r\n        var requiredAddContact = requireAddContact && !requireAddContact.show;\r\n        // Render the header once we've got a user.\r\n        var shouldRenderHeader = !oldOtherUser && newOtherUser;\r\n        // We should also re-render the header if the other user requires\r\n        // being added as a contact or if they did but no longer do.\r\n        shouldRenderHeader = shouldRenderHeader || requiresAddContact || requiredAddContact;\r\n        // Finally, we should re-render if the other user has sent this user\r\n        // a contact request that is waiting for approval or if it's been approved/declined.\r\n        shouldRenderHeader = shouldRenderHeader || confirmContactRequest !== null;\r\n\r\n        if (shouldRenderHeader) {\r\n            return {\r\n                type: Constants.CONVERSATION_TYPES.PRIVATE,\r\n                // We can show controls if the other user doesn't require add contact\r\n                // and we aren't waiting for this user to respond to a contact request.\r\n                showControls: !requiresAddContact && !confirmContactRequest,\r\n                context: {\r\n                    id: newState.id,\r\n                    name: newState.name,\r\n                    subname: newState.subname,\r\n                    totalmembercount: newState.totalMemberCount,\r\n                    imageurl: newState.imageUrl,\r\n                    isfavourite: newState.isFavourite,\r\n                    ismuted: newState.isMuted,\r\n                    // Don't show favouriting if we don't have a conversation.\r\n                    showfavourite: newState.id !== null,\r\n                    userid: newOtherUser.id,\r\n                    showonlinestatus: newOtherUser.showonlinestatus,\r\n                    isonline: newOtherUser.isonline,\r\n                    isblocked: newOtherUser.isblocked,\r\n                    iscontact: newOtherUser.iscontact,\r\n                    cancreatecontact: newOtherUser.cancreatecontact,\r\n                }\r\n            };\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Build a patch for the header of this conversation. Check if this conversation\r\n     * is a group conversation.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object} patch\r\n     */\r\n    var buildHeaderPatchTypeSelf = function(state, newState) {\r\n        var shouldRenderHeader = (state.name === null && newState.name !== null);\r\n\r\n        if (shouldRenderHeader) {\r\n            return {\r\n                type: Constants.CONVERSATION_TYPES.SELF,\r\n                // Don't display the controls for the self-conversations.\r\n                showControls: false,\r\n                context: {\r\n                    id: newState.id,\r\n                    name: newState.name,\r\n                    subname: newState.subname,\r\n                    imageurl: newState.imageUrl,\r\n                    isfavourite: newState.isFavourite,\r\n                    // Don't show favouriting if we don't have a conversation.\r\n                    showfavourite: newState.id !== null,\r\n                    showonlinestatus: true,\r\n                }\r\n            };\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Build a patch for the header of this conversation. Check if this conversation\r\n     * is a group conversation.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object} patch\r\n     */\r\n    var buildHeaderPatchTypePublic = function(state, newState) {\r\n        var oldMemberCount = state.totalMemberCount;\r\n        var newMemberCount = newState.totalMemberCount;\r\n\r\n        if (oldMemberCount != newMemberCount) {\r\n            return {\r\n                type: Constants.CONVERSATION_TYPES.PUBLIC,\r\n                showControls: true,\r\n                context: {\r\n                    id: newState.id,\r\n                    name: newState.name,\r\n                    subname: newState.subname,\r\n                    totalmembercount: newState.totalMemberCount,\r\n                    imageurl: newState.imageUrl,\r\n                    isfavourite: newState.isFavourite,\r\n                    ismuted: newState.isMuted,\r\n                    // Don't show favouriting if we don't have a conversation.\r\n                    showfavourite: newState.id !== null\r\n                }\r\n            };\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Find the newest or oldest message.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Number} Oldest or newest message id.\r\n     */\r\n    var buildScrollToMessagePatch = function(state, newState) {\r\n        var oldMessages = state.messages;\r\n        var newMessages = newState.messages;\r\n\r\n        if (newMessages.length < 1) {\r\n            return null;\r\n        }\r\n\r\n        if (oldMessages.length < 1) {\r\n            return newMessages[newMessages.length - 1].id;\r\n        }\r\n\r\n        var previousNewest = oldMessages[state.messages.length - 1];\r\n        var currentNewest = newMessages[newMessages.length - 1];\r\n        var previousOldest = oldMessages[0];\r\n        var currentOldest = newMessages[0];\r\n\r\n        if (previousNewest.id != currentNewest.id) {\r\n            return currentNewest.id;\r\n        } else if (previousOldest.id != currentOldest.id) {\r\n            return previousOldest.id;\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Check if members should be loaded.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildLoadingMembersPatch = function(state, newState) {\r\n        if (!state.loadingMembers && newState.loadingMembers) {\r\n            return true;\r\n        } else if (state.loadingMembers && !newState.loadingMembers) {\r\n            return false;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Check if the messages are being loaded for the first time.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildLoadingFirstMessages = function(state, newState) {\r\n        if (state.hasTriedToLoadMessages === newState.hasTriedToLoadMessages) {\r\n            return null;\r\n        } else if (!newState.hasTriedToLoadMessages && newState.loadingMessages) {\r\n            return true;\r\n        } else if (newState.hasTriedToLoadMessages && !newState.loadingMessages) {\r\n            return false;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Check if the messages are still being loaded\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildLoadingMessages = function(state, newState) {\r\n        if (!state.loadingMessages && newState.loadingMessages) {\r\n            return true;\r\n        } else if (state.loadingMessages && !newState.loadingMessages) {\r\n            return false;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Determine if we should show the emoji picker.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildShowEmojiPicker = function(state, newState) {\r\n        if (!state.showEmojiPicker && newState.showEmojiPicker) {\r\n            return true;\r\n        } else if (state.showEmojiPicker && !newState.showEmojiPicker) {\r\n            return false;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Determine if we should show the emoji auto complete.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildShowEmojiAutoComplete = function(state, newState) {\r\n        if (!state.showEmojiAutoComplete && newState.showEmojiAutoComplete) {\r\n            return true;\r\n        } else if (state.showEmojiAutoComplete && !newState.showEmojiAutoComplete) {\r\n            return false;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Get the user Object of user to be blocked if pending.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object|Bool|Null} User Object if Object.\r\n     */\r\n    var buildConfirmBlockUser = function(state, newState) {\r\n        if (newState.pendingBlockUserIds.length) {\r\n            // We currently only support a single user;\r\n            var userId = newState.pendingBlockUserIds[0];\r\n            return newState.members[userId];\r\n        } else if (state.pendingBlockUserIds.length) {\r\n            return false;\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Get the user Object of user to be unblocked if pending.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object|Bool|Null} User Object if Object.\r\n     */\r\n    var buildConfirmUnblockUser = function(state, newState) {\r\n        if (newState.pendingUnblockUserIds.length) {\r\n            // We currently only support a single user;\r\n            var userId = newState.pendingUnblockUserIds[0];\r\n            return newState.members[userId];\r\n        } else if (state.pendingUnblockUserIds.length) {\r\n            return false;\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Get the user Object of user to be added as contact if pending.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object|Bool|Null} User Object if Object.\r\n     */\r\n    var buildConfirmAddContact = function(state, newState) {\r\n        if (newState.pendingAddContactIds.length) {\r\n            // We currently only support a single user;\r\n            var userId = newState.pendingAddContactIds[0];\r\n            return newState.members[userId];\r\n        } else if (state.pendingAddContactIds.length) {\r\n            return false;\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Get the user Object of user to be removed as contact if pending.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object|Bool|Null} User Object if Object.\r\n     */\r\n    var buildConfirmRemoveContact = function(state, newState) {\r\n        if (newState.pendingRemoveContactIds.length) {\r\n            // We currently only support a single user;\r\n            var userId = newState.pendingRemoveContactIds[0];\r\n            return newState.members[userId];\r\n        } else if (state.pendingRemoveContactIds.length) {\r\n            return false;\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Check if there are any messages to be deleted.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object|Null} The conversation type and if the user can delete  the messages for all users.\r\n     */\r\n    var buildConfirmDeleteSelectedMessages = function(state, newState) {\r\n        var oldPendingCount = state.pendingDeleteMessageIds.length;\r\n        var newPendingCount = newState.pendingDeleteMessageIds.length;\r\n\r\n        if (newPendingCount && !oldPendingCount) {\r\n            return {\r\n                show: true,\r\n                type: newState.type,\r\n                canDeleteMessagesForAllUsers: newState.canDeleteMessagesForAllUsers\r\n            };\r\n        } else if (oldPendingCount && !newPendingCount) {\r\n            return {\r\n                show: false\r\n            };\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Check if there is a conversation to be deleted.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {int|Null} The conversation type to be deleted.\r\n     */\r\n    var buildConfirmDeleteConversation = function(state, newState) {\r\n        if (!state.pendingDeleteConversation && newState.pendingDeleteConversation) {\r\n            return newState.type;\r\n        } else if (state.pendingDeleteConversation && !newState.pendingDeleteConversation) {\r\n            return false;\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Check if there is a pending contact request to accept or decline.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildConfirmContactRequest = function(state, newState) {\r\n        var loggedInUserId = state.loggedInUserId;\r\n        var oldOtherUser = getOtherUserFromState(state);\r\n        var newOtherUser = getOtherUserFromState(newState);\r\n        var oldReceivedRequests = !oldOtherUser ? [] : oldOtherUser.contactrequests.filter(function(request) {\r\n            return request.requesteduserid == loggedInUserId && request.userid == oldOtherUser.id;\r\n        });\r\n        var newReceivedRequests = !newOtherUser ? [] : newOtherUser.contactrequests.filter(function(request) {\r\n            return request.requesteduserid == loggedInUserId && request.userid == newOtherUser.id;\r\n        });\r\n        var oldRequest = oldReceivedRequests.length ? oldReceivedRequests[0] : null;\r\n        var newRequest = newReceivedRequests.length ? newReceivedRequests[0] : null;\r\n\r\n        if (!oldRequest && newRequest) {\r\n            return newOtherUser;\r\n        } else if (oldRequest && !newRequest) {\r\n            return false;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Check if there are any changes in blocked users.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildIsBlocked = function(state, newState) {\r\n        var oldOtherUser = getOtherUserFromState(state);\r\n        var newOtherUser = getOtherUserFromState(newState);\r\n\r\n        if (!oldOtherUser && !newOtherUser) {\r\n            return null;\r\n        } else if (!oldOtherUser && newOtherUser) {\r\n            return newOtherUser.isblocked ? true : null;\r\n        } else if (!newOtherUser && oldOtherUser) {\r\n            return oldOtherUser.isblocked ? false : null;\r\n        } else if (oldOtherUser.isblocked && !newOtherUser.isblocked) {\r\n            return false;\r\n        } else if (!oldOtherUser.isblocked && newOtherUser.isblocked) {\r\n            return true;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Check if there are any changes the conversation favourite state.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildIsFavourite = function(state, newState) {\r\n        var oldIsFavourite = state.isFavourite;\r\n        var newIsFavourite = newState.isFavourite;\r\n\r\n        if (state.id === null && newState.id === null) {\r\n            // The conversation isn't yet created so don't change anything.\r\n            return null;\r\n        } else if (state.id === null && newState.id !== null) {\r\n            // The conversation was created so we can show the add favourite button.\r\n            return 'show-add';\r\n        } else if (state.id !== null && newState.id === null) {\r\n            // We're changing from a created conversation to a new conversation so hide\r\n            // the favouriting functionality for now.\r\n            return 'hide';\r\n        } else if (oldIsFavourite == newIsFavourite) {\r\n            // No change.\r\n            return null;\r\n        } else if (!oldIsFavourite && newIsFavourite) {\r\n            return 'show-remove';\r\n        } else if (oldIsFavourite && !newIsFavourite) {\r\n            return 'show-add';\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Check if there are any changes the conversation muted state.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {string|null}\r\n     */\r\n    var buildIsMuted = function(state, newState) {\r\n        var oldIsMuted = state.isMuted;\r\n        var newIsMuted = newState.isMuted;\r\n\r\n        if (state.id === null && newState.id === null) {\r\n            // The conversation isn't yet created so don't change anything.\r\n            return null;\r\n        } else if (state.id === null && newState.id !== null) {\r\n            // The conversation was created so we can show the mute button.\r\n            return 'show-mute';\r\n        } else if (state.id !== null && newState.id === null) {\r\n            // We're changing from a created conversation to a new conversation so hide\r\n            // the muting functionality for now.\r\n            return 'hide';\r\n        } else if (oldIsMuted == newIsMuted) {\r\n            // No change.\r\n            return null;\r\n        } else if (!oldIsMuted && newIsMuted) {\r\n            return 'show-unmute';\r\n        } else if (oldIsMuted && !newIsMuted) {\r\n            return 'show-mute';\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Check if there are any changes in the contact status of the current user\r\n     * and other user.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildIsContact = function(state, newState) {\r\n        var loggedInUserId = state.loggedInUserId;\r\n        var oldOtherUser = getOtherUserFromState(state);\r\n        var newOtherUser = getOtherUserFromState(newState);\r\n        var oldContactRequests = !oldOtherUser ? [] : oldOtherUser.contactrequests.filter(function(request) {\r\n            return (request.userid == loggedInUserId && request.requesteduserid == oldOtherUser.id) ||\r\n                (request.userid == oldOtherUser.id && request.requesteduserid == loggedInUserId);\r\n        });\r\n        var newContactRequests = !newOtherUser ? [] : newOtherUser.contactrequests.filter(function(request) {\r\n            return (request.userid == loggedInUserId && request.requesteduserid == newOtherUser.id) ||\r\n                (request.userid == newOtherUser.id && request.requesteduserid == loggedInUserId);\r\n        });\r\n        var oldHasContactRequests = oldContactRequests.length > 0;\r\n        var newHasContactRequests = newContactRequests.length > 0;\r\n\r\n        if (!oldOtherUser && !newOtherUser) {\r\n            return null;\r\n        } else if (oldHasContactRequests && newHasContactRequests) {\r\n            return null;\r\n        } else if (!oldHasContactRequests && newHasContactRequests && !newOtherUser.iscontact) {\r\n            return 'pending-contact';\r\n        } else if (!oldOtherUser && newOtherUser) {\r\n            return newOtherUser.iscontact ? 'contact' : null;\r\n        } else if (!newOtherUser && oldOtherUser) {\r\n            return oldOtherUser.iscontact ? 'non-contact' : null;\r\n        } else if (oldOtherUser.iscontact && !newOtherUser.iscontact) {\r\n            return newHasContactRequests ? 'pending-contact' : 'non-contact';\r\n        } else if (!oldOtherUser.iscontact && newOtherUser.iscontact) {\r\n            return 'contact';\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Check if a confirm action is active.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildLoadingConfirmationAction = function(state, newState) {\r\n        if (!state.loadingConfirmAction && newState.loadingConfirmAction) {\r\n            return true;\r\n        } else if (state.loadingConfirmAction && !newState.loadingConfirmAction) {\r\n            return false;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Check if a edit mode is active.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildInEditMode = function(state, newState) {\r\n        var oldHasSelectedMessages = state.selectedMessageIds.length > 0;\r\n        var newHasSelectedMessages = newState.selectedMessageIds.length > 0;\r\n        var numberOfMessagesHasChanged = state.messages.length != newState.messages.length;\r\n\r\n        if (!oldHasSelectedMessages && newHasSelectedMessages) {\r\n            return true;\r\n        } else if (oldHasSelectedMessages && !newHasSelectedMessages) {\r\n            return false;\r\n        } else if (oldHasSelectedMessages && numberOfMessagesHasChanged) {\r\n            return true;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Build a patch for the messages selected.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object} patch\r\n     */\r\n    var buildSelectedMessages = function(state, newState) {\r\n        var oldSelectedMessages = state.selectedMessageIds;\r\n        var newSelectedMessages = newState.selectedMessageIds;\r\n\r\n        if (isArrayEqual(oldSelectedMessages, newSelectedMessages)) {\r\n            return null;\r\n        }\r\n\r\n        var diff = diffArrays(oldSelectedMessages, newSelectedMessages, function(a, b) {\r\n            return a == b;\r\n        });\r\n\r\n        return {\r\n            count: newSelectedMessages.length,\r\n            add: diff.missingFromA,\r\n            remove: diff.missingFromB\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Get a list of users from the state that are not the logged in user. Use to find group\r\n     * message members or the other user in a conversation.\r\n     *\r\n     * @param  {Object} state State\r\n     * @return {Array} List of users.\r\n     */\r\n    var getOtherUserFromState = function(state) {\r\n        return Object.keys(state.members).reduce(function(carry, userId) {\r\n            if (userId != state.loggedInUserId && !carry) {\r\n                carry = state.members[userId];\r\n            }\r\n\r\n            return carry;\r\n        }, null);\r\n    };\r\n\r\n    /**\r\n     * Check if the given user requires a contact request from the logged in user.\r\n     *\r\n     * @param  {Integer} loggedInUserId The logged in user id\r\n     * @param  {Object} user User record\r\n     * @return {Bool}\r\n     */\r\n    var requiresContactRequest = function(loggedInUserId, user) {\r\n        // If a user can message then no contact request is required.\r\n        if (user.canmessage) {\r\n            return false;\r\n        }\r\n\r\n        var contactRequests = user.contactrequests.filter(function(request) {\r\n            return request.userid == loggedInUserId || request.requesteduserid;\r\n        });\r\n        var hasSentContactRequest = contactRequests.length > 0;\r\n        return user.requirescontact && !user.iscontact && !hasSentContactRequest;\r\n    };\r\n\r\n    /**\r\n     * Check if other users are required to be added as contact.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object} Object controlling the required to add contact dialog variables.\r\n     */\r\n    var buildRequireAddContact = function(state, newState) {\r\n        var oldOtherUser = getOtherUserFromState(state);\r\n        var newOtherUser = getOtherUserFromState(newState);\r\n        var hadMessages = state.messages.length > 0;\r\n        var hasMessages = newState.messages.length > 0;\r\n        var loggedInUserId = newState.loggedInUserId;\r\n        var prevRequiresContactRequest = oldOtherUser && requiresContactRequest(loggedInUserId, oldOtherUser);\r\n        var nextRequiresContactRequest = newOtherUser && requiresContactRequest(loggedInUserId, newOtherUser);\r\n        var confirmAddContact = buildConfirmAddContact(state, newState);\r\n        var finishedAddContact = confirmAddContact === false;\r\n\r\n        // Still doing first load.\r\n        if (!state.hasTriedToLoadMessages && !newState.hasTriedToLoadMessages) {\r\n            return null;\r\n        }\r\n\r\n        // No users yet.\r\n        if (!oldOtherUser && !newOtherUser) {\r\n            return null;\r\n        }\r\n\r\n        // We've loaded a new user and they require a contact request.\r\n        if (!oldOtherUser && nextRequiresContactRequest) {\r\n            return {\r\n                show: true,\r\n                hasMessages: hasMessages,\r\n                user: newOtherUser\r\n            };\r\n        }\r\n\r\n        // The logged in user has completed the confirm contact request dialogue\r\n        // but the other user still requires a contact request which means the logged\r\n        // in user either declined the confirmation or it failed.\r\n        if (finishedAddContact && nextRequiresContactRequest) {\r\n            return {\r\n                show: true,\r\n                hasMessages: hasMessages,\r\n                user: newOtherUser\r\n            };\r\n        }\r\n\r\n        // Everything is loaded.\r\n        if (state.hasTriedToLoadMessages && newState.hasTriedToLoadMessages) {\r\n            if (!prevRequiresContactRequest && nextRequiresContactRequest) {\r\n                return {\r\n                    show: true,\r\n                    hasMessages: hasMessages,\r\n                    user: newOtherUser\r\n                };\r\n            }\r\n\r\n            if (prevRequiresContactRequest && !nextRequiresContactRequest) {\r\n                return {\r\n                    show: false,\r\n                    hasMessages: hasMessages\r\n                };\r\n            }\r\n        }\r\n\r\n        // First load just completed.\r\n        if (!state.hasTriedToLoadMessages && newState.hasTriedToLoadMessages) {\r\n            if (nextRequiresContactRequest) {\r\n                return {\r\n                    show: true,\r\n                    hasMessages: hasMessages,\r\n                    user: newOtherUser\r\n                };\r\n            }\r\n        }\r\n\r\n        // Being reset.\r\n        if (state.hasTriedToLoadMessages && !newState.hasTriedToLoadMessages) {\r\n            if (prevRequiresContactRequest) {\r\n                return {\r\n                    show: false,\r\n                    hasMessages: hadMessages\r\n                };\r\n            }\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Check if other users are required to be unblocked.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool|Null}\r\n     */\r\n    var buildRequireUnblock = function(state, newState) {\r\n        var oldOtherUser = getOtherUserFromState(state);\r\n        var newOtherUser = getOtherUserFromState(newState);\r\n\r\n        if (!oldOtherUser && !newOtherUser) {\r\n            return null;\r\n        } else if (oldOtherUser && !newOtherUser) {\r\n            return oldOtherUser.isblocked ? false : null;\r\n        } else if (!oldOtherUser && newOtherUser) {\r\n            return newOtherUser.isblocked ? true : null;\r\n        } else if (!oldOtherUser.isblocked && newOtherUser.isblocked) {\r\n            return true;\r\n        } else if (oldOtherUser.isblocked && !newOtherUser.isblocked) {\r\n            return false;\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Check if other users can be messaged.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Bool}\r\n     */\r\n    const buildUnableToMessagePatch = (state, newState) => {\r\n        if (newState.type == Constants.CONVERSATION_TYPES.SELF) {\r\n            // Users always can send message themselves on self-conversations.\r\n            return false;\r\n        }\r\n\r\n        const oldOtherUser = getOtherUserFromState(state);\r\n        const newOtherUser = getOtherUserFromState(newState);\r\n\r\n        if (!oldOtherUser && !newOtherUser) {\r\n            return false;\r\n        } else if (oldOtherUser && !newOtherUser) {\r\n            return !oldOtherUser.canmessage;\r\n        } else if (!oldOtherUser && newOtherUser) {\r\n            return !newOtherUser.canmessage;\r\n        } else if (!oldOtherUser.canmessage && newOtherUser.canmessage) {\r\n            return false;\r\n        } else if (oldOtherUser.canmessage && !newOtherUser.canmessage) {\r\n            return true;\r\n        }\r\n\r\n        return !newState.canSendMessageToConversation;\r\n    };\r\n\r\n    /**\r\n     * Build patch for footer information for a private conversation.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object} containing footer state type.\r\n     */\r\n    var buildFooterPatchTypePrivate = function(state, newState) {\r\n        var loadingFirstMessages = buildLoadingFirstMessages(state, newState);\r\n        var inEditMode = buildInEditMode(state, newState);\r\n        var requireAddContact = buildRequireAddContact(state, newState);\r\n        var requireUnblock = buildRequireUnblock(state, newState);\r\n        var showRequireAddContact = requireAddContact !== null ? requireAddContact.show && requireAddContact.hasMessages : null;\r\n        var otherUser = getOtherUserFromState(newState);\r\n        var generateReturnValue = function(checkValue, successReturn) {\r\n            if (checkValue) {\r\n                return successReturn;\r\n            } else if (checkValue !== null && !checkValue) {\r\n                if (!otherUser) {\r\n                    return {type: 'content'};\r\n                } else if (otherUser.isblocked) {\r\n                    return {type: 'unblock'};\r\n                } else if (newState.messages.length && requiresContactRequest(newState.loggedInUserId, otherUser)) {\r\n                    return {\r\n                        type: 'add-contact',\r\n                        user: otherUser\r\n                    };\r\n                }\r\n            }\r\n\r\n            return null;\r\n        };\r\n\r\n        if (\r\n            loadingFirstMessages === null &&\r\n            inEditMode === null &&\r\n            requireAddContact === null &&\r\n            requireUnblock === null\r\n        ) {\r\n            return null;\r\n        }\r\n\r\n        var checks = [\r\n            [loadingFirstMessages, {type: 'placeholder'}],\r\n            [inEditMode, {type: 'edit-mode'}],\r\n            [requireUnblock, {type: 'unblock'}],\r\n            [showRequireAddContact, {type: 'add-contact', user: otherUser}]\r\n        ];\r\n\r\n        for (var i = 0; i < checks.length; i++) {\r\n            var checkValue = checks[i][0];\r\n            var successReturn = checks[i][1];\r\n            var result = generateReturnValue(checkValue, successReturn);\r\n\r\n            if (result !== null) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        return {\r\n            type: 'content'\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Build patch for footer information for a public conversation.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object} containing footer state type.\r\n     */\r\n    var buildFooterPatchTypePublic = function(state, newState) {\r\n        var loadingFirstMessages = buildLoadingFirstMessages(state, newState);\r\n        var inEditMode = buildInEditMode(state, newState);\r\n\r\n        if (loadingFirstMessages === null && inEditMode === null) {\r\n            return null;\r\n        }\r\n\r\n        if (loadingFirstMessages) {\r\n            return {type: 'placeholder'};\r\n        }\r\n\r\n        if (inEditMode) {\r\n            return {type: 'edit-mode'};\r\n        }\r\n\r\n        return {\r\n            type: 'content'\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Check if we're viewing a different conversation. If so then we need to\r\n     * reset the UI.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {bool|null} If a reset needs to occur\r\n     */\r\n    var buildReset = function(state, newState) {\r\n        var oldType = state.type;\r\n        var newType = newState.type;\r\n        var oldConversationId = state.id;\r\n        var newConversationId = newState.id;\r\n        var oldMemberIds = Object.keys(state.members);\r\n        var newMemberIds = Object.keys(newState.members);\r\n\r\n        oldMemberIds.sort();\r\n        newMemberIds.sort();\r\n\r\n        var membersUnchanged = oldMemberIds.every(function(id, index) {\r\n            return id == newMemberIds[index];\r\n        });\r\n\r\n        if (oldType != newType) {\r\n            // If we've changed conversation type then we need to reset.\r\n            return true;\r\n        } else if (oldConversationId && !newConversationId) {\r\n            // We previously had a conversation id but no longer do. This likely means\r\n            // the user is viewing the conversation with someone they've never spoken to\r\n            // before.\r\n            return true;\r\n        } else if (oldConversationId && newConversationId && oldConversationId != newConversationId) {\r\n            // If we had a conversation id and it's changed then we need to reset.\r\n            return true;\r\n        } else if (!oldConversationId && !newConversationId && !membersUnchanged) {\r\n            // If we never had a conversation id but the members of the conversation have\r\n            // changed then we need to reset. This can happen if the user goes from viewing\r\n            // a user they've never had a conversation with to viewing a different user that\r\n            // they've never had a conversation with.\r\n            return true;\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * We should show this message always, for all the self-conversations.\r\n     *\r\n     * The message should be hidden when it's not a self-conversation.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {bool}\r\n     */\r\n    var buildSelfConversationMessage = function(state, newState) {\r\n        if (state.type != newState.type) {\r\n            return (newState.type == Constants.CONVERSATION_TYPES.SELF);\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * We should show the contact request sent message if the user just sent\r\n     * a contact request to the other user\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {string|false|null}\r\n     */\r\n    var buildContactRequestSent = function(state, newState) {\r\n        var loggedInUserId = newState.loggedInUserId;\r\n        var oldOtherUser = getOtherUserFromState(state);\r\n        var newOtherUser = getOtherUserFromState(newState);\r\n        var oldSentRequests = !oldOtherUser ? [] : oldOtherUser.contactrequests.filter(function(request) {\r\n            return request.userid == loggedInUserId;\r\n        });\r\n        var newSentRequests = !newOtherUser ? [] : newOtherUser.contactrequests.filter(function(request) {\r\n            return request.userid == loggedInUserId;\r\n        });\r\n        var oldRequest = oldSentRequests.length > 0;\r\n        var newRequest = newSentRequests.length > 0;\r\n\r\n        if (!oldRequest && newRequest && !newOtherUser.iscontact) {\r\n            return newOtherUser.fullname;\r\n        } else if (oldOtherUser && !oldOtherUser.iscontact && newRequest && newOtherUser.iscontact) {\r\n            // Contact request accepted.\r\n            return false;\r\n        } else if (oldRequest && !newRequest) {\r\n            return false;\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Build the full patch comparing the current state and the new state. This patch is used by\r\n     * the conversation renderer to render the UI on any update.\r\n     *\r\n     * @param  {Object} state The current state.\r\n     * @param  {Object} newState The new state.\r\n     * @return {Object} Patch containing all information changed.\r\n     */\r\n    var buildPatch = function(state, newState) {\r\n        var config = {\r\n            all: {\r\n                reset: buildReset,\r\n                conversation: buildConversationPatch,\r\n                scrollToMessage: buildScrollToMessagePatch,\r\n                loadingMembers: buildLoadingMembersPatch,\r\n                loadingFirstMessages: buildLoadingFirstMessages,\r\n                loadingMessages: buildLoadingMessages,\r\n                confirmDeleteSelectedMessages: buildConfirmDeleteSelectedMessages,\r\n                inEditMode: buildInEditMode,\r\n                selectedMessages: buildSelectedMessages,\r\n                isFavourite: buildIsFavourite,\r\n                isMuted: buildIsMuted,\r\n                showEmojiPicker: buildShowEmojiPicker,\r\n                showEmojiAutoComplete: buildShowEmojiAutoComplete,\r\n                unableToMessage: buildUnableToMessagePatch\r\n            }\r\n        };\r\n        // These build functions are only applicable to private conversations.\r\n        config[Constants.CONVERSATION_TYPES.PRIVATE] = {\r\n            header: buildHeaderPatchTypePrivate,\r\n            footer: buildFooterPatchTypePrivate,\r\n            confirmBlockUser: buildConfirmBlockUser,\r\n            confirmUnblockUser: buildConfirmUnblockUser,\r\n            confirmAddContact: buildConfirmAddContact,\r\n            confirmRemoveContact: buildConfirmRemoveContact,\r\n            confirmContactRequest: buildConfirmContactRequest,\r\n            confirmDeleteConversation: buildConfirmDeleteConversation,\r\n            isBlocked: buildIsBlocked,\r\n            isContact: buildIsContact,\r\n            loadingConfirmAction: buildLoadingConfirmationAction,\r\n            requireAddContact: buildRequireAddContact,\r\n            contactRequestSent: buildContactRequestSent\r\n        };\r\n        // These build functions are only applicable to public (group) conversations.\r\n        config[Constants.CONVERSATION_TYPES.PUBLIC] = {\r\n            header: buildHeaderPatchTypePublic,\r\n            footer: buildFooterPatchTypePublic,\r\n        };\r\n        // These build functions are only applicable to self-conversations.\r\n        config[Constants.CONVERSATION_TYPES.SELF] = {\r\n            header: buildHeaderPatchTypeSelf,\r\n            footer: buildFooterPatchTypePublic,\r\n            confirmDeleteConversation: buildConfirmDeleteConversation,\r\n            selfConversationMessage: buildSelfConversationMessage\r\n        };\r\n\r\n        var patchConfig = $.extend({}, config.all);\r\n        if (newState.type && newState.type in config) {\r\n            // Add the type specific builders to the patch config.\r\n            patchConfig = $.extend(patchConfig, config[newState.type]);\r\n        }\r\n\r\n        return Object.keys(patchConfig).reduce(function(patch, key) {\r\n            var buildFunc = patchConfig[key];\r\n            var value = buildFunc(state, newState);\r\n\r\n            if (value !== null) {\r\n                patch[key] = value;\r\n            }\r\n\r\n            return patch;\r\n        }, {});\r\n    };\r\n\r\n    return {\r\n        buildPatch: buildPatch\r\n    };\r\n});\r\n"],"names":["define","$","UserDate","Constants","sortMessagesByDay","messages","midnight","messagesByDay","reduce","carry","message","timeCreated","dayTimestamp","getUserMidnightForTimestamp","hasOwnProperty","push","Object","keys","map","timestamp","diffArrays","a","b","matchFunction","slice","missingFromB","matches","forEach","current","found","index","length","next","splice","missingFromA","findPositionInArray","array","breakFunction","i","candidate","isArrayEqual","sort","aLength","bLength","every","item","isObjectEqual","aKeys","bKeys","key","aVal","bVal","aType","bType","Array","isArray","isMessageEqual","id","state","sendState","text","buildDaysPatch","remove","add","day","before","value","buildConversationPatch","newState","matchingDays","update","diff","daysDiff","dayCurrent","dayNext","days","messagesDiff","patch","timeAdded","concat","after","unableToMessage","buildUnableToMessagePatch","buildHeaderPatchTypePrivate","requireAddContact","buildRequireAddContact","confirmContactRequest","buildConfirmContactRequest","oldOtherUser","getOtherUserFromState","newOtherUser","requiresAddContact","show","hasMessages","requiredAddContact","shouldRenderHeader","type","CONVERSATION_TYPES","PRIVATE","showControls","context","name","subname","totalmembercount","totalMemberCount","imageurl","imageUrl","isfavourite","isFavourite","ismuted","isMuted","showfavourite","userid","showonlinestatus","isonline","isblocked","iscontact","cancreatecontact","buildHeaderPatchTypeSelf","SELF","buildHeaderPatchTypePublic","PUBLIC","buildScrollToMessagePatch","oldMessages","newMessages","previousNewest","currentNewest","previousOldest","currentOldest","buildLoadingMembersPatch","loadingMembers","buildLoadingFirstMessages","hasTriedToLoadMessages","loadingMessages","buildLoadingMessages","buildShowEmojiPicker","showEmojiPicker","buildShowEmojiAutoComplete","showEmojiAutoComplete","buildConfirmBlockUser","pendingBlockUserIds","userId","members","buildConfirmUnblockUser","pendingUnblockUserIds","buildConfirmAddContact","pendingAddContactIds","buildConfirmRemoveContact","pendingRemoveContactIds","buildConfirmDeleteSelectedMessages","oldPendingCount","pendingDeleteMessageIds","newPendingCount","canDeleteMessagesForAllUsers","buildConfirmDeleteConversation","pendingDeleteConversation","loggedInUserId","oldReceivedRequests","contactrequests","filter","request","requesteduserid","newReceivedRequests","oldRequest","newRequest","buildIsBlocked","buildIsFavourite","oldIsFavourite","newIsFavourite","buildIsMuted","oldIsMuted","newIsMuted","buildIsContact","oldContactRequests","newContactRequests","oldHasContactRequests","newHasContactRequests","buildLoadingConfirmationAction","loadingConfirmAction","buildInEditMode","oldHasSelectedMessages","selectedMessageIds","newHasSelectedMessages","numberOfMessagesHasChanged","buildSelectedMessages","oldSelectedMessages","newSelectedMessages","count","requiresContactRequest","user","canmessage","hasSentContactRequest","requirescontact","hadMessages","prevRequiresContactRequest","nextRequiresContactRequest","finishedAddContact","canSendMessageToConversation","buildFooterPatchTypePrivate","loadingFirstMessages","inEditMode","requireUnblock","buildRequireUnblock","showRequireAddContact","otherUser","generateReturnValue","checkValue","successReturn","checks","result","buildFooterPatchTypePublic","buildReset","oldType","newType","oldConversationId","newConversationId","oldMemberIds","newMemberIds","membersUnchanged","buildSelfConversationMessage","buildContactRequestSent","oldSentRequests","newSentRequests","fullname","buildPatch","config","all","reset","conversation","scrollToMessage","confirmDeleteSelectedMessages","selectedMessages","header","footer","confirmBlockUser","confirmUnblockUser","confirmAddContact","confirmRemoveContact","confirmDeleteConversation","isBlocked","isContact","contactRequestSent","selfConversationMessage","patchConfig","extend","buildFunc"],"mappings":"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"}