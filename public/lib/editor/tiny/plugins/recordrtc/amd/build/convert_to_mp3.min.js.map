{"version":3,"file":"convert_to_mp3.min.js","sources":["../src/convert_to_mp3.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Convert audio to MP3.\r\n *\r\n * @module     tiny_recordrtc/convert_to_mp3\r\n * @copyright  Meirza <meirza.arson@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nimport lamejs from './lame.all';\r\n\r\n/**\r\n * Extract Pulse Code Modulation (PCM) data from an AudioBuffer to get raw channel data.\r\n *\r\n * @param {AudioBuffer} audioBuffer The AudioBuffer containing the audio data.\r\n * @returns {Array<Int16Array>} The PCM data for each channel.\r\n */\r\nconst extractPCM = (audioBuffer) => {\r\n    const channelData = [];\r\n    const numberOfChannels = audioBuffer.numberOfChannels;\r\n    const audioBufferLength = audioBuffer.length;\r\n\r\n    for (let channel = 0; channel < numberOfChannels; channel++) {\r\n        const rawChannelData = audioBuffer.getChannelData(channel);\r\n        channelData[channel] = new Int16Array(audioBufferLength);\r\n        // Convert floating-point audio samples into 16-bit signed integer values.\r\n        for (let i = 0; i < audioBufferLength; i++) {\r\n            channelData[channel][i] = rawChannelData[i] * 32768;\r\n        }\r\n    }\r\n\r\n    return channelData;\r\n};\r\n\r\n/**\r\n * Fetches and decodes the audio data from a given URL into an AudioBuffer.\r\n *\r\n * @param {string} sourceUrl - The URL of the source audio file.\r\n * @returns {Promise<AudioBuffer>} - A promise that resolves with the decoded AudioBuffer object.\r\n */\r\nconst getAudioBuffer = async(sourceUrl) => {\r\n    const response = await fetch(sourceUrl);\r\n    const arrayBuffer = await response.arrayBuffer();\r\n    const audioContext = new (\r\n        window.AudioContext // Default.\r\n        || window.webkitAudioContext // Safari and old versions of Chrome.\r\n    )();\r\n    return audioContext.decodeAudioData(arrayBuffer);\r\n};\r\n\r\n/**\r\n * Converts an AudioBuffer to MP3 format using lamejs.\r\n *\r\n * @param {Object} lamejs - The lamejs library object.\r\n * @param {number} channels - The number of audio channels (1 for mono, 2 for stereo).\r\n * @param {number} sampleRate - The sample rate of the audio (e.g., 44100 Hz).\r\n * @param {number} bitRate - The bitrate (in kbps) to encode the MP3.\r\n * @param {Int16Array} left - The PCM data for the left channel.\r\n * @param {Int16Array} [right=null] - The PCM data for the right channel (optional for stereo).\r\n * @returns {Blob} - A Blob containing the MP3 audio data.\r\n */\r\nconst convertAudioBuffer = (lamejs, channels, sampleRate, bitRate, left, right = null) => {\r\n    const mp3Data = [];\r\n    const mp3Encoder = new lamejs.Mp3Encoder(channels, sampleRate, bitRate);\r\n    // Each frame represents 1152 audio samples per channel (for both mono and stereo).\r\n    const sampleBlockSize = 1152;\r\n\r\n    // Ensure that the same encoding logic works for both mono and stereo audio by\r\n    // either passing both channels or just the left channel to the MP3 encoder.\r\n    for (let i = 0; i < left.length; i += sampleBlockSize) {\r\n        const leftChunk = left.subarray(i, i + sampleBlockSize);\r\n        const mp3Buf = right\r\n            ? mp3Encoder.encodeBuffer(leftChunk, right.subarray(i, i + sampleBlockSize)) // Stereo.\r\n            : mp3Encoder.encodeBuffer(leftChunk); // Mono.\r\n\r\n        if (mp3Buf.length) {\r\n            mp3Data.push(mp3Buf);\r\n        }\r\n    }\r\n\r\n    // Preventing loss of the last few samples of audio.\r\n    const mp3Buf = mp3Encoder.flush();\r\n    if (mp3Buf.length) {\r\n        mp3Data.push(new Int8Array(mp3Buf));\r\n    }\r\n\r\n    return new Blob(mp3Data, {type: 'audio/mp3'});\r\n};\r\n\r\n/**\r\n * Main function to handle the entire process of converting an audio file to MP3 format.\r\n *\r\n * @param {string} sourceUrl - The URL of the source audio file to be converted.\r\n * @param {number} [bitRate=128] - The bitrate (in kbps) for the MP3 conversion. Default is 128 kbps.\r\n * @returns {Promise<Blob>} - A promise that resolves with the MP3 file as a Blob.\r\n *\r\n * @throws {Error} If the Lamejs module or audio buffer fails to load.\r\n *\r\n * @example\r\n * const mp3Data = await convertMp3('audio-source.wav', 192);\r\n * window.console.log(mp3Data); // Logs the ArrayBuffer with MP3 data.\r\n */\r\nexport const convertMp3 = async(sourceUrl, bitRate = 128) => {\r\n    const audioBuffer = await getAudioBuffer(sourceUrl);\r\n    const [left, right] = extractPCM(audioBuffer);\r\n    return convertAudioBuffer(lamejs, audioBuffer.numberOfChannels, audioBuffer.sampleRate, bitRate, left, right);\r\n};\r\n"],"names":["extractPCM","audioBuffer","channelData","numberOfChannels","audioBufferLength","length","channel","rawChannelData","getChannelData","Int16Array","i","getAudioBuffer","async","response","fetch","sourceUrl","arrayBuffer","window","AudioContext","webkitAudioContext","decodeAudioData","convertAudioBuffer","lamejs","channels","sampleRate","bitRate","left","right","mp3Data","mp3Encoder","Mp3Encoder","sampleBlockSize","leftChunk","subarray","mp3Buf","encodeBuffer","push","flush","Int8Array","Blob","type"],"mappings":";;;;;;;kJA+BMA,WAAcC,oBACVC,YAAc,GACdC,iBAAmBF,YAAYE,iBAC/BC,kBAAoBH,YAAYI,WAEjC,IAAIC,QAAU,EAAGA,QAAUH,iBAAkBG,UAAW,OACnDC,eAAiBN,YAAYO,eAAeF,SAClDJ,YAAYI,SAAW,IAAIG,WAAWL,uBAEjC,IAAIM,EAAI,EAAGA,EAAIN,kBAAmBM,IACnCR,YAAYI,SAASI,GAAyB,MAApBH,eAAeG,UAI1CR,aASLS,eAAiBC,MAAAA,kBACbC,eAAiBC,MAAMC,WACvBC,kBAAoBH,SAASG,qBACd,IACjBC,OAAOC,cACJD,OAAOE,qBAEMC,gBAAgBJ,cAclCK,mBAAqB,SAACC,OAAQC,SAAUC,WAAYC,QAASC,UAAMC,6DAAQ,WACvEC,QAAU,GACVC,WAAa,IAAIP,OAAOQ,WAAWP,SAAUC,WAAYC,SAEzDM,gBAAkB,SAInB,IAAIrB,EAAI,EAAGA,EAAIgB,KAAKrB,OAAQK,GAAKqB,gBAAiB,OAC7CC,UAAYN,KAAKO,SAASvB,EAAGA,EAAIqB,iBACjCG,OAASP,MACTE,WAAWM,aAAaH,UAAWL,MAAMM,SAASvB,EAAGA,EAAIqB,kBACzDF,WAAWM,aAAaH,WAE1BE,OAAO7B,QACPuB,QAAQQ,KAAKF,cAKfA,OAASL,WAAWQ,eACtBH,OAAO7B,QACPuB,QAAQQ,KAAK,IAAIE,UAAUJ,SAGxB,IAAIK,KAAKX,QAAS,CAACY,KAAM,mCAgBV5B,eAAMG,eAAWU,+DAAU,UAC3CxB,kBAAoBU,eAAeI,YAClCW,KAAMC,OAAS3B,WAAWC,oBAC1BoB,mBAAmBC,cAAQrB,YAAYE,iBAAkBF,YAAYuB,WAAYC,QAASC,KAAMC"}