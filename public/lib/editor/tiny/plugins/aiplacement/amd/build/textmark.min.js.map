{"version":3,"file":"textmark.min.js","sources":["../src/textmark.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Tiny AI Mark Changed text.\r\n *\r\n * This module marks text that was returned by the AI service\r\n * and that has been changed by a human prior to being inserted.\r\n *\r\n * @module      tiny_aiplacement/textmark\r\n * @copyright   2023 Matt Porritt <matt.porritt@moodle.com>\r\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nexport default class TinyAiTextMarker {\r\n    /**\r\n     * Finds the longest common subsequence of two strings.\r\n     *\r\n     * @param {string} a The first string.\r\n     * @param {string} b The second string.\r\n     * @returns {string} The longest common subsequence.\r\n     */\r\n    static longestCommonSubsequence(a, b) {\r\n        const lengths = Array(a.length + 1)\r\n            .fill(null)\r\n            .map(() => Array(b.length + 1).fill(0));\r\n\r\n        for (let i = 0; i < a.length; i++) {\r\n            for (let j = 0; j < b.length; j++) {\r\n                if (a[i] === b[j]) {\r\n                    lengths[i + 1][j + 1] = lengths[i][j] + 1;\r\n                } else {\r\n                    lengths[i + 1][j + 1] = Math.max(lengths[i + 1][j], lengths[i][j + 1]);\r\n                }\r\n            }\r\n        }\r\n\r\n        let i = a.length;\r\n        let j = b.length;\r\n        let lcs = '';\r\n\r\n        while (i > 0 && j > 0) {\r\n            if (a[i - 1] === b[j - 1]) {\r\n                lcs = a[i - 1] + lcs;\r\n                i--;\r\n                j--;\r\n            } else if (lengths[i - 1][j] > lengths[i][j - 1]) {\r\n                i--;\r\n            } else {\r\n                j--;\r\n            }\r\n        }\r\n\r\n        return lcs;\r\n    }\r\n\r\n    /**\r\n     * Finds the differences between the original and edited text using the LCS algorithm.\r\n     *\r\n     * @param {string} originalText The original text.\r\n     * @param {string} editedText The edited text.\r\n     * @returns {Array<Object>} An array of difference objects with start, end, and text properties.\r\n     */\r\n    static findDifferences(originalText, editedText) {\r\n        const lcs = TinyAiTextMarker.longestCommonSubsequence(originalText, editedText);\r\n        let differences = [];\r\n        let i = 0;\r\n        let j = 0;\r\n\r\n        for (let k = 0; k < lcs.length; k++) {\r\n            let commonChar = lcs[k];\r\n\r\n            while (originalText[i] !== commonChar || editedText[j] !== commonChar) {\r\n                let start = j;\r\n                while (editedText[j] !== commonChar) {\r\n                    j++;\r\n                }\r\n                let editedSection = editedText.slice(start, j);\r\n                differences.push({start, end: j, text: editedSection});\r\n\r\n                while (originalText[i] !== commonChar) {\r\n                    i++;\r\n                }\r\n            }\r\n\r\n            i++;\r\n            j++;\r\n        }\r\n\r\n        if (j < editedText.length) {\r\n            differences.push({start: j, end: editedText.length, text: editedText.slice(j)});\r\n        }\r\n\r\n        return differences;\r\n    }\r\n\r\n    /**\r\n     * Wraps the given edited section in a span tag with a 'user-edited' class.\r\n     *\r\n     * @param {string} editedSection The edited section of the text.\r\n     * @returns {Promise<string>} A promise that resolves with the wrapped edited section.\r\n     */\r\n    static async wrapInSpan(editedSection) {\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                let wrappedText = `<span class=\"user-edited\">${editedSection}</span>`;\r\n                resolve(wrappedText);\r\n            } catch (error) {\r\n                reject(error);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Wraps the edited sections of the text in span tags with a 'user-edited' class.\r\n     *\r\n     * @param {string} originalText The original text.\r\n     * @param {string} editedText The edited text.\r\n     * @returns {Promise<string>} A promise that resolves with the edited text, where edited sections are wrapped in span tags.\r\n     */\r\n    static async wrapEditedSections(originalText, editedText) {\r\n        let differences = TinyAiTextMarker.findDifferences(originalText, editedText);\r\n        let wrappedText = editedText;\r\n\r\n        for (let i = differences.length - 1; i >= 0; i--) {\r\n            let {start, end, text} = differences[i];\r\n            let wrappedSection = await TinyAiTextMarker.wrapInSpan(text);\r\n            wrappedText = wrappedText.slice(0, start) + wrappedSection + wrappedText.slice(end);\r\n        }\r\n\r\n        return wrappedText;\r\n    }\r\n\r\n}\r\n"],"names":["TinyAiTextMarker","a","b","lengths","Array","length","fill","map","i","j","Math","max","lcs","originalText","editedText","longestCommonSubsequence","differences","k","commonChar","start","editedSection","slice","push","end","text","Promise","resolve","reject","error","findDifferences","wrappedText","wrappedSection","wrapInSpan"],"mappings":";;;;;;;;;;;MA0BqBA,iDAQeC,EAAGC,SACzBC,QAAUC,MAAMH,EAAEI,OAAS,GAC5BC,KAAK,MACLC,KAAI,IAAMH,MAAMF,EAAEG,OAAS,GAAGC,KAAK,SAEnC,IAAIE,EAAI,EAAGA,EAAIP,EAAEI,OAAQG,QACrB,IAAIC,EAAI,EAAGA,EAAIP,EAAEG,OAAQI,IACtBR,EAAEO,KAAON,EAAEO,GACXN,QAAQK,EAAI,GAAGC,EAAI,GAAKN,QAAQK,GAAGC,GAAK,EAExCN,QAAQK,EAAI,GAAGC,EAAI,GAAKC,KAAKC,IAAIR,QAAQK,EAAI,GAAGC,GAAIN,QAAQK,GAAGC,EAAI,QAK3ED,EAAIP,EAAEI,OACNI,EAAIP,EAAEG,OACNO,IAAM,QAEHJ,EAAI,GAAKC,EAAI,GACZR,EAAEO,EAAI,KAAON,EAAEO,EAAI,IACnBG,IAAMX,EAAEO,EAAI,GAAKI,IACjBJ,IACAC,KACON,QAAQK,EAAI,GAAGC,GAAKN,QAAQK,GAAGC,EAAI,GAC1CD,IAEAC,WAIDG,2BAUYC,aAAcC,kBAC3BF,IAAMZ,iBAAiBe,yBAAyBF,aAAcC,gBAChEE,YAAc,GACdR,EAAI,EACJC,EAAI,MAEH,IAAIQ,EAAI,EAAGA,EAAIL,IAAIP,OAAQY,IAAK,KAC7BC,WAAaN,IAAIK,QAEdJ,aAAaL,KAAOU,YAAcJ,WAAWL,KAAOS,YAAY,KAC/DC,MAAQV,OACLK,WAAWL,KAAOS,YACrBT,QAEAW,cAAgBN,WAAWO,MAAMF,MAAOV,OAC5CO,YAAYM,KAAK,CAACH,MAAAA,MAAOI,IAAKd,EAAGe,KAAMJ,gBAEhCP,aAAaL,KAAOU,YACvBV,IAIRA,IACAC,WAGAA,EAAIK,WAAWT,QACfW,YAAYM,KAAK,CAACH,MAAOV,EAAGc,IAAKT,WAAWT,OAAQmB,KAAMV,WAAWO,MAAMZ,KAGxEO,oCASaI,sBACb,IAAIK,SAAQ,CAACC,QAASC,cAGrBD,4CAD+CN,0BAEjD,MAAOQ,OACLD,OAAOC,2CAYaf,aAAcC,gBACtCE,YAAchB,iBAAiB6B,gBAAgBhB,aAAcC,YAC7DgB,YAAchB,eAEb,IAAIN,EAAIQ,YAAYX,OAAS,EAAGG,GAAK,EAAGA,IAAK,KAC1CW,MAACA,MAADI,IAAQA,IAARC,KAAaA,MAAQR,YAAYR,GACjCuB,qBAAuB/B,iBAAiBgC,WAAWR,MACvDM,YAAcA,YAAYT,MAAM,EAAGF,OAASY,eAAiBD,YAAYT,MAAME,YAG5EO"}