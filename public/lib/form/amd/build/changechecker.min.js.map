{"version":3,"file":"changechecker.min.js","sources":["../src/changechecker.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * This module provides change detection to forms, allowing a browser to warn the user before navigating away if changes\r\n * have been made.\r\n *\r\n * Two flags are stored for each form:\r\n * * a 'dirty' flag; and\r\n * * a 'submitted' flag.\r\n *\r\n * When the page is unloaded each watched form is checked. If the 'dirty' flag is set for any form, and the 'submitted'\r\n * flag is not set for any form, then a warning is shown.\r\n *\r\n * The 'dirty' flag is set when any form element is modified within a watched form.\r\n * The flag can also be set programatically. This may be required for custom form elements.\r\n *\r\n * It is not possible to customise the warning message in any modern browser.\r\n *\r\n * Please note that some browsers have controls on when these alerts may or may not be shown.\r\n * See {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload} for browser-specific\r\n * notes and references.\r\n *\r\n * @module     core_form/changechecker\r\n * @copyright  2021 Andrew Lyons <andrew@nicols.co.uk>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n * @example <caption>Usage where the FormElement is already held</caption>\r\n *\r\n * import {watchForm} from 'core_form/changechecker';\r\n *\r\n * // Fetch the form element somehow.\r\n * watchForm(formElement);\r\n *\r\n * @example <caption>Usage from the child of a form - i.e. an input, button, div, etc.</caption>\r\n *\r\n * import {watchForm} from 'core_form/changechecker';\r\n *\r\n * // Watch the form by using a child of it.\r\n * watchForm(document.querySelector('input[data-foo=\"bar\"]'););\r\n *\r\n * @example <caption>Usage from within a template</caption>\r\n * <form id=\"mod_example-entry-{{uniqid}}\" ...>\r\n *   <!--\r\n *\r\n *   -->\r\n * </form>\r\n * {{#js}}\r\n * require(['core_form/changechecker'], function(changeChecker) {\r\n *     watchFormById('mod_example-entry-{{uniqid}}');\r\n * });\r\n * {{/js}}\r\n */\r\n\r\nimport {eventTypes} from 'core_editor/events';\r\nimport {getString} from 'core/str';\r\n\r\n/**\r\n * @property {Bool} initialised Whether the change checker has been initialised\r\n * @private\r\n */\r\nlet initialised = false;\r\n\r\n/**\r\n * @property {String} warningString The warning string to show on form change failure\r\n * @private\r\n */\r\nlet warningString;\r\n\r\n/**\r\n * @property {Array} watchedForms The list of watched forms\r\n * @private\r\n */\r\nlet watchedForms = [];\r\n\r\n/**\r\n * @property {Bool} formChangeCheckerDisabled Whether the form change checker has been actively disabled\r\n * @private\r\n */\r\nlet formChangeCheckerDisabled = false;\r\n\r\n/**\r\n * Get the nearest form element from a child element.\r\n *\r\n * @param {HTMLElement} formChild\r\n * @returns {HTMLFormElement|null}\r\n * @private\r\n */\r\nconst getFormFromChild = formChild => formChild.closest('form');\r\n\r\n/**\r\n * Watch the specified form for changes.\r\n *\r\n * @method\r\n * @param   {HTMLElement} formNode\r\n */\r\nexport const watchForm = formNode => {\r\n    // Normalise the formNode.\r\n    formNode = getFormFromChild(formNode);\r\n\r\n    if (!formNode) {\r\n         // No form found.\r\n         return;\r\n    }\r\n\r\n    if (isWatchingForm(formNode)) {\r\n        // This form is already watched.\r\n        return;\r\n    }\r\n\r\n    watchedForms.push(formNode);\r\n};\r\n\r\n/**\r\n * Stop watching the specified form for changes.\r\n *\r\n * If the form was not watched, then no change is made.\r\n *\r\n * A child of the form may be passed instead.\r\n *\r\n * @method\r\n * @param   {HTMLElement} formNode\r\n * @example <caption>Stop watching a form for changes</caption>\r\n * import {unWatchForm} from 'core_form/changechecker';\r\n *\r\n * // ...\r\n * document.addEventListener('click', e => {\r\n *     if (e.target.closest('[data-action=\"changePage\"]')) {\r\n *         unWatchForm(e.target);\r\n *     }\r\n * });\r\n */\r\nexport const unWatchForm = formNode => {\r\n    watchedForms = watchedForms.filter(watchedForm => !watchedForm.contains(formNode));\r\n};\r\n\r\n/**\r\n * Reset the 'dirty' flag for all watched forms.\r\n *\r\n * If a form was previously marked as 'dirty', then this flag will be cleared and when the page is unloaded no warning\r\n * will be shown.\r\n *\r\n * @method\r\n */\r\nexport const resetAllFormDirtyStates = () => {\r\n    watchedForms.forEach(watchedForm => {\r\n        watchedForm.dataset.formSubmitted = \"false\";\r\n        watchedForm.dataset.formDirty = \"false\";\r\n    });\r\n};\r\n\r\n/**\r\n * Reset the 'dirty' flag of the specified form.\r\n *\r\n * @method\r\n * @param   {HTMLElement} formNode\r\n */\r\nexport const resetFormDirtyState = formNode => {\r\n    formNode = getFormFromChild(formNode);\r\n\r\n    if (!formNode) {\r\n         return;\r\n    }\r\n\r\n    formNode.dataset.formSubmitted = \"false\";\r\n    formNode.dataset.formDirty = \"false\";\r\n};\r\n\r\n/**\r\n * Mark all forms as dirty.\r\n *\r\n * This function is only for backwards-compliance with the old YUI module and should not be used in any other situation.\r\n * It will be removed in Moodle 4.4.\r\n *\r\n * @method\r\n */\r\nexport const markAllFormsAsDirty = () => {\r\n    watchedForms.forEach(watchedForm => {\r\n        watchedForm.dataset.formDirty = \"true\";\r\n    });\r\n};\r\n\r\n/**\r\n * Mark a specific form as dirty.\r\n *\r\n * This behaviour may be required for custom form elements which are not caught by the standard change listeners.\r\n *\r\n * @method\r\n * @param   {HTMLElement} formNode\r\n */\r\nexport const markFormAsDirty = formNode => {\r\n    formNode = getFormFromChild(formNode);\r\n\r\n    if (!formNode) {\r\n         return;\r\n    }\r\n\r\n    // Mark it as dirty.\r\n    formNode.dataset.formDirty = \"true\";\r\n};\r\n\r\n/**\r\n * Actively disable the form change checker.\r\n *\r\n * Please note that it cannot be re-enabled once disabled.\r\n *\r\n * @method\r\n */\r\nexport const disableAllChecks = () => {\r\n    formChangeCheckerDisabled = true;\r\n};\r\n\r\n/**\r\n * Check whether any watched from is dirty.\r\n *\r\n * @method\r\n * @returns {Bool}\r\n */\r\nexport const isAnyWatchedFormDirty = () => {\r\n    if (formChangeCheckerDisabled) {\r\n        // The form change checker is disabled.\r\n        return false;\r\n    }\r\n\r\n    const hasSubmittedForm = watchedForms.some(watchedForm => watchedForm.dataset.formSubmitted === \"true\");\r\n    if (hasSubmittedForm) {\r\n        // Do not warn about submitted forms, ever.\r\n        return false;\r\n    }\r\n\r\n    const hasDirtyForm = watchedForms.some(watchedForm => {\r\n        if (!watchedForm.isConnected) {\r\n            // The watched form is not connected to the DOM.\r\n            return false;\r\n        }\r\n\r\n        if (watchedForm.dataset.formDirty === \"true\") {\r\n            // The form has been marked as dirty.\r\n            return true;\r\n        }\r\n\r\n        // Elements currently holding focus will not have triggered change detection.\r\n        // Check whether the value matches the original value upon form load.\r\n        if (document.activeElement && document.activeElement.dataset.propertyIsEnumerable('initialValue')) {\r\n            const isActiveElementWatched = isWatchingForm(document.activeElement)\r\n                && !shouldIgnoreChangesForNode(document.activeElement);\r\n            const hasValueChanged = document.activeElement.dataset.initialValue !== document.activeElement.value;\r\n\r\n            if (isActiveElementWatched && hasValueChanged) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    });\r\n\r\n    if (hasDirtyForm) {\r\n        // At least one form is dirty.\r\n        return true;\r\n    }\r\n\r\n    // Handle TinyMCE editor instances.\r\n    // TinyMCE forms may not have been initialised at the time that startWatching is called.\r\n    // Check whether any tinyMCE editor is dirty.\r\n    if (typeof window.tinyMCE !== 'undefined' && window.tinyMCE.editors) {\r\n        if (window.tinyMCE.editors.some(editor => editor.isDirty())) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // No dirty forms detected.\r\n    return false;\r\n};\r\n\r\n/**\r\n * Get the watched form for the specified target.\r\n *\r\n * @method\r\n * @param   {HTMLNode} target\r\n * @returns {HTMLFormElement}\r\n * @private\r\n */\r\nconst getFormForNode = target => watchedForms.find(watchedForm => watchedForm.contains(target));\r\n\r\n/**\r\n * Whether the specified target is a watched form.\r\n *\r\n * @method\r\n * @param   {HTMLNode} target\r\n * @returns {Bool}\r\n * @private\r\n */\r\nconst isWatchingForm = target => watchedForms.some(watchedForm => watchedForm.contains(target));\r\n\r\n/**\r\n * Whether the specified target should ignore changes or not.\r\n *\r\n * @method\r\n * @param   {HTMLNode} target\r\n * @returns {Bool}\r\n * @private\r\n */\r\nconst shouldIgnoreChangesForNode = target => !!target.closest('.ignoredirty');\r\n\r\n/**\r\n * Mark a form as changed.\r\n *\r\n * @method\r\n * @param   {HTMLElement} changedNode An element in the form which was changed\r\n */\r\nexport const markFormChangedFromNode = changedNode => {\r\n    if (changedNode.dataset.formChangeCheckerOverride) {\r\n        // Changes to this form node disable the form change checker entirely.\r\n        // This is intended for select fields which cause an immediate redirect.\r\n        disableAllChecks();\r\n        return;\r\n    }\r\n\r\n    if (!isWatchingForm(changedNode)) {\r\n        return;\r\n    }\r\n\r\n    if (shouldIgnoreChangesForNode(changedNode)) {\r\n        return;\r\n    }\r\n\r\n    // Mark the form as dirty.\r\n    const formNode = getFormForNode(changedNode);\r\n    formNode.dataset.formDirty = \"true\";\r\n};\r\n\r\n/**\r\n * Mark a form as submitted.\r\n *\r\n * @method\r\n * @param   {HTMLElement} formNode An element in the form to mark as submitted\r\n */\r\nexport const markFormSubmitted = formNode => {\r\n    formNode = getFormFromChild(formNode);\r\n\r\n    if (!formNode) {\r\n         return;\r\n    }\r\n\r\n    formNode.dataset.formSubmitted = \"true\";\r\n};\r\n\r\n/**\r\n * Mark all forms as submitted.\r\n *\r\n * This function is only for backwards-compliance with the old YUI module and should not be used in any other situation.\r\n * It will be removed in Moodle 4.4.\r\n *\r\n * @method\r\n */\r\nexport const markAllFormsSubmitted = () => {\r\n    watchedForms.forEach(watchedForm => markFormSubmitted(watchedForm));\r\n};\r\n\r\n/**\r\n * Handle the beforeunload event.\r\n *\r\n * @method\r\n * @param   {Event} e\r\n * @returns {string|null}\r\n * @private\r\n */\r\nconst beforeUnloadHandler = e => {\r\n    // Please note: The use of Promises in this function is forbidden.\r\n    // This is an event handler and _cannot_ be asynchronous.\r\n    let warnBeforeUnload = isAnyWatchedFormDirty() && !M.cfg.behatsiterunning;\r\n    if (warnBeforeUnload) {\r\n        // According to the specification, to show the confirmation dialog an event handler should call preventDefault()\r\n        // on the event.\r\n        e.preventDefault();\r\n\r\n        // However note that not all browsers support this method, and some instead require the event handler to\r\n        // implement one of two legacy methods:\r\n        // * assigning a string to the event's returnValue property; and\r\n        // * returning a string from the event handler.\r\n\r\n        // Assigning a string to the event's returnValue property.\r\n        e.returnValue = warningString;\r\n\r\n        // Returning a string from the event handler.\r\n        return e.returnValue;\r\n    }\r\n\r\n    // Attaching an event handler/listener to window or document's beforeunload event prevents browsers from using\r\n    // in-memory page navigation caches, like Firefox's Back-Forward cache or WebKit's Page Cache.\r\n    // Remove the handler.\r\n    window.removeEventListener('beforeunload', beforeUnloadHandler);\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Start watching for form changes.\r\n *\r\n * This function is called on module load, and should not normally be called.\r\n *\r\n * @method\r\n * @protected\r\n */\r\nexport const startWatching = () => {\r\n    if (initialised) {\r\n        return;\r\n    }\r\n\r\n    document.addEventListener('change', e => {\r\n        if (!isWatchingForm(e.target)) {\r\n            return;\r\n        }\r\n\r\n        markFormChangedFromNode(e.target);\r\n    });\r\n\r\n    document.addEventListener('click', e => {\r\n        const ignoredButton = e.target.closest('[data-formchangechecker-ignore-submit]');\r\n        if (!ignoredButton) {\r\n            return;\r\n        }\r\n\r\n        const ownerForm = getFormFromChild(e.target);\r\n        if (ownerForm) {\r\n            ownerForm.dataset.ignoreSubmission = \"true\";\r\n        }\r\n    });\r\n\r\n    document.addEventListener('focusin', e => {\r\n        if (e.target.matches('input, textarea, select')) {\r\n            if (e.target.dataset.propertyIsEnumerable('initialValue')) {\r\n                // The initial value has already been set.\r\n                return;\r\n            }\r\n            e.target.dataset.initialValue = e.target.value;\r\n        }\r\n    });\r\n\r\n    document.addEventListener('submit', e => {\r\n        const formNode = getFormFromChild(e.target);\r\n        if (!formNode) {\r\n            // Weird, but watch for this anyway.\r\n            return;\r\n        }\r\n\r\n        if (formNode.dataset.ignoreSubmission) {\r\n            // This form was submitted by a button which requested that the form checked should not mark it as submitted.\r\n            formNode.dataset.ignoreSubmission = \"false\";\r\n            return;\r\n        }\r\n\r\n        markFormSubmitted(formNode);\r\n    });\r\n\r\n    document.addEventListener(eventTypes.editorContentRestored, e => {\r\n        if (e.target != document) {\r\n            resetFormDirtyState(e.target);\r\n        } else {\r\n            resetAllFormDirtyStates();\r\n        }\r\n    });\r\n\r\n    getString('changesmadereallygoaway', 'moodle')\r\n    .then(changesMadeString => {\r\n        warningString = changesMadeString;\r\n        return;\r\n    })\r\n    .catch();\r\n\r\n    window.addEventListener('beforeunload', beforeUnloadHandler);\r\n};\r\n\r\n/**\r\n * Watch the form matching the specified ID for changes.\r\n *\r\n * @method\r\n * @param   {String} formId\r\n */\r\nexport const watchFormById = formId => {\r\n    watchForm(document.getElementById(formId));\r\n};\r\n\r\n/**\r\n * Reset the dirty state of the form matching the specified ID..\r\n *\r\n * @method\r\n * @param   {String} formId\r\n */\r\nexport const resetFormDirtyStateById = formId => {\r\n    resetFormDirtyState(document.getElementById(formId));\r\n};\r\n\r\n/**\r\n * Mark the form matching the specified ID as dirty.\r\n *\r\n * @method\r\n * @param   {String} formId\r\n */\r\nexport const markFormAsDirtyById = formId => {\r\n    markFormAsDirty(document.getElementById(formId));\r\n};\r\n\r\n// Configure all event listeners.\r\nstartWatching();\r\n"],"names":["warningString","watchedForms","formChangeCheckerDisabled","getFormFromChild","formChild","closest","watchForm","formNode","isWatchingForm","push","filter","watchedForm","contains","resetAllFormDirtyStates","forEach","dataset","formSubmitted","formDirty","resetFormDirtyState","markFormAsDirty","disableAllChecks","isAnyWatchedFormDirty","some","isConnected","document","activeElement","propertyIsEnumerable","isActiveElementWatched","shouldIgnoreChangesForNode","hasValueChanged","initialValue","value","window","tinyMCE","editors","editor","isDirty","target","markFormChangedFromNode","changedNode","formChangeCheckerOverride","find","markFormSubmitted","beforeUnloadHandler","e","M","cfg","behatsiterunning","preventDefault","returnValue","removeEventListener","startWatching","addEventListener","ownerForm","ignoreSubmission","matches","eventTypes","editorContentRestored","then","changesMadeString","catch","formId","getElementById"],"mappings":"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"}