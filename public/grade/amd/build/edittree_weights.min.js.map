{"version":3,"file":"edittree_weights.min.js","sources":["../src/edittree_weights.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * This module provides functionality for managing weight calculations and adjustments for grade items.\r\n *\r\n * @module     core_grades/edittree_weight\r\n * @copyright  2023 Shamim Rezaie <shamim@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nimport {getString} from 'core/str';\r\nimport {prefetchStrings} from 'core/prefetch';\r\n\r\n/**\r\n * Selectors.\r\n *\r\n * @type {Object}\r\n */\r\nconst selectors = {\r\n    weightOverrideCheckbox: 'input[type=\"checkbox\"][name^=\"weightoverride_\"]',\r\n    weightOverrideInput: 'input[type=\"text\"][name^=\"weight_\"]',\r\n    aggregationForCategory: category => `[data-aggregationforcategory='${category}']`,\r\n    childrenByCategory: category => `tr[data-parent-category=\"${category}\"]`,\r\n    categoryByIdentifier: identifier => `tr.category[data-category=\"${identifier}\"]`,\r\n};\r\n\r\n/**\r\n * An object representing grading-related constants.\r\n * The same as what's defined in lib/grade/constants.php.\r\n *\r\n * @type {Object}\r\n * @property {Object} aggregation Aggregation settings.\r\n * @property {number} aggregation.sum Aggregation method: sum.\r\n * @property {Object} type Grade type settings.\r\n * @property {number} type.none Grade type: none.\r\n * @property {number} type.value Grade type: value.\r\n * @property {number} type.scale Grade type: scale.\r\n */\r\nconst grade = {\r\n    aggregation: {\r\n        sum: 13,\r\n    },\r\n};\r\n\r\n/**\r\n * The character used as the decimal separator for number formatting.\r\n *\r\n * @type {string}\r\n */\r\nlet decimalSeparator;\r\n\r\n/**\r\n * This setting indicates if we should use algorithm prior to MDL-49257 fix for calculating extra credit weights.\r\n * Even though the old algorithm has bugs in it, we need to preserve existing grades.\r\n *\r\n * @type {boolean}\r\n */\r\nlet oldExtraCreditCalculation;\r\n\r\n/**\r\n * Recalculates the natural weights for grade items within a given category.\r\n *\r\n * @param {HTMLElement} categoryElement The DOM element representing the category.\r\n */\r\n// Suppress 'complexity' linting rule to keep this function as close to grade_category::auto_update_weights.\r\n// eslint-disable-next-line complexity\r\nconst recalculateNaturalWeights = (categoryElement) => {\r\n    const childElements = document.querySelectorAll(selectors.childrenByCategory(categoryElement.dataset.category));\r\n\r\n    // Calculate the sum of the grademax's of all the items within this category.\r\n    let totalGradeMax = 0;\r\n\r\n    // Out of 100, how much weight has been manually overridden by a user?\r\n    let totalOverriddenWeight = 0;\r\n    let totalOverriddenGradeMax = 0;\r\n\r\n    // Has every assessment in this category been overridden?\r\n    let automaticGradeItemsPresent = false;\r\n    // Does the grade item require normalising?\r\n    let requiresNormalising = false;\r\n\r\n    // Is there an error in the weight calculations?\r\n    let erroneous = false;\r\n\r\n    // This array keeps track of the id and weight of every grade item that has been overridden.\r\n    const overrideArray = {};\r\n\r\n    for (const childElement of childElements) {\r\n        const weightInput = childElement.querySelector(selectors.weightOverrideInput);\r\n        const weightCheckbox = childElement.querySelector(selectors.weightOverrideCheckbox);\r\n\r\n        // There are cases where a grade item should be excluded from calculations:\r\n        // - If the item's grade type is 'text' or 'none'.\r\n        // - If the grade item is an outcome item and the settings are set to not aggregate outcome items.\r\n        // - If the item's grade type is 'scale' and the settings are set to ignore scales in aggregations.\r\n        // All these cases are already taken care of in the backend, and no 'weight' input element is rendered on the page\r\n        // if a grade item should not have a weight.\r\n        if (!weightInput) {\r\n            continue;\r\n        }\r\n\r\n        const itemWeight = parseWeight(weightInput.value);\r\n        const itemAggregationCoefficient = parseInt(childElement.dataset.aggregationcoef);\r\n        const itemGradeMax = parseFloat(childElement.dataset.grademax);\r\n\r\n        // Record the ID and the weight for this grade item.\r\n        overrideArray[childElement.dataset.itemid] = {\r\n            extraCredit: itemAggregationCoefficient,\r\n            weight: itemWeight,\r\n            weightOverride: weightCheckbox.checked,\r\n        };\r\n        // If this item has had its weight overridden then set the flag to true, but\r\n        // only if all previous items were also overridden. Note that extra credit items\r\n        // are counted as overridden grade items.\r\n        if (!weightCheckbox.checked && itemAggregationCoefficient === 0) {\r\n            automaticGradeItemsPresent = true;\r\n        }\r\n\r\n        if (itemAggregationCoefficient > 0) {\r\n            // An extra credit grade item doesn't contribute to totalOverriddenGradeMax.\r\n            continue;\r\n        } else if (weightCheckbox.checked && itemWeight <= 0) {\r\n            // An overridden item that defines a weight of 0 does not contribute to totalOverriddenGradeMax.\r\n            continue;\r\n        }\r\n\r\n        totalGradeMax += itemGradeMax;\r\n        if (weightCheckbox.checked) {\r\n            totalOverriddenWeight += itemWeight;\r\n            totalOverriddenGradeMax += itemGradeMax;\r\n        }\r\n    }\r\n\r\n    // Initialise this variable (used to keep track of the weight override total).\r\n    let normaliseTotal = 0;\r\n    // Keep a record of how much the override total is to see if it is above 100. If it is then we need to set the\r\n    // other weights to zero and normalise the others.\r\n    let overriddenTotal = 0;\r\n    // Total up all the weights.\r\n    for (const gradeItemDetail of Object.values(overrideArray)) {\r\n        // Exclude grade items with extra credit or negative weights (which will be set to zero later).\r\n        if (!gradeItemDetail.extraCredit && gradeItemDetail.weight > 0) {\r\n            normaliseTotal += gradeItemDetail.weight;\r\n        }\r\n        // The overridden total includes items that are marked as overridden, not extra credit, and have a positive weight.\r\n        if (gradeItemDetail.weightOverride && !gradeItemDetail.extraCredit && gradeItemDetail.weight > 0) {\r\n            // Add overridden weights up to see if they are greater than 1.\r\n            overriddenTotal += gradeItemDetail.weight;\r\n        }\r\n    }\r\n    if (overriddenTotal > 100) {\r\n        // Make sure that this category of weights gets normalised.\r\n        requiresNormalising = true;\r\n        // The normalised weights are only the overridden weights, so we just use the total of those.\r\n        normaliseTotal = overriddenTotal;\r\n    }\r\n\r\n    const totalNonOverriddenGradeMax = totalGradeMax - totalOverriddenGradeMax;\r\n\r\n    for (const childElement of childElements) {\r\n        const weightInput = childElement.querySelector(selectors.weightOverrideInput);\r\n        const weightCheckbox = childElement.querySelector(selectors.weightOverrideCheckbox);\r\n        const itemAggregationCoefficient = parseInt(childElement.dataset.aggregationcoef);\r\n        const itemGradeMax = parseFloat(childElement.dataset.grademax);\r\n\r\n        if (!weightInput) {\r\n            continue;\r\n        } else if (!oldExtraCreditCalculation && itemAggregationCoefficient > 0 && weightCheckbox.checked) {\r\n            // For an item with extra credit ignore other weights and overrides but do not change anything at all\r\n            // if its weight was already overridden.\r\n            continue;\r\n        }\r\n\r\n        // Remove any error messages and classes.\r\n        weightInput.classList.remove('is-invalid');\r\n        const errorArea = weightInput.closest('td').querySelector('.invalid-feedback');\r\n        errorArea.textContent = '';\r\n\r\n        if (!oldExtraCreditCalculation && itemAggregationCoefficient > 0 && !weightCheckbox.checked) {\r\n            // For an item with extra credit ignore other weights and overrides.\r\n            weightInput.value = totalGradeMax ? formatFloat(itemGradeMax * 100 / totalGradeMax) : 0;\r\n        } else if (!weightCheckbox.checked) {\r\n            // Calculations with a grade maximum of zero will cause problems. Just set the weight to zero.\r\n            if (totalOverriddenWeight >= 100 || totalNonOverriddenGradeMax === 0 || itemGradeMax === 0) {\r\n                // There is no more weight to distribute.\r\n                weightInput.value = formatFloat(0);\r\n            } else {\r\n                // Calculate this item's weight as a percentage of the non-overridden total grade maxes\r\n                // then convert it to a proportion of the available non-overridden weight.\r\n                weightInput.value = formatFloat((itemGradeMax / totalNonOverriddenGradeMax) * (100 - totalOverriddenWeight));\r\n            }\r\n        } else if ((!automaticGradeItemsPresent && normaliseTotal !== 100) || requiresNormalising ||\r\n                overrideArray[childElement.dataset.itemid].weight < 0) {\r\n            if (overrideArray[childElement.dataset.itemid].weight < 0) {\r\n                weightInput.value = formatFloat(0);\r\n            }\r\n\r\n            // Zero is a special case. If the total is zero then we need to set the weight of the parent category to zero.\r\n            if (normaliseTotal !== 0) {\r\n                erroneous = true;\r\n                const error = normaliseTotal > 100 ? 'erroroverweight' : 'errorunderweight';\r\n                // eslint-disable-next-line promise/always-return,promise/catch-or-return\r\n                getString(error, 'core_grades').then((errorString) => {\r\n                    errorArea.textContent = errorString;\r\n                });\r\n                weightInput.classList.add('is-invalid');\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!erroneous) {\r\n        const categoryGradeMax = parseFloat(categoryElement.dataset.grademax);\r\n        if (categoryGradeMax !== totalGradeMax) {\r\n            // The category grade max is not the same as the total grade max, so we need to update the category grade max.\r\n            categoryElement.dataset.grademax = totalGradeMax;\r\n            const relatedCategoryAggregationRow = document.querySelector(\r\n                selectors.aggregationForCategory(categoryElement.dataset.category)\r\n            );\r\n            relatedCategoryAggregationRow.querySelector('.column-range').innerHTML = formatFloat(totalGradeMax, 2, 2);\r\n\r\n            const parentCategory = document.querySelector(selectors.categoryByIdentifier(categoryElement.dataset.parentCategory));\r\n            if (parentCategory && (parseInt(parentCategory.dataset.aggregation) === grade.aggregation.sum)) {\r\n                recalculateNaturalWeights(parentCategory);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Formats a floating-point number as a string with the specified number of decimal places.\r\n * Unnecessary trailing zeros are removed up to the specified minimum number of decimal places.\r\n *\r\n * @param {number} number The float value to be formatted.\r\n * @param {number} [decimalPoints=3] The number of decimal places to use.\r\n * @param {number} [minDecimals=1] The minimum number of decimal places to use.\r\n * @returns {string} The formatted weight value with the specified decimal places.\r\n */\r\nconst formatFloat = (number, decimalPoints = 3, minDecimals = 1) => {\r\n    return number.toFixed(decimalPoints)\r\n        .replace(new RegExp(`0{0,${decimalPoints - minDecimals}}$`), '')\r\n        .replace('.', decimalSeparator);\r\n};\r\n\r\n/**\r\n * Parses a weight string and returns a normalized float value.\r\n *\r\n * @param {string} weightString The weight as a string, possibly with localized formatting.\r\n * @returns {number} The parsed weight as a float. If parsing fails, returns 0.\r\n */\r\nconst parseWeight = (weightString) => {\r\n    const normalizedWeightString = weightString.replace(decimalSeparator, '.');\r\n    return isNaN(Number(normalizedWeightString)) ? 0 : parseFloat(normalizedWeightString || 0);\r\n};\r\n\r\n/**\r\n * Initializes the weight management module with optional configuration.\r\n *\r\n * @param {string} decSep The character used as the decimal separator for number formatting.\r\n * @param {boolean} oldCalculation A flag indicating whether to use the old (pre MDL-49257) extra credit calculation.\r\n */\r\nexport const init = (decSep, oldCalculation) => {\r\n    decimalSeparator = decSep;\r\n    oldExtraCreditCalculation = oldCalculation;\r\n    prefetchStrings('core_grades', ['erroroverweight', 'errorunderweight']);\r\n\r\n    document.addEventListener('change', e => {\r\n        // Update the weights of all grade items in the category when the weight of any grade item in the category is changed.\r\n        if (e.target.matches(selectors.weightOverrideInput) || e.target.matches(selectors.weightOverrideCheckbox)) {\r\n            // The following is named gradeItemRow, but it may also be a row that's representing a grade category.\r\n            // It's ok because it serves as the categories associated grade item in our calculations.\r\n            const gradeItemRow = e.target.closest('tr');\r\n            const categoryElement = document.querySelector(selectors.categoryByIdentifier(gradeItemRow.dataset.parentCategory));\r\n\r\n            // This is only required if we are using natural weights.\r\n            if (parseInt(categoryElement.dataset.aggregation) === grade.aggregation.sum) {\r\n                const weightElement = gradeItemRow.querySelector(selectors.weightOverrideInput);\r\n                weightElement.value = formatFloat(Math.max(0, parseWeight(weightElement.value)));\r\n                recalculateNaturalWeights(categoryElement);\r\n            }\r\n        }\r\n    });\r\n\r\n    document.addEventListener('submit', e => {\r\n        // If the form is being submitted, then we need to ensure that the weight input fields are all set to\r\n        // a valid value.\r\n        if (e.target.matches('#gradetreeform')) {\r\n            const firstInvalidWeightInput = e.target.querySelector('input.is-invalid');\r\n            if (firstInvalidWeightInput) {\r\n                const firstFocusableInvalidWeightInput = e.target.querySelector('input.is-invalid:enabled');\r\n                if (firstFocusableInvalidWeightInput) {\r\n                    firstFocusableInvalidWeightInput.focus();\r\n                } else {\r\n                    firstInvalidWeightInput.scrollIntoView({block: 'center'});\r\n                }\r\n                e.preventDefault();\r\n            }\r\n        }\r\n    });\r\n};\r\n"],"names":["selectors","category","identifier","grade","sum","decimalSeparator","oldExtraCreditCalculation","recalculateNaturalWeights","categoryElement","childElements","document","querySelectorAll","dataset","totalGradeMax","totalOverriddenWeight","totalOverriddenGradeMax","automaticGradeItemsPresent","requiresNormalising","erroneous","overrideArray","childElement","weightInput","querySelector","weightCheckbox","itemWeight","parseWeight","value","itemAggregationCoefficient","parseInt","aggregationcoef","itemGradeMax","parseFloat","grademax","itemid","extraCredit","weight","weightOverride","checked","normaliseTotal","overriddenTotal","gradeItemDetail","Object","values","totalNonOverriddenGradeMax","classList","remove","errorArea","closest","textContent","formatFloat","error","then","errorString","add","innerHTML","parentCategory","aggregation","number","decimalPoints","minDecimals","toFixed","replace","RegExp","weightString","normalizedWeightString","isNaN","Number","decSep","oldCalculation","addEventListener","e","target","matches","gradeItemRow","weightElement","Math","max","firstInvalidWeightInput","firstFocusableInvalidWeightInput","focus","scrollIntoView","block","preventDefault"],"mappings":"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"}