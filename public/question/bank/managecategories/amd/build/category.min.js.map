{"version":3,"file":"category.min.js","sources":["../src/category.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * The category component.\r\n *\r\n * @module     qbank_managecategories/category\r\n * @class      qbank_managecategories/category\r\n */\r\n\r\nimport {BaseComponent, DragDrop} from 'core/reactive';\r\nimport {categorymanager} from 'qbank_managecategories/categorymanager';\r\nimport Templates from 'core/templates';\r\nimport Modal from \"core/modal\";\r\nimport {get_string as getString} from \"core/str\";\r\n\r\nexport default class extends BaseComponent {\r\n\r\n    create(descriptor) {\r\n        this.name = descriptor.element.id;\r\n        this.selectors = {\r\n            CATEGORY_LIST: '.qbank_managecategories-categorylist',\r\n            CATEGORY_ITEM: '.qbank_managecategories-item[data-categoryid]',\r\n            CATEGORY_CONTENTS: '.qbank_managecategories-item > .container',\r\n            EDIT_BUTTON: '[data-action=\"addeditcategory\"]',\r\n            MOVE_BUTTON: '[role=\"menuitem\"][data-actiontype=\"move\"]',\r\n            CONTEXT: '.qbank_managecategories-categorylist[data-contextid]',\r\n            MODAL_CATEGORY_ITEM: '.modal_category_item[data-movingcategoryid]',\r\n            CONTENT_AREA: '.qbank_managecategories-details',\r\n            CATEGORY_ID: id => `#category-${id}`,\r\n            CONTENT_CONTAINER: id => `#category-${id} .qbank_managecategories-childlistcontainer`,\r\n            CHILD_LIST: id => `ul[data-categoryid=\"${id}\"]`,\r\n            PREVIOUS_SIBLING: sortorder => `:scope > [data-sortorder=\"${sortorder}\"]`,\r\n        };\r\n        this.classes = {\r\n            NO_BOTTOM_PADDING: 'pb-0',\r\n            DRAGHANDLE: 'draghandle',\r\n            DROPTARGET: 'qbank_managecategories-droptarget-before',\r\n        };\r\n        this.ids = {\r\n            CATEGORY: id => `category-${id}`,\r\n        };\r\n    }\r\n\r\n    stateReady() {\r\n        this.initDragDrop();\r\n        this.addEventListener(this.getElement(this.selectors.EDIT_BUTTON), 'click', categorymanager.showEditModal);\r\n        const moveButton = this.getElement(this.selectors.MOVE_BUTTON);\r\n        this.addEventListener(moveButton, 'click', this.showMoveModal);\r\n    }\r\n\r\n    destroy() {\r\n        // The draggable element must be unregistered.\r\n        this.deInitDragDrop();\r\n    }\r\n\r\n    /**\r\n     * Remove any existing DragDrop component, and create a new one.\r\n     */\r\n    initDragDrop() {\r\n        this.deInitDragDrop();\r\n        // If the element is currently draggable, register the getDraggableData method.\r\n        if (this.element.classList.contains(this.classes.DRAGHANDLE)) {\r\n            this.getDraggableData = this._getDraggableData;\r\n        }\r\n        this.dragdrop = new DragDrop(this);\r\n    }\r\n\r\n    /**\r\n     * If the DragDrop component is currently registered, unregister it.\r\n     */\r\n    deInitDragDrop() {\r\n        if (this.dragdrop !== undefined) {\r\n            if (this.getDraggableData !== undefined) {\r\n                this.dragdrop.setDraggable(false);\r\n                this.getDraggableData = undefined;\r\n            }\r\n            this.dragdrop.unregister();\r\n            this.dragdrop = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Static method to create a component instance.\r\n     *\r\n     * @param {string} target the DOM main element or its ID\r\n     * @param {object} selectors optional css selector overrides\r\n     * @return {Component}\r\n     */\r\n    static init(target, selectors) {\r\n        return new this({\r\n            element: document.querySelector(target),\r\n            selectors,\r\n            reactive: categorymanager,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Return the category ID from the component's element.\r\n     *\r\n     * This method is referenced as getDraggableData when the component can be dragged.\r\n     *\r\n     * @return {{id: string}}\r\n     * @private\r\n     */\r\n    _getDraggableData() {\r\n        return {\r\n            id: this.getElement().dataset.categoryid\r\n        };\r\n    }\r\n\r\n    validateDropData() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Highlight the top border of the category item.\r\n     *\r\n     * @param {Object} dropData\r\n     */\r\n    showDropZone(dropData) {\r\n        if (this.getElement().closest(this.selectors.CATEGORY_ID(dropData.id))) {\r\n            // Can't drop onto itself or its own child.\r\n            return false;\r\n        }\r\n        this.getElement().classList.add(this.classes.DROPTARGET);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Remove highlighting.\r\n     */\r\n    hideDropZone() {\r\n        this.getElement().classList.remove(this.classes.DROPTARGET);\r\n    }\r\n\r\n    /**\r\n     * Find the new position of the dropped category, and trigger the move.\r\n     *\r\n     * @param {Object} dropData The category being moved.\r\n     * @param {Event} event The drop event.\r\n     */\r\n    drop(dropData, event) {\r\n        const dropTarget = event.target.closest(this.selectors.CATEGORY_ITEM);\r\n\r\n        if (!dropTarget) {\r\n            return;\r\n        }\r\n\r\n        if (dropTarget.closest(this.selectors.CATEGORY_ID(dropData.id))) {\r\n            // Can't drop onto your own child.\r\n            return;\r\n        }\r\n\r\n        const source = document.getElementById(this.ids.CATEGORY(dropData.id));\r\n\r\n        if (!source) {\r\n            return;\r\n        }\r\n\r\n        const targetParentId = dropTarget.dataset.parent;\r\n        const parentList = dropTarget.closest(this.selectors.CATEGORY_LIST);\r\n        let precedingSibling;\r\n\r\n        if (dropTarget === parentList.firstElementChild) {\r\n            // Dropped at the top of the list.\r\n            precedingSibling = null;\r\n        } else {\r\n            precedingSibling = dropTarget.previousElementSibling;\r\n        }\r\n\r\n        // Insert the category after the target category\r\n        categorymanager.moveCategory(dropData.id, targetParentId, precedingSibling?.dataset.categoryid);\r\n    }\r\n\r\n    getWatchers() {\r\n        return [\r\n            // After any update to this category, move it to the new position.\r\n            {watch: `categories[${this.element.dataset.categoryid}]:updated`, handler: this.updatePosition},\r\n            // When the template context is added or updated, re-render the content.\r\n            {watch: `categories[${this.element.dataset.categoryid}].templatecontext:created`, handler: this.rerender},\r\n            {watch: `categories[${this.element.dataset.categoryid}].templatecontext:updated`, handler: this.rerender},\r\n            // When a new category is created, check whether we need to add a child list to this category.\r\n            {watch: `categories:created`, handler: this.checkChildList},\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Re-render the category content.\r\n     *\r\n     * @param {Object} args\r\n     * @param {Element} args.element\r\n     * @return {Promise<Array>}\r\n     */\r\n    async rerender({element}) {\r\n        const {html, js} = await Templates.renderForPromise(\r\n            'qbank_managecategories/category_details',\r\n            element.templatecontext\r\n        );\r\n        return Templates.replaceNodeContents(this.getElement(this.selectors.CONTENT_AREA), html, js);\r\n    }\r\n\r\n    /**\r\n     * Render and append a new child list.\r\n     *\r\n     * @param {Object} context Template context, must include at least categoryid.\r\n     * @return {Promise<Element>}\r\n     */\r\n    async createChildList(context) {\r\n        const {html, js} = await Templates.renderForPromise(\r\n            'qbank_managecategories/childlist',\r\n            context,\r\n        );\r\n        const parentContainer = document.querySelector(this.selectors.CONTENT_CONTAINER(context.categoryid));\r\n        await Templates.appendNodeContents(parentContainer, html, js);\r\n        const childList = document.querySelector(this.selectors.CHILD_LIST(context.categoryid));\r\n        childList.closest(this.selectors.CATEGORY_CONTENTS).classList.add(this.classes.NO_BOTTOM_PADDING);\r\n        return childList;\r\n    }\r\n\r\n    /**\r\n     * Move a category to its new position.\r\n     *\r\n     * A category may change its parent, sortorder and draghandle independently or at the same time. This method will resolve those\r\n     * changes and move the element to the new position. If the parent doesn't already have a child list, one will be created.\r\n     *\r\n     * If the parent has changed, this will also update the state with the new child count of the old and new parents.\r\n     *\r\n     * @param {Object} args\r\n     * @param {Object} args.element\r\n     * @return {Promise<void>}\r\n     */\r\n    async updatePosition({element}) {\r\n        // Move to a new parent category.\r\n        let newParent;\r\n        const originParent = document.querySelector(this.selectors.CHILD_LIST(this.getElement().dataset.parent));\r\n        if (parseInt(this.getElement().dataset.parent) !== element.parent) {\r\n            newParent = document.querySelector(this.selectors.CHILD_LIST(element.parent));\r\n            if (!newParent) {\r\n                // The target category doesn't have a child list yet. We'd better create one.\r\n                newParent = await this.createChildList({categoryid: element.parent});\r\n            }\r\n            this.getElement().dataset.parent = element.parent;\r\n        } else {\r\n            newParent = this.getElement().parentElement;\r\n        }\r\n\r\n        // Move to a new position within the parent.\r\n        let previousSibling;\r\n        let nextSibling;\r\n        if (newParent.firstElementChild && parseInt(element.sortorder) <= parseInt(newParent.firstElementChild.dataset.sortorder)) {\r\n            // Move to the top of the list.\r\n            nextSibling = newParent.firstElementChild;\r\n        } else {\r\n            // Move later in the list.\r\n            previousSibling = newParent.querySelector(this.selectors.PREVIOUS_SIBLING(element.sortorder - 1));\r\n            nextSibling = previousSibling?.nextElementSibling;\r\n        }\r\n\r\n        // Check if this has actually moved, or if it's just having its sortorder updated due to another element moving.\r\n        const moved = (newParent !== this.getElement().parentElement || nextSibling !== this.getElement());\r\n\r\n        if (moved) {\r\n            if (nextSibling) {\r\n                // Move to the specified position in the list.\r\n                newParent.insertBefore(this.getElement(), nextSibling);\r\n            } else {\r\n                // Move to the end of the list (may also be the top of the list is empty).\r\n                newParent.appendChild(this.getElement());\r\n            }\r\n        }\r\n        if (originParent !== newParent) {\r\n            // Update child count of old and new parent.\r\n            this.reactive.stateManager.processUpdates([\r\n                {\r\n                    name: 'categoryLists',\r\n                    action: 'put',\r\n                    fields: {\r\n                        id: originParent.dataset.categoryid,\r\n                        childCount: originParent.querySelectorAll(this.selectors.CATEGORY_ITEM).length\r\n                    }\r\n                },\r\n                {\r\n                    name: 'categoryLists',\r\n                    action: 'put',\r\n                    fields: {\r\n                        id: newParent.dataset.categoryid,\r\n                        childCount: newParent.querySelectorAll(this.selectors.CATEGORY_ITEM).length\r\n                    }\r\n                }\r\n            ]);\r\n        }\r\n\r\n        this.element.dataset.sortorder = element.sortorder;\r\n\r\n        // Enable/disable dragging.\r\n        const isDraggable = this.element.classList.contains(this.classes.DRAGHANDLE);\r\n        if (isDraggable && !element.draghandle) {\r\n            this.element.classList.remove(this.classes.DRAGHANDLE);\r\n            this.initDragDrop();\r\n        } else if (!isDraggable && element.draghandle) {\r\n            this.element.classList.add(this.classes.DRAGHANDLE);\r\n            this.initDragDrop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recursively create a list of all valid destinations for a current category within a parent category.\r\n     *\r\n     * @param {Element} item\r\n     * @param {Number} movingCategoryId\r\n     * @return {Array<Object>}\r\n     */\r\n    createMoveCategoryList(item, movingCategoryId) {\r\n        const categories = [];\r\n        if (item.children) {\r\n            let precedingSibling = null;\r\n            item.children.forEach(category => {\r\n                const categoryId = parseInt(category.dataset.categoryid);\r\n                // Don't create a target for the category that's moving.\r\n                if (categoryId === movingCategoryId) {\r\n                    return;\r\n                }\r\n                // Create a target to move before this child.\r\n                let child = {\r\n                    categoryid: categoryId,\r\n                    movingcategoryid: movingCategoryId,\r\n                    precedingsiblingid: precedingSibling?.dataset.categoryid ?? 0,\r\n                    parent: category.dataset.parent,\r\n                    categoryname: category.dataset.categoryname,\r\n                    categories: null,\r\n                    current: categoryId === movingCategoryId,\r\n                };\r\n                const childList = category.querySelector(this.selectors.CATEGORY_LIST);\r\n                if (childList) {\r\n                    // If the child has its own children, recursively make a list of those.\r\n                    child.categories = this.createMoveCategoryList(childList, movingCategoryId);\r\n                } else {\r\n                    // Otherwise, create a target to move as a new child of this one.\r\n                    child.categories = [\r\n                        {\r\n                            movingcategoryid: movingCategoryId,\r\n                            precedingsiblingid: 0,\r\n                            parent: categoryId,\r\n                            categoryname: category.dataset.categoryname,\r\n                            categories: null,\r\n                            newchild: true,\r\n                        }\r\n                    ];\r\n                }\r\n                categories.push(child);\r\n                precedingSibling = category;\r\n            });\r\n            if (precedingSibling) {\r\n                const precedingId = parseInt(precedingSibling.dataset.categoryid);\r\n                if (precedingId !== movingCategoryId) {\r\n                    // If this is the last child of its parent, also create a target to move the category after this one.\r\n                    categories.push({\r\n                        movingcategoryid: movingCategoryId,\r\n                        precedingsiblingid: precedingId,\r\n                        parent: precedingSibling.dataset.parent,\r\n                        categoryname: precedingSibling.dataset.categoryname,\r\n                        categories: null,\r\n                        lastchild: true,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        return categories;\r\n    }\r\n\r\n    /**\r\n     * Displays a modal containing links to move the category to a new location.\r\n     *\r\n     * @param {Event} e Button click event.\r\n     */\r\n    async showMoveModal(e) {\r\n        // Return if it is not menu item.\r\n        const item = e.target.closest(this.selectors.MOVE_BUTTON);\r\n        if (!item) {\r\n            return;\r\n        }\r\n        // Return if it is disabled.\r\n        if (item.getAttribute('aria-disabled') === 'true') {\r\n            return;\r\n        }\r\n\r\n        // Prevent addition click on the item.\r\n        item.setAttribute('aria-disabled', true);\r\n\r\n        // Build the list of move links.\r\n        let moveList = {contexts: []};\r\n        const contexts = document.querySelectorAll(this.selectors.CONTEXT);\r\n        contexts.forEach(context => {\r\n            const moveContext = {\r\n                contextname: context.dataset.contextname,\r\n                categories: [],\r\n                hascategories: false,\r\n            };\r\n            moveContext.categories = this.createMoveCategoryList(context, parseInt(item.dataset.categoryid));\r\n            moveContext.hascategories = moveContext.categories.length > 0;\r\n            moveList.contexts.push(moveContext);\r\n        });\r\n\r\n        const modal = await Modal.create({\r\n            title: getString('movecategory', 'qbank_managecategories', item.dataset.categoryname),\r\n            body: Templates.render('qbank_managecategories/move_context_list', moveList),\r\n            footer: '',\r\n            show: true,\r\n            large: true,\r\n        });\r\n        // Show modal and add click event for list items.\r\n        modal.getBody()[0].addEventListener('click', e => {\r\n            const target = e.target.closest(this.selectors.MODAL_CATEGORY_ITEM);\r\n            if (!target) {\r\n                return;\r\n            }\r\n            categorymanager.moveCategory(target.dataset.movingcategoryid, target.dataset.parent, target.dataset.precedingsiblingid);\r\n            modal.destroy();\r\n        });\r\n        item.setAttribute('aria-disabled', false);\r\n    }\r\n\r\n    /**\r\n     * Check and add a child list if needed.\r\n     *\r\n     * Check whether the category that has just been added has this category as its parent. If it does,\r\n     * check that this category has a child list, and if not, add one.\r\n     *\r\n     * @param {Object} args\r\n     * @param {Element} args.element The new category.\r\n     * @return {Promise<Element>}\r\n     */\r\n    async checkChildList({element}) {\r\n        if (element.parent !== this.getElement().dataset.categoryid) {\r\n            return null; // Not for me.\r\n        }\r\n        let childList = this.getElement(this.selectors.CATEGORY_LIST);\r\n        if (childList) {\r\n            return null; // List already exists, it will handle adding the new category.\r\n        }\r\n        // Render and add a new child list containing the new category.\r\n        return this.createChildList({\r\n            categoryid: element.parent,\r\n            children: [\r\n                element.templatecontext,\r\n            ]\r\n        });\r\n    }\r\n}\r\n"],"names":["BaseComponent","create","descriptor","name","element","id","selectors","CATEGORY_LIST","CATEGORY_ITEM","CATEGORY_CONTENTS","EDIT_BUTTON","MOVE_BUTTON","CONTEXT","MODAL_CATEGORY_ITEM","CONTENT_AREA","CATEGORY_ID","CONTENT_CONTAINER","CHILD_LIST","PREVIOUS_SIBLING","sortorder","classes","NO_BOTTOM_PADDING","DRAGHANDLE","DROPTARGET","ids","CATEGORY","stateReady","initDragDrop","addEventListener","this","getElement","categorymanager","showEditModal","moveButton","showMoveModal","destroy","deInitDragDrop","classList","contains","getDraggableData","_getDraggableData","dragdrop","DragDrop","undefined","setDraggable","unregister","target","document","querySelector","reactive","dataset","categoryid","validateDropData","showDropZone","dropData","closest","add","hideDropZone","remove","drop","event","dropTarget","getElementById","targetParentId","parent","parentList","precedingSibling","firstElementChild","previousElementSibling","moveCategory","_precedingSibling","getWatchers","watch","handler","updatePosition","rerender","checkChildList","html","js","Templates","renderForPromise","templatecontext","replaceNodeContents","context","parentContainer","appendNodeContents","childList","newParent","originParent","previousSibling","nextSibling","parseInt","createChildList","parentElement","_previousSibling","nextElementSibling","insertBefore","appendChild","stateManager","processUpdates","action","fields","childCount","querySelectorAll","length","isDraggable","draghandle","createMoveCategoryList","item","movingCategoryId","categories","children","forEach","category","categoryId","child","movingcategoryid","precedingsiblingid","_precedingSibling2","categoryname","current","newchild","push","precedingId","lastchild","e","getAttribute","setAttribute","moveList","contexts","moveContext","contextname","hascategories","modal","Modal","title","body","render","footer","show","large","getBody"],"mappings":"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"}