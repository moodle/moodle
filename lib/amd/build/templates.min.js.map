{"version":3,"file":"templates.min.js","sources":["../src/templates.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Template renderer for Moodle. Load and render Moodle templates with Mustache.\n *\n * @module     core/templates\n * @copyright  2015 Damyon Wiese <damyon@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @since      2.9\n */\nimport mustache from 'core/mustache';\nimport $ from 'jquery';\nimport * as ajax from 'core/ajax';\nimport * as str from 'core/str';\nimport * as notification from 'core/notification';\nimport * as config from 'core/config';\nimport * as storage from 'core/localstorage';\nimport IconSystem from 'core/icon_system';\nimport * as filterEvents from 'core_filters/events';\nimport * as Y from 'core/yui';\nimport * as Log from 'core/log';\nimport * as Truncate from 'core/truncate';\nimport * as UserDate from 'core/user_date';\nimport Pending from 'core/pending';\n\n\n// Module variables.\n/** @var {Number} uniqInstances Count of times this constructor has been called. */\nvar uniqInstances = 0;\n\n/** @var {String[]} templateCache - Cache of already loaded template strings */\nvar templateCache = {};\n\n/** @var {Promise[]} templatePromises - Cache of already loaded template promises */\nvar templatePromises = {};\n\n/** @var {Promise[]} cachePartialPromises - Cache of already loaded template partial promises */\nvar cachePartialPromises = {};\n\n/** @var {Object} iconSystem - Object extending core/iconsystem */\nvar iconSystem = {};\n\n/** @var {Object[]} loadTemplateBuffer - List of templates to be loaded */\nvar loadTemplateBuffer = [];\n\n/** @var {Bool} isLoadingTemplates - Whether templates are currently being loaded */\nvar isLoadingTemplates = false;\n\n/** @var {Array} disallowedNestedHelpers - List of helpers that can't be called within other helpers */\nvar disallowedNestedHelpers = ['js'];\n\n/**\n * Normalise the provided component such that '', 'moodle', and 'core' are treated consistently.\n *\n * @param   {String} component\n * @returns {String}\n */\nvar getNormalisedComponent = function (component) {\n    if (component) {\n        if (component !== 'moodle' && component !== 'core') {\n            return component;\n        }\n    }\n\n    return 'core';\n};\n\n/**\n * Search the various caches for a template promise for the given search key.\n * The search key should be in the format <theme>/<component>/<template> e.g. boost/core/modal.\n *\n * If the template is found in any of the caches it will populate the other caches with\n * the same data as well.\n *\n * @param {String} searchKey The template search key in the format <theme>/<component>/<template> e.g. boost/core/modal\n * @return {Object} jQuery promise resolved with the template source\n */\nvar getTemplatePromiseFromCache = function (searchKey) {\n    // First try the cache of promises.\n    if (searchKey in templatePromises) {\n        return templatePromises[searchKey];\n    }\n\n    // Check the module cache.\n    if (searchKey in templateCache) {\n        // Add this to the promises cache for future.\n        templatePromises[searchKey] = $.Deferred().resolve(templateCache[searchKey]).promise();\n        return templatePromises[searchKey];\n    }\n\n    if (M.cfg.templaterev <= 0) {\n        // Template caching is disabled. Do not store in persistent storage.\n        return null;\n    }\n\n    // Now try local storage.\n    var cached = storage.get('core_template/' + M.cfg.templaterev + ':' + searchKey);\n    if (cached) {\n        // Add this to the module cache for future.\n        templateCache[searchKey] = cached;\n        // Add this to the promises cache for future.\n        templatePromises[searchKey] = $.Deferred().resolve(cached).promise();\n        return templatePromises[searchKey];\n    }\n\n    return null;\n};\n\n/**\n * Take all of the templates waiting in the buffer and load them from the server\n * or from the cache.\n *\n * All of the templates that need to be loaded from the server will be batched up\n * and sent in a single network request.\n */\nvar processLoadTemplateBuffer = function () {\n    if (!loadTemplateBuffer.length) {\n        return;\n    }\n\n    if (isLoadingTemplates) {\n        return;\n    }\n\n    isLoadingTemplates = true;\n    // Grab any templates waiting in the buffer.\n    var templatesToLoad = loadTemplateBuffer.slice();\n    // This will be resolved with the list of promises for the server request.\n    var serverRequestsDeferred = $.Deferred();\n    var requests = [];\n    // Get a list of promises for each of the templates we need to load.\n    var templatePromises = templatesToLoad.map(function (templateData) {\n        var component = getNormalisedComponent(templateData.component);\n        var name = templateData.name;\n        var searchKey = templateData.searchKey;\n        var theme = templateData.theme;\n        var templateDeferred = templateData.deferred;\n        var promise = null;\n\n        // Double check to see if this template happened to have landed in the\n        // cache as a dependency of an earlier template.\n        var cachedPromise = getTemplatePromiseFromCache(searchKey);\n        if (cachedPromise) {\n            // We've seen this template so immediately resolve the existing promise.\n            promise = cachedPromise;\n        } else {\n            // We haven't seen this template yet so we need to request it from\n            // the server.\n            requests.push({\n                methodname: 'core_output_load_template_with_dependencies',\n                args: {\n                    component: component,\n                    template: name,\n                    themename: theme,\n                    lang: $('html').attr('lang').replace(/-/g, '_')\n                }\n            });\n            // Remember the index in the requests list for this template so that\n            // we can get the appropriate promise back.\n            var index = requests.length - 1;\n\n            // The server deferred will be resolved with a list of all of the promises\n            // that were sent in the order that they were added to the requests array.\n            promise = serverRequestsDeferred.promise()\n                .then(function (promises) {\n                    // The promise for this template will be the one that matches the index\n                    // for it's entry in the requests array.\n                    //\n                    // Make sure the promise is added to the promises cache for this template\n                    // search key so that we don't request it again.\n                    templatePromises[searchKey] = promises[index].then(function (response) {\n                        var templateSource = null;\n\n                        // Process all of the template dependencies for this template and add\n                        // them to the caches so that we don't request them again later.\n                        response.templates.forEach(function (data) {\n                            data.component = getNormalisedComponent(data.component);\n                            // Generate the search key for this template in the response so that we\n                            // can add it to the caches.\n                            var tempSearchKey = [theme, data.component, data.name].join('/');\n                            // Cache all of the dependent templates because we'll need them to render\n                            // the requested template.\n                            templateCache[tempSearchKey] = data.value;\n\n                            if (M.cfg.templaterev > 0) {\n                                // The template cache is enabled - set the value there.\n                                storage.set('core_template/' + M.cfg.templaterev + ':' + tempSearchKey, data.value);\n                            }\n\n                            if (data.component == component && data.name == name) {\n                                // This is the original template that was requested so remember it to return.\n                                templateSource = data.value;\n                            }\n                        });\n\n                        if (response.strings.length) {\n                            // If we have strings that the template needs then warm the string cache\n                            // with them now so that we don't need to re-fetch them.\n                            str.cache_strings(response.strings.map(function (data) {\n                                return {\n                                    component: getNormalisedComponent(data.component),\n                                    key: data.name,\n                                    value: data.value\n                                };\n                            }));\n                        }\n\n                        // Return the original template source that the user requested.\n                        return templateSource;\n                    });\n\n                    return templatePromises[searchKey];\n                });\n        }\n\n        return promise\n            .then(function (source) {\n                // When we've successfully loaded the template then resolve the deferred\n                // in the buffer so that all of the calling code can proceed.\n                return templateDeferred.resolve(source);\n            })\n            .catch(function (error) {\n                // If there was an error loading the template then reject the deferred\n                // in the buffer so that all of the calling code can proceed.\n                templateDeferred.reject(error);\n                // Rethrow for anyone else listening.\n                throw error;\n            });\n    });\n\n    if (requests.length) {\n        // We have requests to send so resolve the deferred with the promises.\n        serverRequestsDeferred.resolve(ajax.call(requests, true, false, false, 0, M.cfg.templaterev));\n    } else {\n        // Nothing to load so we can resolve our deferred.\n        serverRequestsDeferred.resolve();\n    }\n\n    // Once we've finished loading all of the templates then recurse to process\n    // any templates that may have been added to the buffer in the time that we\n    // were fetching.\n    $.when.apply(null, templatePromises)\n        .then(function () {\n            // Remove the templates we've loaded from the buffer.\n            loadTemplateBuffer.splice(0, templatesToLoad.length);\n            isLoadingTemplates = false;\n            processLoadTemplateBuffer();\n            return;\n        })\n        .catch(function () {\n            // Remove the templates we've loaded from the buffer.\n            loadTemplateBuffer.splice(0, templatesToLoad.length);\n            isLoadingTemplates = false;\n            processLoadTemplateBuffer();\n        });\n};\n\n/**\n * Constructor\n *\n * Each call to templates.render gets it's own instance of this class.\n */\nvar Renderer = function () {\n    this.requiredStrings = [];\n    this.requiredJS = [];\n    this.requiredDates = [];\n    this.currentThemeName = '';\n};\n// Class variables and functions.\n\n/** @var {string[]} requiredStrings - Collection of strings found during the rendering of one template */\nRenderer.prototype.requiredStrings = null;\n\n/** @var {object[]} requiredDates - Collection of dates found during the rendering of one template */\nRenderer.prototype.requiredDates = [];\n\n/** @var {string[]} requiredJS - Collection of js blocks found during the rendering of one template */\nRenderer.prototype.requiredJS = null;\n\n/** @var {String} themeName for the current render */\nRenderer.prototype.currentThemeName = '';\n\n/**\n * Load a template.\n *\n * @method getTemplate\n * @private\n * @param {string} templateName - should consist of the component and the name of the template like this:\n *                              core/menu (lib/templates/menu.mustache) or\n *                              tool_bananas/yellow (admin/tool/bananas/templates/yellow.mustache)\n * @return {Promise} JQuery promise object resolved when the template has been fetched.\n */\nRenderer.prototype.getTemplate = function (templateName) {\n    var currentTheme = this.currentThemeName;\n    var searchKey = currentTheme + '/' + templateName;\n\n    // If we haven't already seen this template then buffer it.\n    var cachedPromise = getTemplatePromiseFromCache(searchKey);\n    if (cachedPromise) {\n        return cachedPromise;\n    }\n\n    // Check the buffer to see if this template has already been added.\n    var existingBufferRecords = loadTemplateBuffer.filter(function (record) {\n        return record.searchKey == searchKey;\n    });\n    if (existingBufferRecords.length) {\n        // This template is already in the buffer so just return the existing\n        // promise. No need to add it to the buffer again.\n        return existingBufferRecords[0].deferred.promise();\n    }\n\n    // This is the first time this has been requested so let's add it to the buffer\n    // to be loaded.\n    var parts = templateName.split('/');\n    var component = getNormalisedComponent(parts.shift());\n    var name = parts.join('/');\n    var deferred = $.Deferred();\n\n    // Add this template to the buffer to be loaded.\n    loadTemplateBuffer.push({\n        component: component,\n        name: name,\n        theme: currentTheme,\n        searchKey: searchKey,\n        deferred: deferred\n    });\n\n    // We know there is at least one thing in the buffer so kick off a processing run.\n    processLoadTemplateBuffer();\n    return deferred.promise();\n};\n\n/**\n * Prefetch a set of templates without rendering them.\n *\n * @param {Array} templateNames The list of templates to fetch\n * @param {String} currentTheme\n */\nRenderer.prototype.prefetchTemplates = function (templateNames, currentTheme) {\n    templateNames.forEach(function (templateName) {\n        var searchKey = currentTheme + '/' + templateName;\n\n        // If we haven't already seen this template then buffer it.\n        if (getTemplatePromiseFromCache(searchKey)) {\n            return;\n        }\n\n        // Check the buffer to see if this template has already been added.\n        var existingBufferRecords = loadTemplateBuffer.filter(function (record) {\n            return record.searchKey == searchKey;\n        });\n\n        if (existingBufferRecords.length) {\n            // This template is already in the buffer so just return the existing promise.\n            // No need to add it to the buffer again.\n            return;\n        }\n\n        // This is the first time this has been requested so let's add it to the buffer to be loaded.\n        var parts = templateName.split('/');\n        var component = getNormalisedComponent(parts.shift());\n        var name = parts.join('/');\n\n        // Add this template to the buffer to be loaded.\n        loadTemplateBuffer.push({\n            component: component,\n            name: name,\n            theme: currentTheme,\n            searchKey: searchKey,\n            deferred: $.Deferred(),\n        });\n    });\n\n    processLoadTemplateBuffer();\n};\n\n/**\n * Load a partial from the cache or ajax.\n *\n * @method partialHelper\n * @private\n * @param {string} name The partial name to load.\n * @return {string}\n */\nRenderer.prototype.partialHelper = function (name) {\n\n    var searchKey = this.currentThemeName + '/' + name;\n\n    if (!(searchKey in templateCache)) {\n        notification.exception(new Error('Failed to pre-fetch the template: ' + name));\n    }\n\n    return templateCache[searchKey];\n};\n\n/**\n * Render a single image icon.\n *\n * @method renderIcon\n * @private\n * @param {string} key The icon key.\n * @param {string} component The component name.\n * @param {string} title The icon title\n * @return {Promise}\n */\nRenderer.prototype.renderIcon = function (key, component, title) {\n    // Preload the module to do the icon rendering based on the theme iconsystem.\n    var modulename = config.iconsystemmodule;\n    component = getNormalisedComponent(component);\n\n    // RequireJS does not return a promise.\n    var ready = $.Deferred();\n    require([modulename], function (System) {\n        var system = new System();\n        if (!(system instanceof IconSystem)) {\n            ready.reject('Invalid icon system specified' + config.iconsystemmodule);\n        } else {\n            iconSystem = system;\n            system.init().then(ready.resolve).catch(notification.exception);\n        }\n    });\n\n    return ready.then(function (iconSystem) {\n        return this.getTemplate(iconSystem.getTemplateName());\n    }.bind(this)).then(function (template) {\n        return iconSystem.renderIcon(\n            key,\n            component,\n            title,\n            template\n        );\n    });\n};\n\n/**\n * Render image icons.\n *\n * @method pixHelper\n * @private\n * @param {object} context The mustache context\n * @param {string} sectionText The text to parse arguments from.\n * @param {function} helper Used to render the alt attribute of the text.\n * @return {string}\n */\nRenderer.prototype.pixHelper = function (context, sectionText, helper) {\n    var parts = sectionText.split(',');\n    var key = '';\n    var component = '';\n    var text = '';\n\n    if (parts.length > 0) {\n        key = helper(parts.shift().trim(), context);\n    }\n    if (parts.length > 0) {\n        component = helper(parts.shift().trim(), context);\n    }\n    if (parts.length > 0) {\n        text = helper(parts.join(',').trim(), context);\n    }\n\n    var templateName = iconSystem.getTemplateName();\n    var searchKey = this.currentThemeName + '/' + templateName;\n    var template = templateCache[searchKey];\n\n    component = getNormalisedComponent(component);\n\n    // The key might have been escaped by the JS Mustache engine which\n    // converts forward slashes to HTML entities. Let us undo that here.\n    key = key.replace(/&#x2F;/gi, '/');\n\n    return iconSystem.renderIcon(\n        key,\n        component,\n        text,\n        template\n    );\n};\n\n/**\n * Render blocks of javascript and save them in an array.\n *\n * @method jsHelper\n * @private\n * @param {object} context The current mustache context.\n * @param {string} sectionText The text to save as a js block.\n * @param {function} helper Used to render the block.\n * @return {string}\n */\nRenderer.prototype.jsHelper = function (context, sectionText, helper) {\n    this.requiredJS.push(helper(sectionText, context));\n    return '';\n};\n\n/**\n * String helper used to render {{#str}}abd component { a : 'fish'}{{/str}}\n * into a get_string call.\n *\n * @method stringHelper\n * @private\n * @param {object} context The current mustache context.\n * @param {string} sectionText The text to parse the arguments from.\n * @param {function} helper Used to render subsections of the text.\n * @return {string}\n */\nRenderer.prototype.stringHelper = function (context, sectionText, helper) {\n    var parts = sectionText.split(',');\n    var key = '';\n    var component = '';\n    var param = '';\n    if (parts.length > 0) {\n        key = parts.shift().trim();\n    }\n    if (parts.length > 0) {\n        component = parts.shift().trim();\n    }\n    if (parts.length > 0) {\n        param = parts.join(',').trim();\n    }\n\n    component = getNormalisedComponent(component);\n\n    if (param !== '') {\n        // Allow variable expansion in the param part only.\n        param = helper(param, context);\n    }\n\n    if (param.match(/^{\\s*\"/gm)) {\n        // If it can't be parsed then the string is not a JSON format.\n        try {\n            const parsedParam = JSON.parse(param);\n            // Handle non-exception-throwing cases, e.g. null, integer, boolean.\n            if (parsedParam && typeof parsedParam === \"object\") {\n                param = parsedParam;\n            }\n        } catch (err) {\n            // This was probably not JSON.\n            // Keep the error message visible.\n            window.console.warn(err.message);\n        }\n    }\n\n    var index = this.requiredStrings.length;\n    this.requiredStrings.push({\n        key: key,\n        component: component,\n        param: param\n    });\n\n    // The placeholder must not use {{}} as those can be misinterpreted by the engine.\n    return '[[_s' + index + ']]';\n};\n\n/**\n * String helper to render {{#cleanstr}}abd component { a : 'fish'}{{/cleanstr}}\n * into a get_string following by an HTML escape.\n *\n * @method cleanStringHelper\n * @private\n * @param {object} context The current mustache context.\n * @param {string} sectionText The text to parse the arguments from.\n * @param {function} helper Used to render subsections of the text.\n * @return {string}\n */\nRenderer.prototype.cleanStringHelper = function (context, sectionText, helper) {\n    var str = this.stringHelper(context, sectionText, helper);\n\n    // We're going to use [[_cx]] format for clean strings, where x is a number.\n    // Hence, replacing 's' with 'c' in the placeholder that stringHelper returns.\n    return str.replace('s', 'c');\n};\n\n/**\n * Quote helper used to wrap content in quotes, and escape all special JSON characters present in the content.\n *\n * @method quoteHelper\n * @private\n * @param {object} context The current mustache context.\n * @param {string} sectionText The text to parse the arguments from.\n * @param {function} helper Used to render subsections of the text.\n * @return {string}\n */\nRenderer.prototype.quoteHelper = function (context, sectionText, helper) {\n    var content = helper(sectionText.trim(), context);\n\n    // Escape the {{ and JSON encode.\n    // This involves wrapping {{, and }} in change delimeter tags.\n    content = JSON.stringify(content);\n    content = content.replace(/([{}]{2,3})/g, '{{=<% %>=}}$1<%={{ }}=%>');\n    return content;\n};\n\n/**\n * Shorten text helper to truncate text and append a trailing ellipsis.\n *\n * @method shortenTextHelper\n * @private\n * @param {object} context The current mustache context.\n * @param {string} sectionText The text to parse the arguments from.\n * @param {function} helper Used to render subsections of the text.\n * @return {string}\n */\nRenderer.prototype.shortenTextHelper = function (context, sectionText, helper) {\n    // Non-greedy split on comma to grab section text into the length and\n    // text parts.\n    var regex = /(.*?),(.*)/;\n    var parts = sectionText.match(regex);\n    // The length is the part matched in the first set of parethesis.\n    var length = parts[1].trim();\n    // The length is the part matched in the second set of parethesis.\n    var text = parts[2].trim();\n    var content = helper(text, context);\n    return Truncate.truncate(content, {\n        length: length,\n        words: true,\n        ellipsis: '...'\n    });\n};\n\n/**\n * User date helper to render user dates from timestamps.\n *\n * @method userDateHelper\n * @private\n * @param {object} context The current mustache context.\n * @param {string} sectionText The text to parse the arguments from.\n * @param {function} helper Used to render subsections of the text.\n * @return {string}\n */\nRenderer.prototype.userDateHelper = function (context, sectionText, helper) {\n    // Non-greedy split on comma to grab the timestamp and format.\n    var regex = /(.*?),(.*)/;\n    var parts = sectionText.match(regex);\n    var timestamp = helper(parts[1].trim(), context);\n    var format = helper(parts[2].trim(), context);\n    var index = this.requiredDates.length;\n\n    this.requiredDates.push({\n        timestamp: timestamp,\n        format: format\n    });\n\n    return '[[_t_' + index + ']]';\n};\n\n/**\n * Return a helper function to be added to the context for rendering the a\n * template.\n *\n * This will parse the provided text before giving it to the helper function\n * in order to remove any disallowed nested helpers to prevent one helper\n * from calling another.\n *\n * In particular to prevent the JS helper from being called from within another\n * helper because it can lead to security issues when the JS portion is user\n * provided.\n *\n * @param  {function} helperFunction The helper function to add\n * @param  {object} context The template context for the helper function\n * @return {Function} To be set in the context\n */\nRenderer.prototype.addHelperFunction = function (helperFunction, context) {\n    return function () {\n        return function (sectionText, helper) {\n            // Override the disallowed helpers in the template context with\n            // a function that returns an empty string for use when executing\n            // other helpers. This is to prevent these helpers from being\n            // executed as part of the rendering of another helper in order to\n            // prevent any potential security issues.\n            var originalHelpers = disallowedNestedHelpers.reduce(function (carry, name) {\n                if (context.hasOwnProperty(name)) {\n                    carry[name] = context[name];\n                }\n\n                return carry;\n            }, {});\n\n            disallowedNestedHelpers.forEach(function (helperName) {\n                context[helperName] = function () {\n                    return '';\n                };\n            });\n\n            // Execute the helper with the modified context that doesn't include\n            // the disallowed nested helpers. This prevents the disallowed\n            // helpers from being called from within other helpers.\n            var result = helperFunction.apply(this, [context, sectionText, helper]);\n\n            // Restore the original helper implementation in the context so that\n            // any further rendering has access to them again.\n            for (var name in originalHelpers) {\n                context[name] = originalHelpers[name];\n            }\n\n            return result;\n        }.bind(this);\n    }.bind(this);\n};\n\n/**\n * Add some common helper functions to all context objects passed to templates.\n * These helpers match exactly the helpers available in php.\n *\n * @method addHelpers\n * @private\n * @param {Object} context Simple types used as the context for the template.\n * @param {String} themeName We set this multiple times, because there are async calls.\n */\nRenderer.prototype.addHelpers = function (context, themeName) {\n    this.currentThemeName = themeName;\n    this.requiredStrings = [];\n    this.requiredJS = [];\n    context.uniqid = (uniqInstances++);\n    context.str = this.addHelperFunction(this.stringHelper, context);\n    context.cleanstr = this.addHelperFunction(this.cleanStringHelper, context);\n    context.pix = this.addHelperFunction(this.pixHelper, context);\n    context.js = this.addHelperFunction(this.jsHelper, context);\n    context.quote = this.addHelperFunction(this.quoteHelper, context);\n    context.shortentext = this.addHelperFunction(this.shortenTextHelper, context);\n    context.userdate = this.addHelperFunction(this.userDateHelper, context);\n    context.globals = {config: config};\n    context.currentTheme = themeName;\n};\n\n/**\n * Get all the JS blocks from the last rendered template.\n *\n * @method getJS\n * @private\n * @return {string}\n */\nRenderer.prototype.getJS = function () {\n    var js = '';\n    if (this.requiredJS.length > 0) {\n        js = this.requiredJS.join(\";\\n\");\n    }\n\n    return js;\n};\n\n/**\n * Treat strings in content.\n *\n * The purpose of this method is to replace the placeholders found in a string\n * with the their respective translated strings.\n *\n * Previously we were relying on String.replace() but the complexity increased with\n * the numbers of strings to replace. Now we manually walk the string and stop at each\n * placeholder we find, only then we replace it. Most of the time we will\n * replace all the placeholders in a single run, at times we will need a few\n * more runs when placeholders are replaced with strings that contain placeholders\n * themselves.\n *\n * @param {String} content The content in which string placeholders are to be found.\n * @param {Array} strings The strings to replace with.\n * @return {String} The treated content.\n */\nRenderer.prototype.treatStringsInContent = function (content, strings) {\n    var pattern = /\\[\\[_(s|c)\\d+\\]\\]/,\n        treated,\n        index,\n        strIndex,\n        walker,\n        char,\n        strFinal,\n        isClean;\n\n    do {\n        treated = '';\n        index = content.search(pattern);\n        while (index > -1) {\n\n            // Copy the part prior to the placeholder to the treated string.\n            treated += content.substring(0, index);\n            content = content.substr(index);\n            isClean = content[3] == 'c';\n            strIndex = '';\n            walker = 4; // 4 is the length of either '[[_s' or '[[_c'.\n\n            // Walk the characters to manually extract the index of the string from the placeholder.\n            char = content.substr(walker, 1);\n            do {\n                strIndex += char;\n                walker++;\n                char = content.substr(walker, 1);\n            } while (char != ']');\n\n            // Get the string, add it to the treated result, and remove the placeholder from the content to treat.\n            strFinal = strings[parseInt(strIndex, 10)];\n            if (typeof strFinal === 'undefined') {\n                Log.debug('Could not find string for pattern [[_' + (isClean ? 'c' : 's') + strIndex + ']].');\n                strFinal = '';\n            }\n            if (isClean) {\n                strFinal = mustache.escape(strFinal);\n            }\n            treated += strFinal;\n            content = content.substr(6 + strIndex.length); // 6 is the length of the placeholder without the index.\n                                                            // That's either '[[_s]]' or '[[_c]]'.\n\n            // Find the next placeholder.\n            index = content.search(pattern);\n        }\n\n        // The content becomes the treated part with the rest of the content.\n        content = treated + content;\n\n        // Check if we need to walk the content again, in case strings contained placeholders.\n        index = content.search(pattern);\n\n    } while (index > -1);\n\n    return content;\n};\n\n/**\n * Treat strings in content.\n *\n * The purpose of this method is to replace the date placeholders found in the\n * content with the their respective translated dates.\n *\n * @param {String} content The content in which string placeholders are to be found.\n * @param {Array} dates The dates to replace with.\n * @return {String} The treated content.\n */\nRenderer.prototype.treatDatesInContent = function (content, dates) {\n    dates.forEach(function (date, index) {\n        var key = '\\\\[\\\\[_t_' + index + '\\\\]\\\\]';\n        var re = new RegExp(key, 'g');\n        content = content.replace(re, date);\n    });\n\n    return content;\n};\n\n/**\n * Render a template and then call the callback with the result.\n *\n * @method doRender\n * @private\n * @param {string} templateSource The mustache template to render.\n * @param {Object} context Simple types used as the context for the template.\n * @param {String} themeName Name of the current theme.\n * @return {Promise} object\n */\nRenderer.prototype.doRender = function (templateSource, context, themeName) {\n    this.currentThemeName = themeName;\n    var iconTemplate = iconSystem.getTemplateName();\n\n    var pendingPromise = new Pending('core/templates:doRender');\n    return this.getTemplate(iconTemplate).then(function () {\n        this.addHelpers(context, themeName);\n        var result = mustache.render(templateSource, context, this.partialHelper.bind(this));\n        return $.Deferred().resolve(result.trim(), this.getJS()).promise();\n    }.bind(this))\n    .then(function (html, js) {\n        if (this.requiredStrings.length > 0) {\n            return str.get_strings(this.requiredStrings).then(function (strings) {\n\n                // Make sure string substitutions are done for the userdate\n                // values as well.\n                this.requiredDates = this.requiredDates.map(function (date) {\n                    return {\n                        timestamp: this.treatStringsInContent(date.timestamp, strings),\n                        format: this.treatStringsInContent(date.format, strings)\n                    };\n                }.bind(this));\n\n                // Why do we not do another call the render here?\n                //\n                // Because that would expose DOS holes. E.g.\n                // I create an assignment called \"{{fish\" which\n                // would get inserted in the template in the first pass\n                // and cause the template to die on the second pass (unbalanced).\n                html = this.treatStringsInContent(html, strings);\n                js = this.treatStringsInContent(js, strings);\n                return $.Deferred().resolve(html, js).promise();\n            }.bind(this));\n        }\n\n        return $.Deferred().resolve(html, js).promise();\n    }.bind(this))\n    .then(function (html, js) {\n        // This has to happen after the strings replacement because you can\n        // use the string helper in content for the user date helper.\n        if (this.requiredDates.length > 0) {\n            return UserDate.get(this.requiredDates).then(function (dates) {\n                html = this.treatDatesInContent(html, dates);\n                js = this.treatDatesInContent(js, dates);\n                return $.Deferred().resolve(html, js).promise();\n            }.bind(this));\n        }\n\n        return $.Deferred().resolve(html, js).promise();\n    }.bind(this))\n    .then(function (html, js) {\n        pendingPromise.resolve();\n        return $.Deferred().resolve(html, js).promise();\n    });\n};\n\n/**\n * Execute a block of JS returned from a template.\n * Call this AFTER adding the template HTML into the DOM so the nodes can be found.\n *\n * @method runTemplateJS\n * @param {string} source - A block of javascript.\n */\nvar runTemplateJS = function (source) {\n    if (source.trim() !== '') {\n        var newscript = $('<script>').attr('type', 'text/javascript').html(source);\n        $('head').append(newscript);\n    }\n};\n\n/**\n * Do some DOM replacement and trigger correct events and fire javascript.\n *\n * @method domReplace\n * @private\n * @param {JQuery} element - Element or selector to replace.\n * @param {String} newHTML - HTML to insert / replace.\n * @param {String} newJS - Javascript to run after the insertion.\n * @param {Boolean} replaceChildNodes - Replace only the childnodes, alternative is to replace the entire node.\n * @return {Array} The list of new DOM Nodes\n * @fires event:filterContentUpdated\n */\nvar domReplace = function (element, newHTML, newJS, replaceChildNodes) {\n    var replaceNode = $(element);\n    if (replaceNode.length) {\n        // First create the dom nodes so we have a reference to them.\n        var newNodes = $(newHTML);\n        var yuiNodes = null;\n        // Do the replacement in the page.\n        if (replaceChildNodes) {\n            // Cleanup any YUI event listeners attached to any of these nodes.\n            yuiNodes = new Y.NodeList(replaceNode.children().get());\n            yuiNodes.destroy(true);\n\n            // JQuery will cleanup after itself.\n            replaceNode.empty();\n            replaceNode.append(newNodes);\n        } else {\n            // Cleanup any YUI event listeners attached to any of these nodes.\n            yuiNodes = new Y.NodeList(replaceNode.get());\n            yuiNodes.destroy(true);\n\n            // JQuery will cleanup after itself.\n            replaceNode.replaceWith(newNodes);\n        }\n        // Run any javascript associated with the new HTML.\n        runTemplateJS(newJS);\n        // Notify all filters about the new content.\n        filterEvents.notifyFilterContentUpdated(newNodes);\n\n        return newNodes.get();\n    }\n\n    return [];\n};\n\n/**\n * Scan a template source for partial tags and return a list of the found partials.\n *\n * @method scanForPartials\n * @private\n * @param {string} templateSource - source template to scan.\n * @return {Array} List of partials.\n */\nRenderer.prototype.scanForPartials = function (templateSource) {\n    var tokens = mustache.parse(templateSource),\n        partials = [];\n\n    var findPartial = function (tokens, partials) {\n        var i, token;\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i];\n            if (token[0] == '>' || token[0] == '<') {\n                partials.push(token[1]);\n            }\n            if (token.length > 4) {\n                findPartial(token[4], partials);\n            }\n        }\n    };\n\n    findPartial(tokens, partials);\n\n    return partials;\n};\n\n/**\n * Load a template and scan it for partials. Recursively fetch the partials.\n *\n * @method cachePartials\n * @private\n * @param {string} templateName - should consist of the component and the name of the template like this:\n *                              core/menu (lib/templates/menu.mustache) or\n *                              tool_bananas/yellow (admin/tool/bananas/templates/yellow.mustache)\n * @param {Array} parentage - A list of requested partials in this render chain.\n * @return {Promise} JQuery promise object resolved when all partials are in the cache.\n */\nRenderer.prototype.cachePartials = function (templateName, parentage) {\n    var searchKey = this.currentThemeName + '/' + templateName;\n\n    if (searchKey in cachePartialPromises) {\n        return cachePartialPromises[searchKey];\n    }\n\n    // This promise will not be resolved until all child partials are also resolved and ready.\n    // We create it here to allow us to check for recursive inclusion of templates.\n    // Keep track of the requested partials in this chain.\n    parentage = parentage || [searchKey];\n\n    cachePartialPromises[searchKey] = $.Deferred();\n\n    this.getTemplate(templateName)\n    .then(function (templateSource) {\n        var partials = this.scanForPartials(templateSource);\n        var uniquePartials = partials.filter(function (partialName) {\n            // Check for recursion.\n\n            if (parentage.indexOf(this.currentThemeName + '/' + partialName) >= 0) {\n                // Ignore templates which include a parent template already requested in the current chain.\n                return false;\n            }\n\n            // Ignore templates that include themselves.\n            return partialName != templateName;\n        }.bind(this));\n\n        // Fetch any partial which has not already been fetched.\n        var fetchThemAll = uniquePartials.map(function (partialName) {\n            parentage.push(this.currentThemeName + '/' + partialName);\n            return this.cachePartials(partialName, parentage);\n        }.bind(this));\n\n        // Resolve the templateName promise when all of the children are resolved.\n        return $.when.apply($, fetchThemAll)\n        .then(function () {\n            return cachePartialPromises[searchKey].resolve(templateSource);\n        });\n    }.bind(this))\n    .catch(cachePartialPromises[searchKey].reject);\n\n    return cachePartialPromises[searchKey];\n};\n\n/**\n * Load a template and call doRender on it.\n *\n * @method render\n * @private\n * @param {string} templateName - should consist of the component and the name of the template like this:\n *                              core/menu (lib/templates/menu.mustache) or\n *                              tool_bananas/yellow (admin/tool/bananas/templates/yellow.mustache)\n * @param {Object} context - Could be array, string or simple value for the context of the template.\n * @param {string} themeName - Name of the current theme.\n * @return {Promise} JQuery promise object resolved when the template has been rendered.\n */\nRenderer.prototype.render = function (templateName, context, themeName) {\n    if (typeof (themeName) === \"undefined\") {\n        // System context by default.\n        themeName = config.theme;\n    }\n\n    this.currentThemeName = themeName;\n\n    // Preload the module to do the icon rendering based on the theme iconsystem.\n    var modulename = config.iconsystemmodule;\n\n    var ready = $.Deferred();\n    require([modulename], function (System) {\n        var system = new System();\n        if (!(system instanceof IconSystem)) {\n            ready.reject('Invalid icon system specified' + config.iconsystem);\n        } else {\n            iconSystem = system;\n            system.init().then(ready.resolve).catch(notification.exception);\n        }\n    });\n\n    return ready.then(function () {\n            return this.cachePartials(templateName);\n        }.bind(this)).then(function (templateSource) {\n            return this.doRender(templateSource, context, themeName);\n        }.bind(this));\n};\n\n/**\n * Prepend some HTML to a node and trigger events and fire javascript.\n *\n * @method domPrepend\n * @private\n * @param {jQuery|String} element - Element or selector to prepend HTML to\n * @param {String} html - HTML to prepend\n * @param {String} js - Javascript to run after we prepend the html\n * @return {Array} The list of new DOM Nodes\n * @fires event:filterContentUpdated\n */\nvar domPrepend = function (element, html, js) {\n    var node = $(element);\n    if (node.length) {\n        // Prepend the html.\n        var newContent = $(html);\n        node.prepend(newContent);\n        // Run any javascript associated with the new HTML.\n        runTemplateJS(js);\n        // Notify all filters about the new content.\n        filterEvents.notifyFilterContentUpdated(node);\n\n        return newContent.get();\n    }\n\n    return [];\n};\n\n/**\n * Append some HTML to a node and trigger events and fire javascript.\n *\n * @method domAppend\n * @private\n * @param {jQuery|String} element - Element or selector to append HTML to\n * @param {String} html - HTML to append\n * @param {String} js - Javascript to run after we append the html\n * @return {Array} The list of new DOM Nodes\n * @fires event:filterContentUpdated\n */\nvar domAppend = function (element, html, js) {\n    var node = $(element);\n    if (node.length) {\n        // Append the html.\n        var newContent = $(html);\n        node.append(newContent);\n        // Run any javascript associated with the new HTML.\n        runTemplateJS(js);\n        // Notify all filters about the new content.\n        filterEvents.notifyFilterContentUpdated(node);\n\n        return newContent.get();\n    }\n\n    return [];\n};\n\nexport default {\n    // Public variables and functions.\n    /**\n     * Every call to render creates a new instance of the class and calls render on it. This\n     * means each render call has it's own class variables.\n     *\n     * @method render\n     * @private\n     * @param {string} templateName - should consist of the component and the name of the template like this:\n     *                              core/menu (lib/templates/menu.mustache) or\n     *                              tool_bananas/yellow (admin/tool/bananas/templates/yellow.mustache)\n     * @param {Object} context - Could be array, string or simple value for the context of the template.\n     * @param {string} themeName - Name of the current theme.\n     * @return {Promise} JQuery promise object resolved when the template has been rendered.\n     */\n    render: function (templateName, context, themeName) {\n        var renderer = new Renderer();\n        return renderer.render(templateName, context, themeName);\n    },\n\n    /**\n     * Prefetch a set of templates without rendering them.\n     *\n     * @method getTemplate\n     * @param {Array} templateNames The list of templates to fetch\n     * @param {String} themeName\n     * @returns {Promise}\n     */\n    prefetchTemplates: function (templateNames, themeName) {\n        var renderer = new Renderer();\n\n        if (typeof themeName === \"undefined\") {\n            // System context by default.\n            themeName = config.theme;\n        }\n\n        return renderer.prefetchTemplates(templateNames, themeName);\n    },\n\n    /**\n     * Every call to render creates a new instance of the class and calls render on it. This\n     * means each render call has it's own class variables.\n     *\n     * This alernate to the standard .render() function returns the html and js in a single object suitable for a\n     * native Promise.\n     *\n     * @method renderForPromise\n     * @private\n     * @param {string} templateName - should consist of the component and the name of the template like this:\n     *                              core/menu (lib/templates/menu.mustache) or\n     *                              tool_bananas/yellow (admin/tool/bananas/templates/yellow.mustache)\n     * @param {Object} context - Could be array, string or simple value for the context of the template.\n     * @param {string} themeName - Name of the current theme.\n     * @return {Promise} JQuery promise object resolved when the template has been rendered.\n     */\n    renderForPromise: function (templateName, context, themeName) {\n        var renderer = new Renderer();\n        return renderer.render(templateName, context, themeName)\n        .then(function (html, js) {\n            return {\n                html: html,\n                js: js,\n            };\n        });\n    },\n\n    /**\n     * Every call to renderIcon creates a new instance of the class and calls renderIcon on it. This\n     * means each render call has it's own class variables.\n     *\n     * @method renderIcon\n     * @public\n     * @param {string} key - Icon key.\n     * @param {string} component - Icon component\n     * @param {string} title - Icon title\n     * @return {Promise} JQuery promise object resolved when the pix has been rendered.\n     */\n    renderPix: function (key, component, title) {\n        var renderer = new Renderer();\n        return renderer.renderIcon(\n            key,\n            getNormalisedComponent(component),\n            title\n        );\n    },\n\n    /**\n     * Execute a block of JS returned from a template.\n     * Call this AFTER adding the template HTML into the DOM so the nodes can be found.\n     *\n     * @method runTemplateJS\n     * @param {string} source - A block of javascript.\n     */\n    runTemplateJS: runTemplateJS,\n\n    /**\n     * Replace a node in the page with some new HTML and run the JS.\n     *\n     * @method replaceNodeContents\n     * @param {JQuery} element - Element or selector to replace.\n     * @param {String} newHTML - HTML to insert / replace.\n     * @param {String} newJS - Javascript to run after the insertion.\n     * @return {Array} The list of new DOM Nodes\n     */\n    replaceNodeContents: function (element, newHTML, newJS) {\n        return domReplace(element, newHTML, newJS, true);\n    },\n\n    /**\n     * Insert a node in the page with some new HTML and run the JS.\n     *\n     * @method replaceNode\n     * @param {JQuery} element - Element or selector to replace.\n     * @param {String} newHTML - HTML to insert / replace.\n     * @param {String} newJS - Javascript to run after the insertion.\n     * @return {Array} The list of new DOM Nodes\n     */\n    replaceNode: function (element, newHTML, newJS) {\n        return domReplace(element, newHTML, newJS, false);\n    },\n\n    /**\n     * Prepend some HTML to a node and trigger events and fire javascript.\n     *\n     * @method prependNodeContents\n     * @param {jQuery|String} element - Element or selector to prepend HTML to\n     * @param {String} html - HTML to prepend\n     * @param {String} js - Javascript to run after we prepend the html\n     * @return {Array} The list of new DOM Nodes\n     */\n    prependNodeContents: function (element, html, js) {\n        return domPrepend(element, html, js);\n    },\n\n    /**\n     * Append some HTML to a node and trigger events and fire javascript.\n     *\n     * @method appendNodeContents\n     * @param {jQuery|String} element - Element or selector to append HTML to\n     * @param {String} html - HTML to append\n     * @param {String} js - Javascript to run after we append the html\n     * @return {Array} The list of new DOM Nodes\n     */\n    appendNodeContents: function (element, html, js) {\n        return domAppend(element, html, js);\n    },\n};\n"],"names":["uniqInstances","templateCache","templatePromises","cachePartialPromises","iconSystem","loadTemplateBuffer","isLoadingTemplates","disallowedNestedHelpers","getNormalisedComponent","component","getTemplatePromiseFromCache","searchKey","$","Deferred","resolve","promise","M","cfg","templaterev","cached","storage","get","processLoadTemplateBuffer","length","templatesToLoad","slice","serverRequestsDeferred","requests","map","templateData","name","theme","templateDeferred","deferred","cachedPromise","push","methodname","args","template","themename","lang","attr","replace","index","then","promises","response","templateSource","templates","forEach","data","tempSearchKey","join","value","set","strings","str","cache_strings","key","source","catch","error","reject","ajax","call","when","apply","splice","Renderer","requiredStrings","requiredJS","requiredDates","currentThemeName","prototype","getTemplate","templateName","currentTheme","this","existingBufferRecords","filter","record","parts","split","shift","prefetchTemplates","templateNames","partialHelper","notification","exception","Error","renderIcon","title","modulename","config","iconsystemmodule","ready","require","System","system","IconSystem","init","getTemplateName","bind","pixHelper","context","sectionText","helper","text","trim","jsHelper","stringHelper","param","match","parsedParam","JSON","parse","err","window","console","warn","message","cleanStringHelper","quoteHelper","content","stringify","shortenTextHelper","Truncate","truncate","words","ellipsis","userDateHelper","timestamp","format","addHelperFunction","helperFunction","originalHelpers","reduce","carry","hasOwnProperty","helperName","result","addHelpers","themeName","uniqid","cleanstr","pix","js","quote","shortentext","userdate","globals","getJS","treatStringsInContent","treated","strIndex","walker","char","strFinal","isClean","pattern","search","substring","substr","parseInt","Log","debug","mustache","escape","treatDatesInContent","dates","date","re","RegExp","doRender","iconTemplate","pendingPromise","Pending","render","html","get_strings","UserDate","runTemplateJS","newscript","append","domReplace","element","newHTML","newJS","replaceChildNodes","replaceNode","newNodes","Y","NodeList","children","destroy","empty","replaceWith","filterEvents","notifyFilterContentUpdated","scanForPartials","tokens","partials","findPartial","i","token","cachePartials","parentage","fetchThemAll","partialName","indexOf","iconsystem","renderer","renderForPromise","renderPix","replaceNodeContents","prependNodeContents","node","newContent","prepend","domPrepend","appendNodeContents","domAppend"],"mappings":"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"}